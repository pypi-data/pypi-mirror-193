# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['webuuid']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'webuuid',
    'version': '0.1.2',
    'description': 'Optimize UUID for web services',
    'long_description': '![Tests](https://github.com/JGoutin/webuuid/workflows/tests/badge.svg)\n[![codecov](https://codecov.io/gh/JGoutin/webuuid/branch/main/graph/badge.svg?token=mgtUTV7PwM)](https://codecov.io/gh/JGoutin/webuuid)\n[![PyPI](https://img.shields.io/pypi/v/webuuid.svg)](https://pypi.org/project/webuuid)\n\n# WebUuid: Optimized UUID primary key for web services\n\n## Why using this library ?\n\nThis library as been created to help solve the following question: What is the best\nformat for ID in a web service and its database ?\n\nThe library trie to answer this question using modern UUID and short user-friendly \nstring representation.\n\n### Why using UUID instead of auto-incrementing integer with SQL databases ?\n\nTraditionally, auto-incrementing integer are used as Primary keys in databases.\nBut, UUID are also a good candidate for the following reasons:\n\nPros:\n\n* **Offline generation:** Auto-incrementing require to call the database first and \n  insert a row to generate the ID value. With UUID, the ID can be generated everywhere,\n  and eventually write in the database later if required.\n* **Security/Privacy:** UUID is not guessable. If an integer is used as ID and an API \n  allow to query using this ID anyone can easily try to guess ID values to list, count \n  or get some data. This can lead to data leak that can be a security or privacy issue.\n* **Uniqueness & collision resistance:** When running a service on a scalable \n  environment (With multiple concurrent servers) or on multiple environments with data \n  that may need to be merged, using auto-incrementing integer will likely lead to \n  collisions (Or complex setup/data reconciliation to avoid it).\n  UUID are optimized for almost perfect uniqueness (see below), so there is not such \n  problem like this with them.\n\nCons:\n\n* **Storage size:** Auto-incrementing integer are smallest in database \n  (4 or 8 bytes instead of 16 bytes).\n\nFixed cons:\n\n* **SQL Insert performance:** UUID1 to UUID5 are not time sortable, so inserting them in\n  a large table lead to a performance penalty.\n  Fortunately, with RFC-4122(rev1), there is now UUID6 and UUID7 that are time \n  sortable. This library use UUID7 by default, or UUID8 with sortable timestamp when \n  used with node.\n* **Privacy**: UUID1 uses MAC address in its "node" part, this have privacy issue.\n  There is no privacy issue with UUID7 that rely on random data instead.\n\n### Why using "short" UUID string format instead of common UUID format ?\n\nThe RFC-4122 provides a standard string representation format \n(like `f81d4fae-7dec-11d0-a765-00a0c91e6bf6`) based on hexadecimal representation.\n\nBut, there are many other way to encode some bytes in strings, and it is easy to convert\nthe UUID between all of its formats if required.\n\n#### Popularity and compatibility\n\nRFC-4648 base64 and base32 are very common bytes encoding codecs and are easily \navailable in many programming languages and common libraries.\n\nThere is some alternate base32 like codecs, but not standardized and not as common,\nwe\'ll not use them here.\n\n#### Size \n\nThe RFC-4122 standard UUID string representation is 36 characters length \n(or eventually 32 characters length if keeping only the hexadecimal part)\n\nThe equivalent size for RFC-4648 base32 is 26 characters (-27%) and 22 characters (-38%)\nfor RFC-4648 base64 (without padding in both cases). The storage is more efficient than\nhexadecimal. This allows to reduce the traffic in web service requests.\n\n#### User-friendliness\n\nThe main advantage of the RFC-4122 format is that it is easy to read the internal\nUUID bytes format in it. But, in practices, users don\'t need to know that the used UUID \nis an UUID7 or 8. So this is not relevant in the use case of a web service.\n\nTo be user-friendly an ID should be easy to read, compare and copy by the user \n(Not only with copy/paste).\n\nBase32 is case-insensitive and characters that can be confused are not used in its \nalphabet, this make it more user-friendly than base64. The reduced size also improve \nuser-friendliness in comparison with hexadecimal notation. So base32 is a good \ncompromise.\n\n### About uniqueness\n\nSince UUID7 as a fixed number of possible values and use a random part, there is still\na very low statistical chance that two generated UUID are identical.\nThis represents 1/18889465931478580854784 chance to have two identical UUID, \nand that apply only for a period of 1 millisecond. \n\nThis can be managed by:\n\n* EASY SOLUTION: Adding a "unique" clause in database that will raise an error when\n  trying to insert the duplicated UUID row.\n* MEDIUM SOLUTION: In addition of the previous solution, the application code may \n handle this case and retry with another ID if a duplicate is detected.\n* MISSION CRITICAL SOLUTION: Using UUID8 with node and ensure this node is unique in \n  your application.\n\n## Features:\n\n * Optimized for database use (Size and performance).\n * Short and user-friendly string representation (With many options).\n * Possibility to use a custom "node" part to help guarantee uniqueness in mission \n   critical application. \n * Possibility to import a UUID from any 16 bytes length binary in many format and types\n  (`bytes`, `int`, `str`, `uuid.UUID`, ...).\n * Possibility to create UUID from a hash to help with deduplication.\n * Included Pydantic support.\n * Fully typped.\n * No external dependencies and pure Python.\n * Easy subclassing.\n\n## Installation\n\nWebUuid is available on PyPI, so it can be installed like any other Python package.\n\nExample with Pip:\n```bash\npip install webuuid\n```\n\nWebUuid does not require any external dependency and is a pure Python library.\n\n## Usage\n\n### UUID generation\n\nBy default, is the class is used without argument, a new UUID7 is generated:\n\n```python\nimport webuuid\n\n\nwebuuid.Uuid()\n```\n\nThe class can also be loaded from any 16 bytes length object or its representation as \nsource:\n\n```python\nimport base64\nimport os\nimport webuuid\n\n\n# Using byte-like objects as source\nbytes_obj = os.urandom(16)\nwebuuid.Uuid(bytes_obj)\n\nmemoryview_obj = memoryview(bytes_obj)\nwebuuid.Uuid(memoryview_obj)\n\nbytearray_obj = bytearray(bytes_obj)\nwebuuid.Uuid(bytearray_obj)\n\n# Using int as source\nint_obj = int.from_bytes(bytes_obj, "big")\nwebuuid.Uuid(int_obj)\n\n# Using base64/base32/hexadecimal str representations\nbase32_obj = base64.b32encode(bytes_obj).decode()\nwebuuid.Uuid(base32_obj)\n\nbase64_obj = base64.b64encode(bytes_obj).decode()\nwebuuid.Uuid(base64_obj)\n\nbase64url_obj = base64.urlsafe_b64encode(bytes_obj).decode()\nwebuuid.Uuid(base64url_obj)\n\nhex_obj = bytes_obj.hex()\nwebuuid.Uuid(hex_obj)\n\n# Using base64/base32 str representations without padding\nwebuuid.Uuid(base32_obj.rstrip("="))\nwebuuid.Uuid(base64_obj.rstrip("="))\nwebuuid.Uuid(base64url_obj.rstrip("="))\n```\n\nA standard library `uuid.UUID` can also be used as source:\n\n```python\nimport uuid\nimport webuuid\n\n\nstdlib_uuid = uuid.uuid4()\n\n# Using standard UUID as source\nuuid_obj = webuuid.Uuid(stdlib_uuid)\nwebuuid.Uuid(str(stdlib_uuid))\n\n# Going back to standard library UUID\nuuid.UUID(bytes=uuid_obj)\n```\n\n#### UUID with custom node\n\nIt is also possible to generate a new UUID with a custom "node". This is mainly be \nuseful if you do not want relly entirely on randomness to improve the collision \nresistance.\nIn this case the node need be unique in all your application and may be \ngenerated/validated against a centralized registry or using a base value that is unique\nby design (Example: in a Cloud environment, server/instance ID and process ID).\n\nIn the case, the first 64 bits of the UUID are generated normally \n(With 48 bits of timestamp and 10 random bits), the 64 endings bytes (Ignoring version \nand variant fields) are the custom node.\n\n```python\nimport webuuid\nimport os\n\n\n# Using a random value as node\nnode = urandom(8)\n\n# Generation from node\nmy_uuid = webuuid.Uuid(node=node)\n\n# The node can be accessed using the following property\nmy_uuid.node\n```\n\nIn the case, the generated UUID wil be an UUID8 instead of an UUID7.\n\n#### UUID from hash\n\nIt is possible to generate a UUID using the hash of a byte-like input data. This can be \nuseful for tables that need deduplication on row IDs.\n\nIn this case, like any hash, the UUID is always the same for the same input data.\nThere is no timestamp in the UUID, so it is not time sortable and can have a negative \nimpact on the database performance on INSERT in large tables.\n\n```python\nimport webuuid\nimport json\n\n\ndata = json.dumps({"key": "value"}).encode()\nmy_uuid = webuuid.Uuid.from_hash(data)\n```\n\nIn the case, the generated UUID will be an UUID8 instead of an UUID7.\n\nThe hash function used is `blake2b`.\n\n### UUID class features\n\nThe `webuuid.Uuid` class is a subclass of `bytes` and supports all the bytes objects\nstandards features with the following changes:\n\n* `webuuid.Uuid.decode()` returns an encoded `str` representation using the\n  base32 encoding (By default, but can be easily changed) instead of the classical UTF-8\n  encoding.\n* Using `str()` on `webuuid.Uuid` objects returns the same result as \n  `webuuid.Uuid.decode()`.\n* `webuuid.Uuid` can be compared with other `webuuid.Uuid` or byte-like objects but also\n  with any `str`, `uuid.UUID` or `int` that can be used as input with `webuuid.Uuid`\n  directly.\n* `int()` can be used directly  on `webuuid.Uuid` objects. \n\nIn addition to bytes features, the class provides some methods to convert it to various\n`str` representations:\n* `webuuid.Uuid.base32()`: RFC-4648 Base 32 representation (Without padding by default).\n* `webuuid.Uuid.base64()`: RFC-4648 Base 64 representation (Without padding by default).\n* `webuuid.Uuid.base64url()`: RFC-4648 Base 64 URL safe representation (Without padding \n  by default).\n* `webuuid.Uuid.standard_hex()`: RFC-4122 UUID hexadecimal representation.\n\n#### String representation customization\n\nThe `webuuid.Uuid` class use the RFC-4648 Base 32 without padding `str` representation \nby default.\n\nThe library also provides the following classes that use a different default \nrepresentation:\n* `webuuid.UuidBase64`: RFC-4648 Base 64 without padding.\n* `webuuid.UuidBase64Url`: RFC-4648 Base 64 URL safe without padding.\n\nThe class can also easily be subclassed to use any representation of your choice as\ndefault output, but also as input:\n\n```python\nimport webuuid\n\n\ndef custom_encoder(\n    value: bytes, encoding: str = "utf-8", errors: str = "strict"\n) -> str:\n    """Custom encoder.\n    \n    Args:\n        value: UUID bytes input value.\n        encoding: See `bytes.decode()` argument.\n        errors: See `bytes.decode()` argument.\n    """\n    # Custom codec implementation\n\n\ndef custom_decoder(value: str) -> bytes:\n    """Custom decoder.\n\n    Args:\n        value: Input string value.\n    """\n    # Custom codec implementation\n\n\nclass CustomUuid(webuuid.Uuid):\n    """Custom UUID that only support the specified codec."""\n\n    # Set custom codec\n    STR_ENCODER = custom_encoder\n    FALLBACK_STR_DECODER = custom_decoder\n\n    # Disable other codecs.\n    STR_DECODERS = dict()\n\n\nclass CustomCompatibleUuid(webuuid.Uuid):\n    """Custom UUID that add the support for an extra codec."""\n\n    # Set custom encoder\n    STR_ENCODER = custom_encoder\n\n    # Add customer decoder.\n    # In this example the encoder generate a 48 characters length str\n    STR_DECODERS = webuuid.Uuid.STR_DECODERS.copy()\n    STR_DECODERS[48] = custom_decoder\n```\n\n### Usage with other libraries\n\nThis part give some tips on how to use WebUuid with some common libraries.\n\n#### JSON serialization/deserialization\n\nIn web application it is very common to serialize/deserialize data in JSON. By default,\nthe standard `json` library (And compatible alternative) only supports base Python \ntypes, but it is easy to add the `webuuid.Uuid` support to it:\n\n```python\nimport json\nimport typing\nimport webuuid\n\n\ndef json_default_uuid(obj: typing.Any) -> typing.Any:\n    """webuuid.uuid JSON serializer.\n\n    Args:\n        obj: Object to serialize.\n    """\n    if isinstance(obj, webuuid.Uuid):\n        return str(obj)\n    raise TypeError\n\n\n# Serializing object with UUID\ndata = {"id": webuuid.Uuid()}\njson.loads(data, default=json_default_uuid)\n```\n\nSome more high level libraries provides feature to register JSON encoders or `default` \nfunction for automatic use.\n\n#### Pydantic\n\n[Pydantic](https://github.com/pydantic/pydantic) is a data validation library. \nIt is notably used with the [FastAPI](https://fastapi.tiangolo.com/) web framework.\n\n`webuuid.Uuid` as native Pydantic support with validator and schema:\n\n```python\nimport pydantic\nimport webuuid\n\n\nclass Model(pydantic.BaseModel):\n    """Pydantic model."""\n    \n    class Config:\n        """Config."""\n\n        # Automatically JSON serialize UUID to its string representation\n        json_encoders = {webuuid.Uuid: str}\n\n    # UUID field\n    id: webuuid.Uuid\n    \n    # UUID Field generating a default new value if not specified\n    value: webuuid.Uuid = pydantic.Field(default_factory=webuuid.Uuid)\n```\n\nOn custom subclass, the schema can easily be customized by overriding the \n`webuuid.Uuid.FIELD_SCHEMA` class dictionary.\n\n#### Databases libraries\n\nIn databases, the UUID can be stored in a 16 bytes length binary column,\nlike BINARY(16). Depending on the library used and the database engine, the type and the\nsyntax to use may vary.\n\n##### SQLAlchemy\n\nWith [SQLAlchemy](https://www.sqlalchemy.org/), the UUID can be stored using the\n`LargeBinary(length=16)` type. SQLAlchemy will use the proper type for the required \ndatabase engine behind the scene.\n\n```python\nimport sqlalchemy\n\n\nmetadata = sqlalchemy.MetaData()\n\ntable = Table(\n    "table_name",\n    metadata,\n    sqlalchemy.Column(\n        "uuid",\n        sqlalchemy.LargeBinary(length=16),\n        primary_key=True,\n        index=True\n    ),\n)\n```\n',
    'author': 'JGoutin',
    'author_email': 'None',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/JGoutin/webuuid',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
