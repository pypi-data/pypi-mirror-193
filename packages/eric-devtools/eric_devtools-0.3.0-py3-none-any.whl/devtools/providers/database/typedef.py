import enum
from typing import Any, Iterable, Protocol

from sqlalchemy.pool import StaticPool

from devtools.models import Model


class DriverTypes(Protocol):
    port: int
    has_config: bool
    async_driver: str
    sync_driver: str
    required_fields: list[str]
    config: dict[str, Any]

    def get_connection_template(self, *, is_async: bool) -> str:
        ...

    def timeout_arg_name(self, *, is_async: bool) -> str:
        ...


class PostgresDriver:
    """Driver Default values for PostgreSQL Connection"""

    port = 5432
    async_driver = "postgresql+asyncpg"
    sync_driver = "postgresql+psycopg2"
    has_config = False
    required_fields = ["user", "password", "host", "port", "name"]
    config: dict[str, Any] = {}

    def get_connection_template(self, *, is_async: bool) -> str:
        """Returns autogenerated driver uri for sqlalchemy create_engine()"""
        driver_prefix = self.async_driver if is_async else self.sync_driver
        return f"{driver_prefix}://" "{user}:{password}@{host}:{port}/{name}"

    def timeout_arg_name(self, *, is_async: bool) -> str:
        return "timeout" if is_async else "connect_timeout"


class SqliteDriver:
    port = 0
    async_driver = "sqlite+aiosqlite"
    sync_driver = "sqlite"
    has_config = True
    required_fields = ["host"]

    config = {
        "connect_args": {"check_same_thread": False},
        "poolclass": StaticPool,
    }

    def get_connection_template(self, is_async: bool) -> str:
        driver_prefix = self.async_driver if is_async else self.sync_driver
        return f"{driver_prefix}" ":///{host}"

    def timeout_arg_name(self, *, is_async: bool) -> str:
        del is_async
        return "timeout"


class Driver(str, enum.Enum):
    POSTGRES = "postgres"
    SQLITE = "sqlite"


DRIVER_MAPPING: dict[Driver, DriverTypes] = {
    Driver.POSTGRES: PostgresDriver(),
    Driver.SQLITE: SqliteDriver(),
}


IterableToDict = Iterable[tuple[Any, Any]]


class SupportsKeyAndGetItem(Protocol):
    def keys(self) -> Iterable[Any]:
        ...

    def __getitem__(self, __k: Any) -> Any:
        ...


DictConvertable = IterableToDict | SupportsKeyAndGetItem | Model | dict
