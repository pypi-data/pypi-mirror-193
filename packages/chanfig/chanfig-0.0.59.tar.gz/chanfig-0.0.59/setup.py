# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['chanfig']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'chanfig',
    'version': '0.0.59',
    'description': 'Easier Configuration',
    'long_description': '# [CHANfiG](https://chanfig.danling.org)\n\n## Introduction\n\nCHANfiG aims to make your configuration easier.\n\nThere are tons of configurable parameters in training a Machine Learning model.\nTo configure all these parameters, researchers usually need to write gigantic config files, sometimes even thousands of lines.\nMost of the configs are just replicates of the default arguments of certain functions, resulting in many unnecessary declarations.\nIt is also very hard to alter the configurations.\nOne needs to navigate and open the right configuration file, make changes, save and exit.\nThese had wasted an uncountable[^uncountable] amount of precious time ~~and are no doubt a crime~~.\nUsing `argparse` could relieve the burdens to some extent.\nHowever, it takes a lot of work to make it compatible with existing config files, and its lack of nesting limits its potential.\n\nCHANfiG would like to make a change.\n\nYou just type the alternations in the command line, and leave everything else to CHANfiG.\n\nCHANfiG is highly inspired by [YACS](https://github.com/rbgirshick/yacs).\nDifferent from the paradigm of YACS(\n`your code + a YACS config for experiment E (+ external dependencies + hardware + other nuisance terms ...) = reproducible experiment E`),\nThe paradigm of CHANfiG is:\n\n`your code + command line arguments (+ optional CHANfiG config + external dependencies + hardware + other nuisance terms ...) = reproducible experiment E (+ optional CHANfiG config for experiment E)`\n\n## Components\n\nA Config is basically a nested dict structure.\n\nHowever, the default Python dict is hard to manipulate.\n\nThe only way to access a dict member is through `dict[\'name\']`, which is obviously extremely complex.\nEven worse, if the dict is nested like a config, member access could be something like `dict[\'parent\'][\'children\'][\'name\']`.\n\nEnough is enough, it is time to make a change.\n\nWe need attribute-style access, and we need it now.\n\nAlthough there have been some other works that achieve a similar functionality of attribute-style access to dict members.\nTheir Config objects either use a separate dict to store information from attribute-style access (EasyDict), which may lead to inconsistency between attribute-style access and dict-style access;\nor re-use the existing `__dict__` and redirect dict-style access (ml_collections), which may result in confliction between attributes and members of Config.\n\nTo overcome the aforementioned limitations, we inherit the Python built-in `dict` to create `FlatDict`, `NestedDict`, and `Config` objects.\n\n### FlatDict\n\n`FlatDict` improves the default `dict` in 3 aspects.\n\n`FlatDict` also accepts `default_factory`, and can be easily used as `defaultdict`.\n\n#### Dict Operations\n\n`FlatDict` extends the `update` method of the original `dict`, allows passing another `Mapping`, `Iterable` or a path.\n\nMoreover, `FlatDict` comes with `difference` and `intersection`, which makes it very easy to compare a `FlatDict` with other `Mapping`, `Iterable`, or a path.\n\n#### ML Operations\n\n`FlatDict` supports the `to` method similar to PyTorch Tensors.\nYou can simply convert all member values of `FlatDict` to a certain type or pass to a device in the same way.\n\n`FlatDict` also integrates `cpu`, `gpu`, and `tpu` methods for easier access.\n\n#### IO Operations\n\n`FlatDict` provides `json`, `jsons`, `yaml` and `yamls` methods to dump `FlatDict` object to a file or string.\nIt also provides `from_json`, `from_jsons`, `from_yaml` and `from_yamls` methods to build a `FlatDict` object from a string or file.\n\n`FlatDict` also includes `dump` and `load` methods which determines the type by its extension and dump/load `FlatDict` object to/from a file.\n\n### NestedDict\n\nSince most Configs are in a nested structure, we further propose a `NestedDict`.\n\nBased on `FlatDict`, `NestedDict` provides `all_keys`, `all_values`, and `all_items` methods to allow iterating over the whole nested structure at once.\n\n`NestedDict` also comes with `apply` method, which made it easier to manipulate nested structures.\n\n### Config\n\n`Config` extends the functionality by supporting `freeze` and `defrost` the dict, and by adding a built-in `ConfigParser` to pare command line arguments.\n\nNote that `Config` also has `default_factory=Config()` by default for convenience.\n\n### Variable\n\nHave one value for multiple names at multiple places? We got you covered.\n\nJust wrap the value with `Variable`, and one alteration will be reflected everywhere.\n\n## Usage\n\nCHANfiG has great backward compatibility with previous configs.\n\nNo matter if your old config is json or yaml, you could directly read from them.\n\nAnd if you are using yacs, just replace `CfgNode` with `Config` and enjoy all the additional benefits that CHANfiG provides.\n\n```python\nfrom chanfig import Config, Variable\n\n\nclass Model:\n    def __init__(self, encoder, dropout=0.1, activation=\'ReLU\'):\n        self.encoder = Encoder(**encoder)\n        self.dropout = Dropout(dropout)\n        self.activation = getattr(Activation, activation)\n\ndef main(config):\n    model = Model(**config.model)\n    optimizer = Optimizer(**config.optimizer)\n    scheduler = Scheduler(**config.scheduler)\n    dataset = Dataset(**config.dataset)\n    dataloader = Dataloader(**config.dataloader)\n\n\nclass TestConfig(Config):\n    def __init__(self):\n        super().__init__()\n        dropout = Variable(0.1)\n        self.name = "CHANfiG"\n        self.seed = 1013\n        self.data.batch_size = 64\n        self.model.encoder.num_layers = 6\n        self.model.decoder.num_layers = 6\n        self.model.dropout = dropout\n        self.model.encoder.dropout = dropout\n        self.model.decoder.dropout = dropout\n        self.activation = "GELU"\n        self.optim.lr = 1e-3\n\n    def post(self):\n        self.id = f"{self.name}_{self.seed}"\n\n\nif __name__ == \'__main__\':\n    # config = Config.load(\'config.yaml\')  # in case you want to read from a yaml\n    # config = Config.load(\'config.json\')  # in case you want to read from a json\n    # existing_configs = {\'data.batch_size\': 64, \'model.encoder.num_layers\': 8}\n    # config = Config(**existing_configs)  # in case you have some config in dict to load\n    config = TestConfig()\n    config = config.parse()\n    # config.update(\'dataset.yaml\')  # in case you want to merge a yaml\n    # config.update(\'dataset.json\')  # in case you want to merge a json\n    # note that the value of merge will override current values\n    config.model.decoder.num_layers = 8\n    config.freeze()\n    print(config)\n    # main(config)\n    # config.yaml(\'config.yaml\')  # in case you want to save a yaml\n    # config.json(\'config.json\')  # in case you want to save a json\n```\n\nAll you need to do is just run a line:\n\n```shell\npython main.py --model.encoder.num_layers 8 --model.dropout=0.2\n```\n\nYou could also load a default configure file and make changes based on it:\n\nNote, you must specify `config.parse(default_config=\'config\')` to correctly load the default config.\n\n```shell\npython main.py --config meow.yaml --model.encoder.num_layers 8 --model.dropout=0.2\n```\n\nIf you have made it dump current configurations, this should be in the written file:\n\n```yaml\nactivation: GELU\ndata:\n  batch_size: 64\nid: CHANfiG_1013\nmodel:\n  decoder:\n    dropout: 0.1\n    num_layers: 6\n  dropout: 0.1\n  encoder:\n    dropout: 0.1\n    num_layers: 6\nname: CHANfiG\noptim:\n  lr: 0.001\nseed: 1013\n```\n\n```json\n{\n  "name": "CHANfiG",\n  "seed": 1013,\n  "data": {\n    "batch_size": 64\n  },\n  "model": {\n    "encoder": {\n      "num_layers": 6,\n      "dropout": 0.1\n    },\n    "decoder": {\n      "num_layers": 6,\n      "dropout": 0.1\n    },\n    "dropout": 0.1\n  },\n  "activation": "GELU",\n  "optim": {\n    "lr": 0.001\n  },\n  "id": "CHANfiG_1013"\n}\n```\n\nDefine the default arguments in function, put alterations in CLI, and leave the rest to CHANfiG.\n\n## Installation\n\nInstall the most recent stable version on pypi:\n\n```shell\npip install chanfig\n```\n\nInstall the latest version from source:\n\n```shell\npip install git+https://github.com/ZhiyuanChen/CHANfiG\n```\n\nIt works the way it should have worked.\n\n## License\n\nCHANfiG is multi-licensed under the following licenses:\n\n- Unlicense\n- GNU GPL 2.0 (or any later version)\n- MIT\n- Apache 2.0\n- BSD 2-Clause\n- BSD 3-Clause\n\nYou can choose any (one or more) of them if you use this work.\n\n`SPDX-License-Identifier: Unlicense OR GPL-2.0-or-later OR MIT OR Apache-2.0 OR BSD-2-Clause OR BSD-3-Clause`\n\n[^uncountable]: fun fact: time is always uncountable.\n',
    'author': 'Zhiyuan Chen',
    'author_email': 'this@zyc.ai',
    'maintainer': 'Zhiyuan Chen',
    'maintainer_email': 'this@zyc.ai',
    'url': 'https://chanfig.danling.org',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3,<4',
}


setup(**setup_kwargs)
