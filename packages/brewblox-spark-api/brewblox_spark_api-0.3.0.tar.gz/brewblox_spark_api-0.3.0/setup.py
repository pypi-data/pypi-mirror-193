# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['brewblox_spark_api']

package_data = \
{'': ['*']}

install_requires = \
['brewblox-service>=1.0.0,<2.0.0']

setup_kwargs = {
    'name': 'brewblox-spark-api',
    'version': '0.3.0',
    'description': 'Client-side API for consuming Spark blocks',
    'long_description': '# Boilerplate code for Brewblox service implementations\n\nThere is some boilerplate code involved when creating a Brewblox service.\nThis repository can be forked to avoid having to do the boring configuration.\n\nYou\'re free to use whatever editor or IDE you like, but we preconfigured some useful settings for [Visual Studio Code](https://code.visualstudio.com/).\n\nEverything listed under **Required Changes** must be done before the package works as intended.\n\n## How to use\n\n* Install required dependencies (see below)\n* Fork this repository to your own Github account or project.\n* Follow all steps outlined under the various **Required Changes**.\n* Start coding your service =)\n    * To test, run `poetry run pytest`\n\n\n## Install\n\nInstall [Pyenv](https://github.com/pyenv/pyenv):\n```\nsudo apt-get update -y && sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\\nlibreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\\nxz-utils tk-dev libffi-dev liblzma-dev python-openssl git python3-venv\n\ncurl https://pyenv.run | bash\n```\n\nAfter installing, it may suggest to add initialization code to ~/.bashrc. Do that.\n\nTo apply the changes to ~/.bashrc (or ~/.zshrc), run:\n```\nexec $SHELL --login\n```\n\nInstall Python 3.7:\n```\npyenv install 3.7.7\n```\n\nInstall [Poetry](https://python-poetry.org/)\n```\ncurl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python\n\nexec $SHELL --login\n```\n\nConfigure and install the environment used for this project.\n\n**Run in the root of your cloned project**\n```\npoetry run pip install --upgrade pip\npoetry install\n```\n\nDuring development, you need to have your environment activated.\nWhen it is activated, your terminal prompt is prefixed with `(.venv)`.\n\nVisual Studio code with suggested settings does this automatically whenever you open a .py file.\nIf you prefer using a different editor, you can do it manually by running:\n```\npoetry shell\n```\n\nInstall [Docker](https://www.docker.com/101-tutorial)\n```\ncurl -sL get.docker.com | sh\n\nsudo usermod -aG docker $USER\n\nreboot\n```\n\n## Files\n\n---\n### [pyproject.toml](./pyproject.toml)\nThe [pyproject](https://python-poetry.org/docs/pyproject/) file contains all kinds of Python settings.\nFor those more familiar with Python packaging: it replaces the following files:\n- `setup.py`\n- `MANIFEST.in`\n- `requirements.txt`\n\n**Required Changes:**\n* Change the `name` field to your project name. This is generally the same as the repository name. This name is used when installing the package through Pip. </br> It is common for this name to equal the package name, but using "`-`" as separator instead of "`_`".\n* Change the `authors` field to your name and email.\n\n\n---\n### [tox.ini](./tox.ini)\nDeveloper tools such as [Pytest](https://docs.pytest.org/en/latest/), [Flake8](http://flake8.pycqa.org/en/latest/), and [Autopep8](https://github.com/hhatto/autopep8) use this file to find configuration options.\n\n**Required Changes:**\n* Change `--cov=YOUR_PACKAGE` to refer to your module name.\n* The `--cov-fail-under=100` makes the build fail if code coverage is less than 100%. It is optional, but recommended. Remove the `#` comment character to enable it.\n\n\n---\n### [.env](./.env)\nProject-specific environment variables can be stored here. By default, the name of the Docker repository (more on this below) is set here.\n\n**Required Changes:**\n* Change `DOCKER_REPO=you/your-package` to match the name of your docker image.\n\n\n---\n### [.editorconfig](./.editorconfig)\nThis file contains [EditorConfig](https://editorconfig.org/) configuration for this project. </br>\nAmong other things, it describes per file type whether it uses tabs or spaces.\n\nFor a basic service, you do not need to change anything in this file.\nHowever, it is recommended to use an editor that recognizes and uses `.editorconfig` files.\n\n\n---\n### [README.md](./README.md)\nYour module readme (this file). It will automatically be displayed in Github.\n\n**Required Changes:**\n* Add all important info about your package here. What does your package do? How do you use it? What is your favorite color?\n\n\n---\n### [YOUR_PACKAGE/](./YOUR_PACKAGE/)\n[\\_\\_main\\_\\_.py](./YOUR_PACKAGE/__main__.py),\n[subscribe_example.py](./YOUR_PACKAGE/subscribe_example.py),\n[http_example.py](./YOUR_PACKAGE/http_example.py),\n[publish_example.py](./YOUR_PACKAGE/publish_example.py)\n\nYour module. The directory name is used when importing your code in Python.\n\nYou can find examples for common service actions here.\n\n**Required Changes:**\n* Rename to the desired module name. This name can\'t include "`-`" characters. </br>\nIt is common for single-module projects to use "`-`" as a separator for the project name, and "`_`" for the module. </br>\nFor example: `your-package` and `your_package`.\n* Change the import statements in .py files from `YOUR_PACKAGE` to your package name.\n\n\n---\n### [test/conftest.py](./test/conftest.py)\nShared pytest fixtures for all your tests are defined here.\nThe other test files provide examples on how to use the fixtures.\n\n**Required Changes:**\n* Change the import from `YOUR_PACKAGE` to your package name.\n\n\n---\n### [test/test_http_example.py](./test/test_http_example.py) / [test/test_publish_example.py](./test/test_publish_example.py) / [test/test_subscribe_example.py](./test/test_subscribe_example.py)\nThe test code shows how to test the functionality added by the various examples.\nThis includes multiple tricks for testing async code with pytest.\nYou can remove the files if you no longer need them.\n\n**Required Changes:**\n* Change the import from `YOUR_PACKAGE` to your package name.\n\n\n---\n### [docker/before_build.sh](./docker/before_build.sh)\nDocker builds can only access files in the same directory as the `Dockerfile`.\n\nThe `before_build.sh` copies the dependencies for the Docker build into the docker/ directory.\n\n\n---\n### [docker/Dockerfile](./docker/Dockerfile)\nA docker file for running your package. To build the image for both desktop computers (AMD64), Raspberry Pi (ARM32), and Raspberry Pi 64-bit (ARM64):\n\n\nPrepare the builder (run once per shell):\n``` sh\n# Buildx is an experimental feature\nexport DOCKER_CLI_EXPERIMENTAL=enabled\n\n# Enable the QEMU emulator, required for building ARM images on an AMD computer\ndocker run --rm --privileged multiarch/qemu-user-static --reset -p yes\n\n# Remove previous builder\ndocker buildx rm bricklayer || true\n\n# Create and use a new builder\ndocker buildx create --use --name bricklayer\n\n# Bootstrap the newly created builder\ndocker buildx inspect --bootstrap\n```\n\nBuild:\n``` sh\nREPO=you/your-package\nTAG=local\n\n# Will build your Python package, and copy the results to the docker/ directory\nbash docker/before_build.sh\n\n# Set image name\n# Build the image for multiple architectures\n# - AMD64 -> linux/amd64\n# - ARM32 -> linux/arm/v7\n# - ARM64 -> linux/arm64/v8\n# Push the image to the docker registry\ndocker buildx build \\\n    --tag $REPO:$TAG \\\n    --platform linux/amd64,linux/arm/v7,linux/arm64/v8 \\\n    --push \\\n    docker\n```\n\nWhile you are in the same shell, you don\'t need to repeat the build preparation.\n\nIf you only want to use the image locally, run the build commands like this:\n\n``` sh\nREPO=you/your-package\nTAG=local\n\n# Will build your Python package, and copy the results to the docker/ directory\nbash docker/before_build.sh\n\n# Set image name\n# Load image for local use\n# This only builds for the current architecture (AMD64)\ndocker buildx build \\\n    --tag $REPO:$TAG \\\n    --load \\\n    docker\n```\n\n**Required Changes:**\n* Rename instances of `YOUR-PACKAGE` and `YOUR_PACKAGE` in the docker file to desired project and package names.\n\n---\n### [azure-pipelines.yml](./azure-pipelines.yml)\n[Azure](https://dev.azure.com) can automatically test and deploy all commits you push to GitHub.\nIf you haven\'t enabled Azure Pipelines for your repository: don\'t worry, it won\'t do anything.\n\nTo deploy your software, you will also need to create a [Docker Hub](https://hub.docker.com/) account,\nand register your image as a new repository.\n\n\n## Deployment\n\nOther Brewblox services are published and used as Docker images.\nSetting this up is free and easy, and this repository includes the required configuration.\n\n### Docker Hub\n\nFirst, we\'ll need a Docker Hub account and repository to store created images.\nGo to https://hub.docker.com/ and create an account.\n\nAfter this is done: log in, click on the fingerprint icon, and go to "Account Settings" -> "Security".\nGenerate an access token. We\'ll be using this to log in during CI builds.\n\nNow, go back to the main page by clicking on the Docker Hub logo, and click `create repository`.\nPick a name, and click `create`. You don\'t need to connect the repository.\n\nYou can now push images to `user`/`repository`.\n\n**Don\'t forget to set the DOCKER_REPO field in the .env file**.\n\n### Azure Pipelines\n\nTo automatically build and push those images, you\'ll need a Continuous Integration (CI) server.\nHere we\'ll set up Azure Pipelines as CI service, but you can do the same thing using [Travis](https://travis-ci.org/),\n[CircleCI](https://circleci.com/), [GitHub Actions](https://github.com/features/actions),\n[GitLab](https://about.gitlab.com/solutions/github/) or any of the others.\n\nGo to https://azure.microsoft.com/en-us/services/devops/ and click "Start free with GitHub".\nYou can then connect your GitHub account to Azure.\n\nAfter logging in, create a new project. The name does not matter.\n\nIn the side bar, go to Pipelines, click on Library, and create a new variable group.\nCall this group `brewblox`.\n\nAdd two variables:\n- `DOCKER_USER` is your Docker Hub user name.\n- `DOCKER_PASSWORD` is the access token you generated earlier. Make the value secret by clicking the lock icon.\n\nSave to confirm the group. These variables are now used during CI builds.\n\nAgain in the side bar, go to Pipelines, and create a new Pipeline. Choose GitHub as source, and select your repository.\n\nAzure will automatically detect the `azure-pipelines.yml` file. Click "Run" to initialize it.\nIt will ask you for permission to link Azure to your GitHub repository.\n\nWhen this is done, it will start its first build. You can view the build results on https://dev.azure.com/\n\nThat\'s it. Happy coding!\n',
    'author': 'BrewPi.bv',
    'author_email': 'development@brewpi.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.9,<4',
}


setup(**setup_kwargs)
