{"version":3,"file":"5e702e13.js","mappings":";;AAgDA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;;;;;;;;AA+CA;;;;;;;;;;;;;;;;;;;;ACjEA;ACfA;;;;;;;AAOA;;;;;;;;;AAUA;;;;;;;;;;AAqBA;AAEA;AAGA;;;AAGA;AACA;;AAIA;;AAEA;;;;;AAhCA;;;;;;;;;;;;;;;;;;;;;;;AAkFA;;ACzDA;;;AAIA;;AAEA;;;AAGA;;;;AAIA;;;;;;;;;;AAWA;AAEA;;;;;;AAMA;;AAKA;AACA;;;;;;;AAOA;AAGA;;;;;;;;;;;;;;;;AAgBA;;AAGA;AAEA;AAEA;;;;;;;;;;;;;;AAcA;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4DA;AC5JA;;AAEA;;;AAVA;;AAEA;;AAYA","sources":["webpack://home-assistant-frontend/./src/components/ha-button-menu.ts","webpack://home-assistant-frontend/./src/components/ha-switch.ts","webpack://home-assistant-frontend/./src/panels/config/ais_dom/ais-webhooks.ts","webpack://home-assistant-frontend/./src/panels/config/ais_dom/ha-config-ais-dom-config-remote.ts","webpack://home-assistant-frontend/./src/panels/lovelace/entity-rows/hui-timer-entity-row.ts"],"sourcesContent":["import type { Button } from \"@material/mwc-button\";\nimport \"@material/mwc-menu\";\nimport type { Corner, Menu, MenuCorner } from \"@material/mwc-menu\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { FOCUS_TARGET } from \"../dialogs/make-dialog-manager\";\nimport type { HaIconButton } from \"./ha-icon-button\";\n\n@customElement(\"ha-button-menu\")\nexport class HaButtonMenu extends LitElement {\n  protected readonly [FOCUS_TARGET];\n\n  @property() public corner: Corner = \"TOP_START\";\n\n  @property() public menuCorner: MenuCorner = \"START\";\n\n  @property({ type: Number }) public x: number | null = null;\n\n  @property({ type: Number }) public y: number | null = null;\n\n  @property({ type: Boolean }) public multi = false;\n\n  @property({ type: Boolean }) public activatable = false;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public fixed = false;\n\n  @query(\"mwc-menu\", true) private _menu?: Menu;\n\n  public get items() {\n    return this._menu?.items;\n  }\n\n  public get selected() {\n    return this._menu?.selected;\n  }\n\n  public override focus() {\n    if (this._menu?.open) {\n      this._menu.focusItemAtIndex(0);\n    } else {\n      this._triggerButton?.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <div @click=${this._handleClick}>\n        <slot name=\"trigger\" @slotchange=${this._setTriggerAria}></slot>\n      </div>\n      <mwc-menu\n        .corner=${this.corner}\n        .menuCorner=${this.menuCorner}\n        .fixed=${this.fixed}\n        .multi=${this.multi}\n        .activatable=${this.activatable}\n        .y=${this.y}\n        .x=${this.x}\n      >\n        <slot></slot>\n      </mwc-menu>\n    `;\n  }\n\n  protected firstUpdated(changedProps): void {\n    super.firstUpdated(changedProps);\n\n    if (document.dir === \"rtl\") {\n      this.updateComplete.then(() => {\n        this.querySelectorAll(\"mwc-list-item\").forEach((item) => {\n          const style = document.createElement(\"style\");\n          style.innerHTML =\n            \"span.material-icons:first-of-type { margin-left: var(--mdc-list-item-graphic-margin, 32px) !important; margin-right: 0px !important;}\";\n          item!.shadowRoot!.appendChild(style);\n        });\n      });\n    }\n  }\n\n  private _handleClick(): void {\n    if (this.disabled) {\n      return;\n    }\n    this._menu!.anchor = this;\n    this._menu!.show();\n  }\n\n  private get _triggerButton() {\n    return this.querySelector(\n      'ha-icon-button[slot=\"trigger\"], mwc-button[slot=\"trigger\"]'\n    ) as HaIconButton | Button | null;\n  }\n\n  private _setTriggerAria() {\n    if (this._triggerButton) {\n      this._triggerButton.ariaHasPopup = \"menu\";\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: inline-block;\n        position: relative;\n      }\n      ::slotted([disabled]) {\n        color: var(--disabled-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-button-menu\": HaButtonMenu;\n  }\n}\n","import { SwitchBase } from \"@material/mwc-switch/deprecated/mwc-switch-base\";\nimport { styles } from \"@material/mwc-switch/deprecated/mwc-switch.css\";\nimport { css } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { forwardHaptic } from \"../data/haptics\";\n\n@customElement(\"ha-switch\")\nexport class HaSwitch extends SwitchBase {\n  // Generate a haptic vibration.\n  // Only set to true if the new value of the switch is applied right away when toggling.\n  // Do not add haptic when a user is required to press save.\n  @property({ type: Boolean }) public haptic = false;\n\n  protected firstUpdated() {\n    super.firstUpdated();\n    this.addEventListener(\"change\", () => {\n      if (this.haptic) {\n        forwardHaptic(\"light\");\n      }\n    });\n  }\n\n  static override styles = [\n    styles,\n    css`\n      :host {\n        --mdc-theme-secondary: var(--switch-checked-color);\n      }\n      .mdc-switch.mdc-switch--checked .mdc-switch__thumb {\n        background-color: var(--switch-checked-button-color);\n        border-color: var(--switch-checked-button-color);\n      }\n      .mdc-switch.mdc-switch--checked .mdc-switch__track {\n        background-color: var(--switch-checked-track-color);\n        border-color: var(--switch-checked-track-color);\n      }\n      .mdc-switch:not(.mdc-switch--checked) .mdc-switch__thumb {\n        background-color: var(--switch-unchecked-button-color);\n        border-color: var(--switch-unchecked-button-color);\n      }\n      .mdc-switch:not(.mdc-switch--checked) .mdc-switch__track {\n        background-color: var(--switch-unchecked-track-color);\n        border-color: var(--switch-unchecked-track-color);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-switch\": HaSwitch;\n  }\n}\n","import { html, LitElement, PropertyDeclarations } from \"lit\";\nimport {property} from 'lit/decorators';\nimport \"@polymer/paper-item/paper-item\";\nimport \"@polymer/paper-item/paper-item-body\";\nimport \"../../../components/ha-card\";\n\nimport { HomeAssistant } from \"../../../types\";\nimport { Webhook, fetchWebhooks } from \"../../../data/webhook\";\n\nimport { showManageCloudhookDialog } from \"./dialog-manage-ais-cloudhook/show-dialog-manage-ais-cloudhook\";\n\nexport class AisWebhooks extends LitElement {\n  @property() public hass?: HomeAssistant;\n\n  @property() private _localHooks?: Webhook[];\n\n  static get properties(): PropertyDeclarations {\n    return {\n      hass: {},\n      _localHooks: {},\n    };\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    this._fetchData();\n  }\n\n  protected render() {\n    return html`\n      ${this.renderStyle()}\n      <ha-card header=\"Wywołania zwrotne HTTP\">\n        <div class=\"card-content\">\n          Wywołania zwrotne HTTP (Webhook) używane są do udostępniania\n          powiadomień o zdarzeniach. Wszystko, co jest skonfigurowane do\n          uruchamiania przez wywołanie zwrotne, ma publicznie dostępny unikalny\n          adres URL, aby umożliwić wysyłanie danych do Asystenta domowego z\n          dowolnego miejsca. ${this._renderBody()}\n\n          <div class=\"footer\">\n            <a href=\"https://www.ai-speaker.com/\" target=\"_blank\">\n              Dowiedz się więcej o zwrotnym wywołaniu HTTP.\n            </a>\n          </div>\n        </div>\n      </ha-card>\n    `;\n  }\n\n  private _renderBody() {\n    if (!this._localHooks) {\n      return html` <div class=\"body-text\">Pobieranie…</div> `;\n    }\n\n    if (this._localHooks.length === 1) {\n      return html`\n        <div class=\"body-text\">\n          Wygląda na to, że nie masz jeszcze zdefiniowanych żadnych wywołań\n          zwrotnych. Rozpocznij od skonfigurowania\n          <a href=\"/config/integrations\">\n            integracji opartej na wywołaniu zwrotnym\n          </a>\n          lub przez tworzenie\n          <a href=\"/config/automation/new\"> automatyzacji typu webhook </a>.\n        </div>\n      `;\n    }\n\n    return this._localHooks.map(\n      (entry) => html`\n        ${entry.webhook_id === \"aisdomprocesscommandfromframe\"\n          ? html` <div></div> `\n          : html`\n              <div class=\"webhook\" .entry=\"${entry}\">\n                <paper-item-body two-line>\n                  <div>\n                    ${entry.name}\n                    ${entry.domain === entry.name.toLowerCase()\n                      ? \"\"\n                      : ` (${entry.domain})`}\n                  </div>\n                  <div secondary>${entry.webhook_id}</div>\n                </paper-item-body>\n                <mwc-button @click=\"${this._handleManageButton}\">\n                  Pokaż\n                </mwc-button>\n              </div>\n            `}\n      `\n    );\n  }\n\n  private _showDialog(webhookId: string) {\n    const webhook = this._localHooks!.find(\n      (ent) => ent.webhook_id === webhookId\n    )!;\n    showManageCloudhookDialog(this, { webhook });\n  }\n\n  private _handleManageButton(ev: MouseEvent) {\n    const entry = (ev.currentTarget as any).parentElement.entry as Webhook;\n    this._showDialog(entry.webhook_id);\n  }\n\n  private async _fetchData() {\n    this._localHooks = await fetchWebhooks(this.hass!);\n  }\n\n  private renderStyle() {\n    return html`\n      <style>\n        .body-text {\n          padding: 8px 0;\n        }\n        .webhook {\n          display: flex;\n          padding: 4px 0;\n        }\n        .progress {\n          margin-right: 16px;\n          display: flex;\n          flex-direction: column;\n          justify-content: center;\n        }\n        .footer {\n          padding-top: 16px;\n        }\n        .body-text a,\n        .footer a {\n          color: var(--primary-color);\n        }\n      </style>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ais-webhooks\": AisWebhooks;\n  }\n}\n\ncustomElements.define(\"ais-webhooks\", AisWebhooks);\n","import \"@material/mwc-list/mwc-list-item\";\nimport \"../../../components/ha-button-menu\";\nimport \"../../lovelace/entity-rows/hui-timer-entity-row\";\nimport \"@polymer/app-layout/app-header/app-header\";\nimport \"@polymer/app-layout/app-toolbar/app-toolbar\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { mdiDotsVertical } from \"@mdi/js\";\nimport { HomeAssistant } from \"../../../types\";\nimport \"../../../layouts/hass-subpage\";\nimport \"../../../resources/ha-style\";\n\nimport \"./ha-config-ais-dom-dashboard\";\nimport \"./ais-webhooks\";\nimport \"../../../components/ha-switch\";\nimport {\n  HaAisFileDialogParams,\n  showAisFileDialog,\n} from \"../../../dialogs/ais-files/show-dialog-ais-file\";\n\n@customElement(\"ha-config-ais-dom-config-remote\")\nclass HaConfigAisDomControl extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() private _qrCode?: TemplateResult;\n\n  @property() public narrow!: boolean;\n\n  @property() private remoteDomain;\n\n  async _generateQR() {\n    const qrcode = await import(\"qrcode\");\n    const canvas = await qrcode.toCanvas(`${this.remoteDomain}`, {\n      width: 280,\n      errorCorrectionLevel: \"Q\",\n    });\n    const context = canvas.getContext(\"2d\");\n\n    const imageObj = new Image();\n    imageObj.src = \"/static/icons/favicon-192x192.png\";\n    await new Promise((resolve) => {\n      imageObj.onload = resolve;\n    });\n    context.drawImage(\n      imageObj,\n      canvas.width / 3,\n      canvas.height / 3,\n      canvas.width / 3,\n      canvas.height / 3\n    );\n\n    this._qrCode = html`<img src=${canvas.toDataURL()}></img>`;\n  }\n\n  changeRemote() {\n    this.hass.callService(\"input_boolean\", \"toggle\", {\n      entity_id: \"input_boolean.ais_remote_access\",\n    });\n  }\n\n  enableGatePariringByPin() {\n    this.hass.callService(\"ais_cloud\", \"enable_gate_pairing_by_pin\");\n  }\n\n  protected firstUpdated() {\n    this._generateQR();\n  }\n\n  protected render(): TemplateResult {\n    this.remoteDomain =\n      \"https://\" +\n      this.hass.states[\"sensor.ais_secure_android_id_dom\"].state +\n      \".paczka.pro\";\n\n    return html`\n      <hass-subpage header=\"Konfiguracja bramki AIS dom\">\n        ${this.hass.states[\"input_boolean.ais_remote_access\"].state === \"on\"\n          ? html`\n              <ha-button-menu corner=\"BOTTOM_START\" slot=\"toolbar-icon\">\n                <mwc-icon-button slot=\"trigger\" alt=\"menu\">\n                  <ha-svg-icon .path=${mdiDotsVertical}></ha-svg-icon>\n                </mwc-icon-button>\n                <mwc-list-item @click=${this._openCloudflareFileConfig}>\n                  Cloudflare config.yaml\n                </mwc-list-item>\n                <mwc-list-item @click=${this._restartTunnelService}>\n                  Restart tunnel sevice\n                </mwc-list-item>\n              </ha-button-menu>\n            `\n          : ` `}\n        <div>\n          <ha-config-section>\n            <span slot=\"header\">Zdalny dostęp</span>\n            <span slot=\"introduction\"\n              >W tej sekcji możesz skonfigurować zdalny dostęp do bramki</span\n            >\n            <ha-card header=\"Szyfrowany tunel\">\n              <div id=\"ha-switch-id\">\n                <ha-switch\n                  .checked=${this.hass.states[\"input_boolean.ais_remote_access\"]\n                    .state === \"on\"}\n                  @change=${this.changeRemote}\n                ></ha-switch>\n              </div>\n              <div class=\"card-content\">\n                Tunel zapewnia bezpieczne zdalne połączenie z Twoim urządzeniem\n                kiedy jesteś z dala od domu. Twoja bramka dostępna\n                ${this.hass.states[\"input_boolean.ais_remote_access\"].state ===\n                \"on\"\n                  ? html` jest `\n                  : ` będzie `}\n                z Internetu pod adresem\n                <a href=${this.remoteDomain} target=\"_blank\"\n                  >${this.remoteDomain}</a\n                >.\n                <div\n                  class=\"center-container border\"\n                  style=\"height: 320px; text-align: center;\"\n                >\n                  <div id=\"qr\" style=\"text-align: center; margin-top: 10px;\">\n                    ${this._qrCode\n                      ? this._qrCode\n                      : html`\n                          <mwc-button @click=${this._generateQR}\n                            >Pokaż kod QR\n                          </mwc-button>\n                        `}\n                  </div>\n                  Zeskanuj kod QR za pomocą aplikacji na telefonie.\n                </div>\n              </div>\n              <div class=\"card-content\" style=\"text-align:center;\">\n                <svg style=\"width:48px;height:48px\" viewBox=\"0 0 24 24\">\n                  <path\n                    fill=\"#929395\"\n                    d=\"M1,11H6L3.5,8.5L4.92,7.08L9.84,12L4.92,16.92L3.5,15.5L6,13H1V11M8,0H16L16.83,5H17A2,2 0 0,1 19,7V17C19,18.11 18.1,19 17,19H16.83L16,24H8L7.17,19H7C6.46,19 6,18.79 5.62,18.44L7.06,17H17V7H7.06L5.62,5.56C6,5.21 6.46,5 7,5H7.17L8,0Z\"\n                  />\n                </svg>\n                <br />\n                ${this.hass.states[\"timer.ais_dom_pin_join\"].state === \"active\"\n                  ? html`PIN aktywny przez dwie munuty: <br />\n                      <span class=\"pin\"\n                        >${this.hass.states[\"sensor.gate_pairing_pin\"]\n                          .state}</span\n                      ><br /> `\n                  : html`<br />\n                      <mwc-button @click=${this.enableGatePariringByPin}\n                        >Generuj kod PIN</mwc-button\n                      >`}\n              </div>\n              <div class=\"card-actions\">\n                <a\n                  href=\"https://www.ai-speaker.com/docs/ais_bramka_remote_www_index\"\n                  target=\"_blank\"\n                >\n                  <mwc-button>Dowiedz się jak to działa</mwc-button>\n                </a>\n              </div>\n            </ha-card>\n\n            <ais-webhooks .hass=${this.hass}></ais-webhooks>\n          </ha-config-section>\n        </div>\n      </hass-subpage>\n    `;\n  }\n\n  private async _openCloudflareFileConfig() {\n    const filePath =\n      \"/data/data/com.termux/files/home/.cloudflared/config.yaml\";\n    const file = await this.hass.callApi<string>(\"POST\", \"ais_file/read\", {\n      filePath: filePath,\n    });\n    const fileParams: HaAisFileDialogParams = {\n      dialogTitle: \"Cloudflare config.yaml\",\n      filePath: filePath,\n      fileBody: file,\n      readonly: true,\n    };\n    showAisFileDialog(this, fileParams);\n  }\n\n  private async _restartTunnelService() {\n    this.hass.callService(\"ais_shell_command\", \"restart_pm2_service\", {\n      service: \"tunnel\",\n    });\n  }\n\n  static get styles(): CSSResultGroup[] {\n    return [\n      css`\n        .content {\n          padding-bottom: 32px;\n        }\n        a {\n          color: var(--primary-color);\n        }\n        span.pin {\n          color: var(--primary-color);\n          font-size: 2em;\n        }\n        .border {\n          margin-bottom: 12px;\n          border-bottom: 2px solid rgba(0, 0, 0, 0.11);\n          max-width: 1040px;\n        }\n        .narrow .border {\n          max-width: 640px;\n        }\n        .center-container {\n          @apply --layout-vertical;\n          @apply --layout-center-center;\n          height: 70px;\n        }\n        ha-card > div#ha-switch-id {\n          margin: -4px 0;\n          position: absolute;\n          right: 8px;\n          top: 32px;\n        }\n        .card-actions a {\n          text-decoration: none;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-config-ais-dom-config-remote\": HaConfigAisDomControl;\n  }\n}\n","import { HassEntity } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { computeDisplayTimer, timerTimeRemaining } from \"../../../data/timer\";\nimport { HomeAssistant } from \"../../../types\";\nimport { hasConfigOrEntityChanged } from \"../common/has-changed\";\nimport \"../components/hui-generic-entity-row\";\nimport { createEntityNotFoundWarning } from \"../components/hui-warning\";\nimport { EntityConfig } from \"./types\";\n\n@customElement(\"hui-timer-entity-row\")\nclass HuiTimerEntityRow extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @state() private _config?: EntityConfig;\n\n  @state() private _timeRemaining?: number;\n\n  private _interval?: number;\n\n  public setConfig(config: EntityConfig): void {\n    if (!config) {\n      throw new Error(\"Invalid configuration\");\n    }\n    this._config = config;\n\n    if (!this.hass) {\n      return;\n    }\n\n    const stateObj = this.hass!.states[this._config.entity];\n\n    if (stateObj) {\n      this._startInterval(stateObj);\n    } else {\n      this._clearInterval();\n    }\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    this._clearInterval();\n  }\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    if (this._config && this._config.entity) {\n      const stateObj = this.hass?.states[this._config!.entity];\n      if (stateObj) {\n        this._startInterval(stateObj);\n      }\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this._config || !this.hass) {\n      return html``;\n    }\n\n    const stateObj = this.hass.states[this._config.entity];\n\n    if (!stateObj) {\n      return html`\n        <hui-warning>\n          ${createEntityNotFoundWarning(this.hass, this._config.entity)}\n        </hui-warning>\n      `;\n    }\n\n    return html`\n      <hui-generic-entity-row .hass=${this.hass} .config=${this._config}>\n        <div class=\"text-content\">\n          ${computeDisplayTimer(this.hass, stateObj, this._timeRemaining)}\n        </div>\n      </hui-generic-entity-row>\n    `;\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    if (changedProps.has(\"_timeRemaining\")) {\n      return true;\n    }\n\n    return hasConfigOrEntityChanged(this, changedProps);\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    super.updated(changedProps);\n\n    if (!this._config || !changedProps.has(\"hass\")) {\n      return;\n    }\n    const stateObj = this.hass!.states[this._config!.entity];\n    const oldHass = changedProps.get(\"hass\") as this[\"hass\"];\n    const oldStateObj = oldHass\n      ? oldHass.states[this._config!.entity]\n      : undefined;\n\n    if (oldStateObj !== stateObj) {\n      this._startInterval(stateObj);\n    } else if (!stateObj) {\n      this._clearInterval();\n    }\n  }\n\n  private _clearInterval(): void {\n    if (this._interval) {\n      window.clearInterval(this._interval);\n      this._interval = undefined;\n    }\n  }\n\n  private _startInterval(stateObj: HassEntity): void {\n    this._clearInterval();\n    this._calculateRemaining(stateObj);\n\n    if (stateObj.state === \"active\") {\n      this._interval = window.setInterval(\n        () => this._calculateRemaining(stateObj),\n        1000\n      );\n    }\n  }\n\n  private _calculateRemaining(stateObj: HassEntity): void {\n    this._timeRemaining = timerTimeRemaining(stateObj);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-timer-entity-row\": HuiTimerEntityRow;\n  }\n}\n"],"names":[],"sourceRoot":""}