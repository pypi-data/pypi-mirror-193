# This file contains models for incoming responses.
# Generated Wed Jan 18 21:26:39 2023 by generateDS.py version 2.41.1.
# Python 3.9.10 (main, Mar  7 2022, 16:27:04)  [Clang 13.0.0 (clang-1300.0.29.30)]
#
# Command line options:
#   ('-o', 'models.py')
#
# Command line arguments:
#   models.xsd
#
# Command line:
#   generateDS -o "models.py" models.xsd
#
# Current working directory (os.getcwd()):
#   pyskybitz
#

import base64
import datetime as datetime_
import decimal as decimal_
import re as re_
from io import StringIO

from lxml import etree as etree_
from six.moves import zip_longest

SaveElementTreeNode = True
TagNamePrefix = ""


GenerateDSNamespaceDefs = {}
GenerateDSNamespaceTypePrefixes = {}


class GeneratedsSuperBase:
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    @classmethod
    def factory(cls, *args_, **kwargs_):
        if CurrentSubclassModule is not None:
            subclass = get_subclass_from_module(CurrentSubclassModule, Profile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cls.subclass:
            return cls.subclass(*args_, **kwargs_)
        else:
            return cls(*args_, **kwargs_)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix


class GeneratedsSuper(GeneratedsSuperBase):
    __hash__ = object.__hash__
    tz_off_pattern = re_.compile(r"(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$")

    class _FixedOffsetTZ(datetime_.tzinfo):
        def __init__(self, offset, name):
            self.__offset = datetime_.timedelta(minutes=offset)
            self.__name = name

        def utcoffset(self, dt):
            return self.__offset

        def tzname(self, dt):
            return self.__name

        def dst(self, dt):
            return None

    def __str__(self):
        settings = {
            "str_pretty_print": True,
            "str_indent_level": 0,
            "str_namespaceprefix": "",
            "str_name": self.__class__.__name__,
            "str_namespacedefs": "",
        }
        for n in settings:
            if hasattr(self, n):
                settings[n] = getattr(self, n)
        output = StringIO()
        self.export(
            output,
            settings["str_indent_level"],
            pretty_print=settings["str_pretty_print"],
            namespace_prefix=settings["str_namespaceprefix"],
            name_=settings["str_name"],
            namespacedef_=settings["str_namespacedefs"],
        )
        str_val = output.getvalue()
        output.close()
        return str_val

    def gds_format_string(self, input_data, input_name=""):
        return input_data

    def gds_parse_string(self, input_data, node=None, input_name=""):
        return input_data

    def gds_validate_string(self, input_data, node=None, input_name=""):
        if not input_data:
            return ""
        else:
            return input_data

    def gds_format_base64(self, input_data, input_name=""):
        return base64.b64encode(input_data).decode("ascii")

    def gds_validate_base64(self, input_data, node=None, input_name=""):
        return input_data

    def gds_format_integer(self, input_data, input_name=""):
        return "%d" % int(input_data)

    def gds_parse_integer(self, input_data, node=None, input_name=""):
        try:
            ival = int(input_data)
        except (TypeError, ValueError) as exp:
            raise_parse_error(node, "Requires integer value: %s" % exp)
        return ival

    def gds_validate_integer(self, input_data, node=None, input_name=""):
        try:
            value = int(input_data)
        except (TypeError, ValueError):
            raise_parse_error(node, "Requires integer value")
        return value

    def gds_format_integer_list(self, input_data, input_name=""):
        if len(input_data) > 0 and not isinstance(input_data[0], str):
            input_data = [str(s) for s in input_data]
        return "%s" % " ".join(input_data)

    def gds_validate_integer_list(self, input_data, node=None, input_name=""):
        values = input_data.split()
        for value in values:
            try:
                int(value)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires sequence of integer values")
        return values

    def gds_format_float(self, input_data, input_name=""):
        return ("%.15f" % float(input_data)).rstrip("0")

    def gds_parse_float(self, input_data, node=None, input_name=""):
        try:
            fval_ = float(input_data)
        except (TypeError, ValueError) as exp:
            raise_parse_error(node, "Requires float or double value: %s" % exp)
        return fval_

    def gds_validate_float(self, input_data, node=None, input_name=""):
        try:
            value = float(input_data)
        except (TypeError, ValueError):
            raise_parse_error(node, "Requires float value")
        return value

    def gds_format_float_list(self, input_data, input_name=""):
        if len(input_data) > 0 and not isinstance(input_data[0], str):
            input_data = [str(s) for s in input_data]
        return "%s" % " ".join(input_data)

    def gds_validate_float_list(self, input_data, node=None, input_name=""):
        values = input_data.split()
        for value in values:
            try:
                float(value)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires sequence of float values")
        return values

    def gds_format_decimal(self, input_data, input_name=""):
        return_value = "%s" % input_data
        if "." in return_value:
            return_value = return_value.rstrip("0")
            if return_value.endswith("."):
                return_value = return_value.rstrip(".")
        return return_value

    def gds_parse_decimal(self, input_data, node=None, input_name=""):
        try:
            decimal_value = decimal_.Decimal(input_data)
        except (TypeError, ValueError):
            raise_parse_error(node, "Requires decimal value")
        return decimal_value

    def gds_validate_decimal(self, input_data, node=None, input_name=""):
        try:
            value = decimal_.Decimal(input_data)
        except (TypeError, ValueError):
            raise_parse_error(node, "Requires decimal value")
        return value

    def gds_format_decimal_list(self, input_data, input_name=""):
        if len(input_data) > 0 and not isinstance(input_data[0], str):
            input_data = [str(s) for s in input_data]
        return " ".join([self.gds_format_decimal(item) for item in input_data])

    def gds_validate_decimal_list(self, input_data, node=None, input_name=""):
        values = input_data.split()
        for value in values:
            try:
                decimal_.Decimal(value)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires sequence of decimal values")
        return values

    def gds_format_double(self, input_data, input_name=""):
        return "%s" % input_data

    def gds_parse_double(self, input_data, node=None, input_name=""):
        try:
            fval_ = float(input_data)
        except (TypeError, ValueError) as exp:
            raise_parse_error(node, "Requires double or float value: %s" % exp)
        return fval_

    def gds_validate_double(self, input_data, node=None, input_name=""):
        try:
            value = float(input_data)
        except (TypeError, ValueError):
            raise_parse_error(node, "Requires double or float value")
        return value

    def gds_format_double_list(self, input_data, input_name=""):
        if len(input_data) > 0 and not isinstance(input_data[0], str):
            input_data = [str(s) for s in input_data]
        return "%s" % " ".join(input_data)

    def gds_validate_double_list(self, input_data, node=None, input_name=""):
        values = input_data.split()
        for value in values:
            try:
                float(value)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires sequence of double or float values")
        return values

    def gds_format_boolean(self, input_data, input_name=""):
        return ("%s" % input_data).lower()

    def gds_parse_boolean(self, input_data, node=None, input_name=""):
        input_data = input_data.strip()
        if input_data in ("true", "1"):
            bval = True
        elif input_data in ("false", "0"):
            bval = False
        else:
            raise_parse_error(node, "Requires boolean value")
        return bval

    def gds_validate_boolean(self, input_data, node=None, input_name=""):
        if input_data not in (
            True,
            1,
            False,
            0,
        ):
            raise_parse_error(
                node, "Requires boolean value " "(one of True, 1, False, 0)"
            )
        return input_data

    def gds_format_boolean_list(self, input_data, input_name=""):
        if len(input_data) > 0 and not isinstance(input_data[0], str):
            input_data = [str(s) for s in input_data]
        return "%s" % " ".join(input_data)

    def gds_validate_boolean_list(self, input_data, node=None, input_name=""):
        values = input_data.split()
        for value in values:
            value = self.gds_parse_boolean(value, node, input_name)
            if value not in (
                True,
                1,
                False,
                0,
            ):
                raise_parse_error(
                    node,
                    "Requires sequence of boolean values " "(one of True, 1, False, 0)",
                )
        return values

    def gds_validate_datetime(self, input_data, node=None, input_name=""):
        return input_data

    def gds_format_datetime(self, input_data, input_name=""):
        if input_data.microsecond == 0:
            _s_value = "%04d-%02d-%02dT%02d:%02d:%02d" % (
                input_data.year,
                input_data.month,
                input_data.day,
                input_data.hour,
                input_data.minute,
                input_data.second,
            )
        else:
            _s_value = "%04d-%02d-%02dT%02d:%02d:%02d.%s" % (
                input_data.year,
                input_data.month,
                input_data.day,
                input_data.hour,
                input_data.minute,
                input_data.second,
                ("%f" % (float(input_data.microsecond) / 1000000))[2:],
            )
        if input_data.tzinfo is not None:
            tz_off = input_data.tzinfo.utcoffset(input_data)
            if tz_off is not None:
                total_seconds = tz_off.seconds + (86400 * tz_off.days)
                if total_seconds == 0:
                    _s_value += "Z"
                else:
                    if total_seconds < 0:
                        _s_value += "-"
                        total_seconds *= -1
                    else:
                        _s_value += "+"
                    hours = total_seconds // 3600
                    minutes = (total_seconds - (hours * 3600)) // 60
                    _s_value += "{0:02d}:{1:02d}".format(hours, minutes)
        return _s_value

    @classmethod
    def gds_parse_datetime(cls, input_data):
        tz = None
        if input_data[-1] == "Z":
            tz = GeneratedsSuper._FixedOffsetTZ(0, "UTC")
            input_data = input_data[:-1]
        else:
            results = GeneratedsSuper.tz_off_pattern.search(input_data)
            if results is not None:
                tz_off_parts = results.group(2).split(":")
                tz_off = int(tz_off_parts[0]) * 60 + int(tz_off_parts[1])
                if results.group(1) == "-":
                    tz_off *= -1
                tz = GeneratedsSuper._FixedOffsetTZ(tz_off, results.group(0))
                input_data = input_data[:-6]
        if input_data.endswith("Z"):
            dt = datetime_.datetime.strptime(input_data, "%Y-%m-%dT%H:%M:%S")
        else:
            dt = datetime_.datetime.strptime(input_data, "%Y/%m/%d %H:%M:%S")
        dt = dt.replace(tzinfo=tz)
        return dt

    def gds_validate_date(self, input_data, node=None, input_name=""):
        return input_data

    def gds_format_date(self, input_data, input_name=""):
        _s_value = "%04d-%02d-%02d" % (
            input_data.year,
            input_data.month,
            input_data.day,
        )
        try:
            if input_data.tzinfo is not None:
                tz_off = input_data.tzinfo.utcoffset(input_data)
                if tz_off is not None:
                    total_seconds = tz_off.seconds + (86400 * tz_off.days)
                    if total_seconds == 0:
                        _s_value += "Z"
                    else:
                        if total_seconds < 0:
                            _s_value += "-"
                            total_seconds *= -1
                        else:
                            _s_value += "+"
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _s_value += "{0:02d}:{1:02d}".format(hours, minutes)
        except AttributeError:
            pass
        return _s_value

    @classmethod
    def gds_parse_date(cls, input_data):
        tz = None
        if input_data[-1] == "Z":
            tz = GeneratedsSuper._FixedOffsetTZ(0, "UTC")
            input_data = input_data[:-1]
        else:
            results = GeneratedsSuper.tz_off_pattern.search(input_data)
            if results is not None:
                tz_off_parts = results.group(2).split(":")
                tz_off = int(tz_off_parts[0]) * 60 + int(tz_off_parts[1])
                if results.group(1) == "-":
                    tz_off *= -1
                tz = GeneratedsSuper._FixedOffsetTZ(tz_off, results.group(0))
                input_data = input_data[:-6]
        dt = datetime_.datetime.strptime(input_data, "%Y-%m-%d")
        dt = dt.replace(tzinfo=tz)
        return dt.date()

    def gds_validate_time(self, input_data, node=None, input_name=""):
        return input_data

    def gds_format_time(self, input_data, input_name=""):
        if input_data.microsecond == 0:
            _s_value = "%02d:%02d:%02d" % (
                input_data.hour,
                input_data.minute,
                input_data.second,
            )
        else:
            _s_value = "%02d:%02d:%02d.%s" % (
                input_data.hour,
                input_data.minute,
                input_data.second,
                ("%f" % (float(input_data.microsecond) / 1000000))[2:],
            )
        if input_data.tzinfo is not None:
            tz_off = input_data.tzinfo.utcoffset(input_data)
            if tz_off is not None:
                total_seconds = tz_off.seconds + (86400 * tz_off.days)
                if total_seconds == 0:
                    _s_value += "Z"
                else:
                    if total_seconds < 0:
                        _s_value += "-"
                        total_seconds *= -1
                    else:
                        _s_value += "+"
                    hours = total_seconds // 3600
                    minutes = (total_seconds - (hours * 3600)) // 60
                    _s_value += "{0:02d}:{1:02d}".format(hours, minutes)
        return _s_value

    def gds_validate_simple_patterns(self, patterns, target):
        # pat is a list of lists of strings/patterns.
        # The target value must match at least one of the patterns
        # in order for the test to succeed.
        found1 = True
        target = str(target)
        for patterns1 in patterns:
            found2 = False
            for patterns2 in patterns1:
                mo = re_.search(patterns2, target)
                if mo is not None and len(mo.group(0)) == len(target):
                    found2 = True
                    break
            if not found2:
                found1 = False
                break
        return found1

    @classmethod
    def gds_parse_time(cls, input_data):
        tz = None
        if input_data[-1] == "Z":
            tz = GeneratedsSuper._FixedOffsetTZ(0, "UTC")
            input_data = input_data[:-1]
        else:
            results = GeneratedsSuper.tz_off_pattern.search(input_data)
            if results is not None:
                tz_off_parts = results.group(2).split(":")
                tz_off = int(tz_off_parts[0]) * 60 + int(tz_off_parts[1])
                if results.group(1) == "-":
                    tz_off *= -1
                tz = GeneratedsSuper._FixedOffsetTZ(tz_off, results.group(0))
                input_data = input_data[:-6]
        if input_data.endswith("Z"):
            dt = datetime_.datetime.strptime(input_data, "%Y-%m-%dT%H:%M:%S")
        else:
            dt = datetime_.datetime.strptime(input_data, "%Y/%m/%d %H:%M:%S")
        dt = dt.replace(tzinfo=tz)
        return dt.time()

    def gds_check_cardinality_(
        self, value, input_name, min_occurs=0, max_occurs=1, required=None
    ):
        if value is None:
            length = 0
        elif isinstance(value, list):
            length = len(value)
        else:
            length = 1
        if required is not None:
            if required and length < 1:
                self.gds_collector_.add_message(
                    "Required value {}{} is missing".format(
                        input_name, self.gds_get_node_lineno_()
                    )
                )
        if length < min_occurs:
            self.gds_collector_.add_message(
                "Number of values for {}{} is below "
                "the minimum allowed, "
                "expected at least {}, found {}".format(
                    input_name, self.gds_get_node_lineno_(), min_occurs, length
                )
            )
        elif length > max_occurs:
            self.gds_collector_.add_message(
                "Number of values for {}{} is above "
                "the maximum allowed, "
                "expected at most {}, found {}".format(
                    input_name, self.gds_get_node_lineno_(), max_occurs, length
                )
            )

    def gds_validate_builtin_ST_(
        self,
        validator,
        value,
        input_name,
        min_occurs=None,
        max_occurs=None,
        required=None,
    ):
        if value is not None:
            try:
                validator(value, input_name=input_name)
            except GDSParseError as parse_error:
                self.gds_collector_.add_message(str(parse_error))

    def gds_validate_defined_ST_(
        self,
        validator,
        value,
        input_name,
        min_occurs=None,
        max_occurs=None,
        required=None,
    ):
        if value is not None:
            try:
                validator(value)
            except GDSParseError as parse_error:
                self.gds_collector_.add_message(str(parse_error))

    def gds_str_lower(self, instring):
        return instring.lower()

    def get_path_(self, node):
        path_list = []
        self.get_path_list_(node, path_list)
        path_list.reverse()
        path = "/".join(path_list)
        return path

    Tag_strip_pattern_ = re_.compile(r"\{.*\}")

    def get_path_list_(self, node, path_list):
        if node is None:
            return
        tag = GeneratedsSuper.Tag_strip_pattern_.sub("", node.tag)
        if tag:
            path_list.append(tag)
        self.get_path_list_(node.getparent(), path_list)

    def get_class_obj_(self, node, default_class=None):
        class_obj1 = default_class
        if "xsi" in node.nsmap:
            classname = node.get("{%s}type" % node.nsmap["xsi"])
            if classname is not None:
                names = classname.split(":")
                if len(names) == 2:
                    classname = names[1]
                class_obj2 = globals().get(classname)
                if class_obj2 is not None:
                    class_obj1 = class_obj2
        return class_obj1

    def gds_build_any(self, node, type_name=None):
        # provide default value in case option --disable-xml is used.
        content = etree_.tostring(node, encoding="unicode")
        return content

    @classmethod
    def gds_reverse_node_mapping(cls, mapping):
        return {v: k for k, v in mapping.items()}

    @staticmethod
    def gds_encode(instring):
        return instring

    @staticmethod
    def convert_unicode(instring):
        if isinstance(instring, str):
            result = quote_xml(instring)
        else:
            result = GeneratedsSuper.gds_encode(str(instring))
        return result

    def __eq__(self, other):
        def excl_select_objs_(obj):
            return obj[0] != "parent_object_" and obj[0] != "gds_collector_"

        if type(self) != type(other):
            return False
        return all(
            x == y
            for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items()),
            )
        )

    def __ne__(self, other):
        return not self.__eq__(other)

    # Django ETL transform hooks.
    def gds_djo_etl_transform(self):
        pass

    def gds_djo_etl_transform_db_obj(self, dbobj):
        pass

    # SQLAlchemy ETL transform hooks.
    def gds_sqa_etl_transform(self):
        return 0, None

    def gds_sqa_etl_transform_db_obj(self, dbobj):
        pass

    def gds_get_node_lineno_(self):
        if (
            hasattr(self, "gds_elementtree_node_")
            and self.gds_elementtree_node_ is not None
        ):
            return " near line {}".format(self.gds_elementtree_node_.sourceline)
        else:
            return ""


def get_subclass_from_module(module, class_):
    """Get the subclass of a class from a specific module."""
    name = class_.__name__ + "Sub"
    if hasattr(module, name):
        return getattr(module, name)
    else:
        return None


#
# Globals
#

ExternalEncoding = ""
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS = True
CapturedNsMap = {}
TagPattern = re_.compile(r"({.*})?(.*)")
CDATAPattern = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule = None


#
# Support/utility functions.
#


def show_indent(outfile, level, pretty_print=True):
    if pretty_print:
        for _idx in range(level):
            outfile.write("    ")


def quote_xml(in_str):
    "Escape markup chars, but do not modify CDATA sections."
    if not in_str:
        return ""
    s1 = isinstance(in_str, str) and in_str or "%s" % in_str
    s2 = ""
    pos = 0
    matchobjects = CDATAPattern.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos : mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start() : mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(in_str):
    s1 = in_str.replace("&", "&amp;")
    s1 = s1.replace("<", "&lt;")
    s1 = s1.replace(">", "&gt;")
    return s1


def quote_attrib(in_str):
    s1 = isinstance(in_str, str) and in_str or "%s" % in_str
    s1 = s1.replace("&", "&amp;")
    s1 = s1.replace("<", "&lt;")
    s1 = s1.replace(">", "&gt;")
    s1 = s1.replace("\n", "&#10;")
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(in_str):
    s1 = in_str
    if s1.find("'") == -1:
        if s1.find("\n") == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find("\n") == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ""
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(":")
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == "xml":
            namespace = "http://www.w3.org/XML/1998/namespace"
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get(
                "{%s}%s"
                % (
                    namespace,
                    name,
                )
            )
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = "%s (element %s/line %d)" % (
            msg,
            node.tag,
            node.sourceline,
        )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8

    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value

    def get_category(self):
        return self.category

    def get_contenttype(self, content_type):
        return self.content_type

    def get_value(self):
        return self.value

    def get_name(self):
        return self.name

    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.export_simple(outfile, level, name)
        else:  # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name, pretty_print=pretty_print
            )

    def export_simple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write("<%s>%s</%s>" % (self.name, self.value, self.name))
        elif (
            self.content_type == MixedContainer.TypeInteger
            or self.content_type == MixedContainer.TypeBoolean
        ):
            outfile.write("<%s>%d</%s>" % (self.name, self.value, self.name))
        elif (
            self.content_type == MixedContainer.TypeFloat
            or self.content_type == MixedContainer.TypeDecimal
        ):
            outfile.write("<%s>%f</%s>" % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write("<%s>%g</%s>" % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write(
                "<%s>%s</%s>" % (self.name, base64.b64encode(self.value), self.name)
            )

    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, "%s" % self.name)
            subelement.text = self.to_etree_simple()
        else:  # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)

    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        text = ""
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (
            self.content_type == MixedContainer.TypeInteger
            or self.content_type == MixedContainer.TypeBoolean
        ):
            text = "%d" % self.value
        elif (
            self.content_type == MixedContainer.TypeFloat
            or self.content_type == MixedContainer.TypeDecimal
        ):
            text = "%f" % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = "%g" % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = "%s" % base64.b64encode(self.value)
        return text

    def export_literal(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            show_indent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value)
            )
        elif self.category == MixedContainer.CategorySimple:
            show_indent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value)
            )
        else:  # category == MixedContainer.CategoryComplex
            show_indent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n'
                % (
                    self.category,
                    self.content_type,
                    self.name,
                )
            )
            self.value.export_literal(outfile, level + 1)
            show_indent(outfile, level)
            outfile.write(")\n")


class MemberSpec(object):
    def __init__(
        self,
        name="",
        data_type="",
        container=0,
        optional=0,
        child_attrs=None,
        choice=None,
    ):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def set_data_type(self, data_type):
        self.data_type = data_type

    def get_data_type_chain(self):
        return self.data_type

    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return "xs:string"
        else:
            return self.data_type

    def set_container(self, container):
        self.container = container

    def get_container(self):
        return self.container

    def set_child_attrs(self, child_attrs):
        self.child_attrs = child_attrs

    def get_child_attrs(self):
        return self.child_attrs

    def set_choice(self, choice):
        self.choice = choice

    def get_choice(self):
        return self.choice

    def set_optional(self, optional):
        self.optional = optional

    def get_optional(self):
        return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Data representation classes.
#


class SkyBitz(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        error=None,
        transid=None,
        gls=None,
        profile=None,
        setup=None,
        checkstatus=None,
        mileage=None,
        totalmileage=None,
        batchnum=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.error = error
        self.error_nsprefix_ = None
        self.transid = transid
        self.transid_nsprefix_ = None
        if gls is None:
            self.gls = []
        else:
            self.gls = gls
        self.gls_nsprefix_ = None
        if profile is None:
            self.profile = []
        else:
            self.profile = profile
        self.profile_nsprefix_ = None
        if setup is None:
            self.setup = []
        else:
            self.setup = setup
        self.setup_nsprefix_ = None
        if checkstatus is None:
            self.checkstatus = []
        else:
            self.checkstatus = checkstatus
        self.check_statusnsprefix_ = None
        if mileage is None:
            self.mileage = []
        else:
            self.mileage = mileage
        self.mileage_nsprefix_ = None
        if totalmileage is None:
            self.totalmileage = []
        else:
            self.totalmileage = totalmileage
        self.total_mileagensprefix_ = None
        self.batchnum = batchnum
        self.batchnum_nsprefix_ = None

    def get_error(self):
        return self.error

    def set_error(self, error):
        self.error = error

    def get_transid(self):
        return self.transid

    def set_transid(self, transid):
        self.transid = transid

    def get_gls(self):
        return self.gls

    def set_gls(self, gls):
        self.gls = gls

    def add_gls(self, value):
        self.gls.append(value)

    def insert_gls_at(self, index, value):
        self.gls.insert(index, value)

    def replace_gls_at(self, index, value):
        self.gls[index] = value

    def get_profile(self):
        return self.profile

    def set_profile(self, profile):
        self.profile = profile

    def add_profile(self, value):
        self.profile.append(value)

    def insert_profile_at(self, index, value):
        self.profile.insert(index, value)

    def replace_profile_at(self, index, value):
        self.profile[index] = value

    def get_setup(self):
        return self.setup

    def set_setup(self, setup):
        self.setup = setup

    def add_setup(self, value):
        self.setup.append(value)

    def insert_setup_at(self, index, value):
        self.setup.insert(index, value)

    def replace_setup_at(self, index, value):
        self.setup[index] = value

    def get_checkstatus(self):
        return self.checkstatus

    def set_checkstatus(self, checkstatus):
        self.checkstatus = checkstatus

    def add_checkstatus(self, value):
        self.checkstatus.append(value)

    def insert_check_statusat(self, index, value):
        self.checkstatus.insert(index, value)

    def replace_check_statusat(self, index, value):
        self.checkstatus[index] = value

    def get_mileage(self):
        return self.mileage

    def set_mileage(self, mileage):
        self.mileage = mileage

    def add_mileage(self, value):
        self.mileage.append(value)

    def insert_mileage_at(self, index, value):
        self.mileage.insert(index, value)

    def replace_mileage_at(self, index, value):
        self.mileage[index] = value

    def get_totalmileage(self):
        return self.totalmileage

    def set_totalmileage(self, totalmileage):
        self.totalmileage = totalmileage

    def add_totalmileage(self, value):
        self.totalmileage.append(value)

    def insert_total_mileageat(self, index, value):
        self.totalmileage.insert(index, value)

    def replace_total_mileageat(self, index, value):
        self.totalmileage[index] = value

    def get_batchnum(self):
        return self.batchnum

    def set_batchnum(self, batchnum):
        self.batchnum = batchnum

    def _has_content(self):
        if (
            self.error is not None
            or self.transid is not None
            or self.gls
            or self.profile
            or self.setup
            or self.checkstatus
            or self.mileage
            or self.totalmileage
            or self.batchnum is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="skybitz",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("skybitz")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "skybitz":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="skybitz"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="skybitz",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="skybitz"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="skybitz",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.error is not None:
            namespace_prefix = (
                self.error_nsprefix_ + ":"
                if (UseCapturedNS and self.error_nsprefix_)
                else ""
            )
            self.error.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="error",
                pretty_print=pretty_print,
            )
        if self.transid is not None:
            namespace_prefix = (
                self.transid_nsprefix_ + ":"
                if (UseCapturedNS and self.transid_nsprefix_)
                else ""
            )
            self.transid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="transid",
                pretty_print=pretty_print,
            )
        for gls_ in self.gls:
            namespace_prefix = (
                self.gls_nsprefix_ + ":"
                if (UseCapturedNS and self.gls_nsprefix_)
                else ""
            )
            gls_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="gls",
                pretty_print=pretty_print,
            )
        for profile_ in self.profile:
            namespace_prefix = (
                self.profile_nsprefix_ + ":"
                if (UseCapturedNS and self.profile_nsprefix_)
                else ""
            )
            profile_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="profile",
                pretty_print=pretty_print,
            )
        for setup_ in self.setup:
            namespace_prefix = (
                self.setup_nsprefix_ + ":"
                if (UseCapturedNS and self.setup_nsprefix_)
                else ""
            )
            setup_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="setup",
                pretty_print=pretty_print,
            )
        for check_status in self.checkstatus:
            namespace_prefix = (
                self.check_statusnsprefix_ + ":"
                if (UseCapturedNS and self.check_statusnsprefix_)
                else ""
            )
            check_status.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="checkstatus",
                pretty_print=pretty_print,
            )
        for mileage_ in self.mileage:
            namespace_prefix = (
                self.mileage_nsprefix_ + ":"
                if (UseCapturedNS and self.mileage_nsprefix_)
                else ""
            )
            mileage_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="mileage",
                pretty_print=pretty_print,
            )
        for total_mileage in self.totalmileage:
            namespace_prefix = (
                self.total_mileagensprefix_ + ":"
                if (UseCapturedNS and self.total_mileagensprefix_)
                else ""
            )
            total_mileage.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="totalmileage",
                pretty_print=pretty_print,
            )
        if self.batchnum is not None:
            namespace_prefix = (
                self.batchnum_nsprefix_ + ":"
                if (UseCapturedNS and self.batchnum_nsprefix_)
                else ""
            )
            self.batchnum.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="batchnum",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "error":
            obj_ = Error.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.error = obj_
            obj_.original_tagname_ = "error"
        elif node_name == "transid":
            obj_ = TransId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transid = obj_
            obj_.original_tagname_ = "transid"
        elif node_name == "gls":
            obj_ = GLS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gls.append(obj_)
            obj_.original_tagname_ = "gls"
        elif node_name == "profile":
            obj_ = Profile.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.profile.append(obj_)
            obj_.original_tagname_ = "profile"
        elif node_name == "setup":
            obj_ = Setup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setup.append(obj_)
            obj_.original_tagname_ = "setup"
        elif node_name == "checkstatus":
            obj_ = CheckStatus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checkstatus.append(obj_)
            obj_.original_tagname_ = "checkstatus"
        elif node_name == "mileage":
            obj_ = Mileage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mileage.append(obj_)
            obj_.original_tagname_ = "mileage"
        elif node_name == "totalmileage":
            obj_ = TotalMileage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.totalmileage.append(obj_)
            obj_.original_tagname_ = "totalmileage"
        elif node_name == "batchnum":
            obj_ = BatchNum.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.batchnum = obj_
            obj_.original_tagname_ = "batchnum"


# end class skybitz


class Error(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="error",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("error")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "error":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="error"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="error"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="error",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class error


class Profile(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        mtsn=None,
        asset=None,
        profiletype=None,
        profilenum=None,
        profileid=None,
        profilepwr=None,
        profilestatus=None,
        time=None,
        lastupdate=None,
        expiration=None,
        nextaction=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.mtsn = mtsn
        self.mtsn_nsprefix_ = None
        self.asset = asset
        self.asset_nsprefix_ = None
        self.profiletype = profiletype
        self.profiletype_nsprefix_ = None
        self.profilenum = profilenum
        self.profilenum_nsprefix_ = None
        self.profileid = profileid
        self.profileid_nsprefix_ = None
        self.profilepwr = profilepwr
        self.profilepwr_nsprefix_ = None
        self.profilestatus = profilestatus
        self.profilestatus_nsprefix_ = None
        if isinstance(time, str):
            initvalue_ = datetime_.datetime.strptime(time, "%H:%M:%S").time()
        else:
            initvalue_ = time
        self.time = initvalue_
        self.time_nsprefix_ = None
        self.lastupdate = lastupdate
        self.lastupdate_nsprefix_ = None
        self.expiration = expiration
        self.expiration_nsprefix_ = None
        self.nextaction = nextaction
        self.nextaction_nsprefix_ = None

    def get_mtsn(self):
        return self.mtsn

    def set_mtsn(self, mtsn):
        self.mtsn = mtsn

    def get_asset(self):
        return self.asset

    def set_asset(self, asset):
        self.asset = asset

    def get_profiletype(self):
        return self.profiletype

    def set_profiletype(self, profiletype):
        self.profiletype = profiletype

    def get_profilenum(self):
        return self.profilenum

    def set_profilenum(self, profilenum):
        self.profilenum = profilenum

    def get_profileid(self):
        return self.profileid

    def set_profileid(self, profileid):
        self.profileid = profileid

    def get_profilepwr(self):
        return self.profilepwr

    def set_profilepwr(self, profilepwr):
        self.profilepwr = profilepwr

    def get_profilestatus(self):
        return self.profilestatus

    def set_profilestatus(self, profilestatus):
        self.profilestatus = profilestatus

    def get_time(self):
        return self.time

    def set_time(self, time):
        self.time = time

    def get_lastupdate(self):
        return self.lastupdate

    def set_lastupdate(self, lastupdate):
        self.lastupdate = lastupdate

    def get_expiration(self):
        return self.expiration

    def set_expiration(self, expiration):
        self.expiration = expiration

    def get_nextaction(self):
        return self.nextaction

    def set_nextaction(self, nextaction):
        self.nextaction = nextaction

    def _has_content(self):
        if (
            self.mtsn is not None
            or self.asset is not None
            or self.profiletype is not None
            or self.profilenum is not None
            or self.profileid is not None
            or self.profilepwr is not None
            or self.profilestatus is not None
            or self.time is not None
            or self.lastupdate is not None
            or self.expiration is not None
            or self.nextaction is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="profile",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("profile")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "profile":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="profile"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="profile",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="profile"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="profile",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.mtsn is not None:
            namespace_prefix = (
                self.mtsn_nsprefix_ + ":"
                if (UseCapturedNS and self.mtsn_nsprefix_)
                else ""
            )
            self.mtsn.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="mtsn",
                pretty_print=pretty_print,
            )
        if self.asset is not None:
            namespace_prefix = (
                self.asset_nsprefix_ + ":"
                if (UseCapturedNS and self.asset_nsprefix_)
                else ""
            )
            self.asset.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="asset",
                pretty_print=pretty_print,
            )
        if self.profiletype is not None:
            namespace_prefix = (
                self.profiletype_nsprefix_ + ":"
                if (UseCapturedNS and self.profiletype_nsprefix_)
                else ""
            )
            self.profiletype.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="profiletype",
                pretty_print=pretty_print,
            )
        if self.profilenum is not None:
            namespace_prefix = (
                self.profilenum_nsprefix_ + ":"
                if (UseCapturedNS and self.profilenum_nsprefix_)
                else ""
            )
            self.profilenum.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="profilenum",
                pretty_print=pretty_print,
            )
        if self.profileid is not None:
            namespace_prefix = (
                self.profileid_nsprefix_ + ":"
                if (UseCapturedNS and self.profileid_nsprefix_)
                else ""
            )
            self.profileid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="profileid",
                pretty_print=pretty_print,
            )
        if self.profilepwr is not None:
            namespace_prefix = (
                self.profilepwr_nsprefix_ + ":"
                if (UseCapturedNS and self.profilepwr_nsprefix_)
                else ""
            )
            self.profilepwr.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="profilepwr",
                pretty_print=pretty_print,
            )
        if self.profilestatus is not None:
            namespace_prefix = (
                self.profilestatus_nsprefix_ + ":"
                if (UseCapturedNS and self.profilestatus_nsprefix_)
                else ""
            )
            self.profilestatus.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="profilestatus",
                pretty_print=pretty_print,
            )
        if self.time is not None:
            namespace_prefix = (
                self.time_nsprefix_ + ":"
                if (UseCapturedNS and self.time_nsprefix_)
                else ""
            )
            show_indent(outfile, level, pretty_print)
            outfile.write(
                "<%stime>%s</%stime>%s"
                % (
                    namespace_prefix,
                    self.gds_format_time(self.time, input_name="time"),
                    namespace_prefix,
                    eol_,
                )
            )
        if self.lastupdate is not None:
            namespace_prefix = (
                self.lastupdate_nsprefix_ + ":"
                if (UseCapturedNS and self.lastupdate_nsprefix_)
                else ""
            )
            self.lastupdate.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="lastupdate",
                pretty_print=pretty_print,
            )
        if self.expiration is not None:
            namespace_prefix = (
                self.expiration_nsprefix_ + ":"
                if (UseCapturedNS and self.expiration_nsprefix_)
                else ""
            )
            self.expiration.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="expiration",
                pretty_print=pretty_print,
            )
        if self.nextaction is not None:
            namespace_prefix = (
                self.nextaction_nsprefix_ + ":"
                if (UseCapturedNS and self.nextaction_nsprefix_)
                else ""
            )
            self.nextaction.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="nextaction",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "mtsn":
            obj_ = MTSN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mtsn = obj_
            obj_.original_tagname_ = "mtsn"
        elif node_name == "asset":
            obj_ = Asset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asset = obj_
            obj_.original_tagname_ = "asset"
        elif node_name == "profiletype":
            obj_ = ProfileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.profiletype = obj_
            obj_.original_tagname_ = "profiletype"
        elif node_name == "profilenum":
            obj_ = ProfileNum.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.profilenum = obj_
            obj_.original_tagname_ = "profilenum"
        elif node_name == "profileid":
            obj_ = ProfileId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.profileid = obj_
            obj_.original_tagname_ = "profileid"
        elif node_name == "profilepwr":
            obj_ = ProfilePwr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.profilepwr = obj_
            obj_.original_tagname_ = "profilepwr"
        elif node_name == "profilestatus":
            obj_ = ProfileStatus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.profilestatus = obj_
            obj_.original_tagname_ = "profilestatus"
        elif node_name == "time":
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.time = dval_
            self.time_nsprefix_ = child_.prefix
        elif node_name == "lastupdate":
            obj_ = LastUpdate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lastupdate = obj_
            obj_.original_tagname_ = "lastupdate"
        elif node_name == "expiration":
            obj_ = Expiration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expiration = obj_
            obj_.original_tagname_ = "expiration"
        elif node_name == "nextaction":
            obj_ = NextAction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nextaction = obj_
            obj_.original_tagname_ = "nextaction"


# end class profile


class ProfileType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="profiletype",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("profiletype")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "profiletype":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="profiletype"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="profiletype",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="profiletype",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class profiletype


class ProfileNum(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="profilenum",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("profilenum")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "profilenum":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="profilenum"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="profilenum"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="profilenum",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class profilenum


class ProfileId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="profileid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("profileid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "profileid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="profileid"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="profileid"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="profileid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class profileid


class ProfilePwr(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="profilepwr",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("profilepwr")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "profilepwr":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="profilepwr"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="profilepwr"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="profilepwr",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class profilepwr


class ProfileStatus(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="profilestatus",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("profilestatus")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "profilestatus":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="profilestatus"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="profilestatus",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="profilestatus",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class profilestatus


class LastUpdate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lastupdate",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("lastupdate")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "lastupdate":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="lastupdate"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="lastupdate"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lastupdate",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class lastupdate


class Expiration(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="expiration",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("expiration")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "expiration":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="expiration"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="expiration"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="expiration",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class expiration


class NextAction(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="nextaction",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("nextaction")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "nextaction":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="nextaction"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="nextaction"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="nextaction",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class nextaction


class Setup(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, assettypedef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if assettypedef is None:
            self.assettypedef = []
        else:
            self.assettypedef = assettypedef
        self.assettypedef_nsprefix_ = None

    def get_assettypedef(self):
        return self.assettypedef

    def set_assettypedef(self, assettypedef):
        self.assettypedef = assettypedef

    def add_assettypedef(self, value):
        self.assettypedef.append(value)

    def insert_assettypedef_at(self, index, value):
        self.assettypedef.insert(index, value)

    def replace_assettypedef_at(self, index, value):
        self.assettypedef[index] = value

    def _has_content(self):
        if self.assettypedef:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="setup",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("setup")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "setup":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="setup"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="setup",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="setup"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="setup",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for assettypedef_ in self.assettypedef:
            namespace_prefix = (
                self.assettypedef_nsprefix_ + ":"
                if (UseCapturedNS and self.assettypedef_nsprefix_)
                else ""
            )
            assettypedef_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="assettypedef",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "assettypedef":
            obj_ = AssetTypeDef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assettypedef.append(obj_)
            obj_.original_tagname_ = "assettypedef"


# end class setup


class BatchNum(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="batchnum",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("batchnum")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "batchnum":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="batchnum"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="batchnum"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="batchnum",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class batchnum


class GLS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        mtsn=None,
        dttsstatus=None,
        turnupdate=None,
        turnupdate_iso8601=None,
        activationstatus=None,
        transferdate=None,
        transferdate_iso8601=None,
        shippingaddress=None,
        asset=None,
        messagetype=None,
        binary=None,
        extpwr=None,
        serial=None,
        volumetricdata=None,
        latitude=None,
        latitude_iso6709=None,
        longitude=None,
        longitude_iso6709=None,
        speed=None,
        heading=None,
        headingindegrees=None,
        journeydistance=None,
        totaldevicemileage=None,
        temperaturecelsius=None,
        temperaturefahrenheit=None,
        battery=None,
        time=None,
        time_iso8601=None,
        quality=None,
        landmark=None,
        address=None,
        skyfence=None,
        idle=None,
        epmflag=None,
        ehmeter=None,
        ehcounter=None,
        ats=None,
        reeferstate=None,
        transid=None,
        messagereceivedtime=None,
        messagereceivedtime_iso8601=None,
        devicetype=None,
        departurelocation=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.mtsn = mtsn
        self.mtsn_nsprefix_ = None
        self.dttsstatus = dttsstatus
        self.dttsstatus_nsprefix_ = None
        self.turnupdate = turnupdate
        self.turnupdate_nsprefix_ = None
        self.turnupdate_iso8601 = turnupdate_iso8601
        self.turnupdate_iso8601_nsprefix_ = None
        self.activationstatus = activationstatus
        self.activationstatus_nsprefix_ = None
        self.transferdate = transferdate
        self.transferdate_nsprefix_ = None
        self.transferdate_iso8601 = transferdate_iso8601
        self.transferdate_iso8601_nsprefix_ = None
        self.shippingaddress = shippingaddress
        self.shippingaddress_nsprefix_ = None
        self.asset = asset
        self.asset_nsprefix_ = None
        self.messagetype = messagetype
        self.messagetype_nsprefix_ = None
        if binary is None:
            self.binary = []
        else:
            self.binary = binary
        self.binary_nsprefix_ = None
        self.extpwr = extpwr
        self.extpwr_nsprefix_ = None
        if serial is None:
            self.serial = []
        else:
            self.serial = serial
        self.serial_nsprefix_ = None
        self.volumetricdata = volumetricdata
        self.volumetricdata_nsprefix_ = None
        self.latitude = latitude
        self.latitude_nsprefix_ = None
        self.latitude_iso6709 = latitude_iso6709
        self.latitude_iso6709_nsprefix_ = None
        self.longitude = longitude
        self.longitude_nsprefix_ = None
        self.longitude_iso6709 = longitude_iso6709
        self.longitude_iso6709_nsprefix_ = None
        self.speed = speed
        self.speed_nsprefix_ = None
        self.heading = heading
        self.heading_nsprefix_ = None
        self.headingindegrees = headingindegrees
        self.headingindegrees_nsprefix_ = None
        self.journeydistance = journeydistance
        self.journeydistance_nsprefix_ = None
        self.totaldevicemileage = totaldevicemileage
        self.totaldevicemileage_nsprefix_ = None
        self.temperaturecelsius = temperaturecelsius
        self.temperaturecelsius_nsprefix_ = None
        self.temperaturefahrenheit = temperaturefahrenheit
        self.temperaturefahrenheit_nsprefix_ = None
        self.battery = battery
        self.battery_nsprefix_ = None
        if isinstance(time, str):
            initvalue_ = datetime_.datetime.strptime(time, "%H:%M:%S").time()
        else:
            initvalue_ = time
        self.time = initvalue_
        self.time_nsprefix_ = None
        self.time_iso8601 = time_iso8601
        self.time_iso8601_nsprefix_ = None
        self.quality = quality
        self.quality_nsprefix_ = None
        self.landmark = landmark
        self.landmark_nsprefix_ = None
        self.address = address
        self.address_nsprefix_ = None
        self.skyfence = skyfence
        self.skyfence_nsprefix_ = None
        self.idle = idle
        self.idle_nsprefix_ = None
        self.epmflag = epmflag
        self.epmflag_nsprefix_ = None
        self.ehmeter = ehmeter
        self.ehmeter_nsprefix_ = None
        self.ehcounter = ehcounter
        self.ehcounter_nsprefix_ = None
        self.ats = ats
        self.ats_nsprefix_ = None
        self.reeferstate = reeferstate
        self.reeferstate_nsprefix_ = None
        self.transid = transid
        self.transid_nsprefix_ = None
        self.messagereceivedtime = messagereceivedtime
        self.messagereceivedtime_nsprefix_ = None
        self.messagereceivedtime_iso8601 = messagereceivedtime_iso8601
        self.messagereceivedtime_iso8601_nsprefix_ = None
        self.devicetype = devicetype
        self.devicetype_nsprefix_ = None
        self.departurelocation = departurelocation
        self.departurelocation_nsprefix_ = None

    def get_mtsn(self):
        return self.mtsn

    def set_mtsn(self, mtsn):
        self.mtsn = mtsn

    def get_dttsstatus(self):
        return self.dttsstatus

    def set_dttsstatus(self, dttsstatus):
        self.dttsstatus = dttsstatus

    def get_turnupdate(self):
        return self.turnupdate

    def set_turnupdate(self, turnupdate):
        self.turnupdate = turnupdate

    def get_turnupdate_iso8601(self):
        return self.turnupdate_iso8601

    def set_turnupdate_iso8601(self, turnupdate_iso8601):
        self.turnupdate_iso8601 = turnupdate_iso8601

    def get_activationstatus(self):
        return self.activationstatus

    def set_activationstatus(self, activationstatus):
        self.activationstatus = activationstatus

    def get_transferdate(self):
        return self.transferdate

    def set_transferdate(self, transferdate):
        self.transferdate = transferdate

    def get_transferdate_iso8601(self):
        return self.transferdate_iso8601

    def set_transferdate_iso8601(self, transferdate_iso8601):
        self.transferdate_iso8601 = transferdate_iso8601

    def get_shippingaddress(self):
        return self.shippingaddress

    def set_shippingaddress(self, shippingaddress):
        self.shippingaddress = shippingaddress

    def get_asset(self):
        return self.asset

    def set_asset(self, asset):
        self.asset = asset

    def get_messagetype(self):
        return self.messagetype

    def set_messagetype(self, messagetype):
        self.messagetype = messagetype

    def get_binary(self):
        return self.binary

    def set_binary(self, binary):
        self.binary = binary

    def add_binary(self, value):
        self.binary.append(value)

    def insert_binary_at(self, index, value):
        self.binary.insert(index, value)

    def replace_binary_at(self, index, value):
        self.binary[index] = value

    def get_extpwr(self):
        return self.extpwr

    def set_extpwr(self, extpwr):
        self.extpwr = extpwr

    def get_serial(self):
        return self.serial

    def set_serial(self, serial):
        self.serial = serial

    def add_serial(self, value):
        self.serial.append(value)

    def insert_serial_at(self, index, value):
        self.serial.insert(index, value)

    def replace_serial_at(self, index, value):
        self.serial[index] = value

    def get_volumetricdata(self):
        return self.volumetricdata

    def set_volumetricdata(self, volumetricdata):
        self.volumetricdata = volumetricdata

    def get_latitude(self):
        return self.latitude

    def set_latitude(self, latitude):
        self.latitude = latitude

    def get_latitude_iso6709(self):
        return self.latitude_iso6709

    def set_latitude_iso6709(self, latitude_iso6709):
        self.latitude_iso6709 = latitude_iso6709

    def get_longitude(self):
        return self.longitude

    def set_longitude(self, longitude):
        self.longitude = longitude

    def get_longitude_iso6709(self):
        return self.longitude_iso6709

    def set_longitude_iso6709(self, longitude_iso6709):
        self.longitude_iso6709 = longitude_iso6709

    def get_speed(self):
        return self.speed

    def set_speed(self, speed):
        self.speed = speed

    def get_heading(self):
        return self.heading

    def set_heading(self, heading):
        self.heading = heading

    def get_headingindegrees(self):
        return self.headingindegrees

    def set_headingindegrees(self, headingindegrees):
        self.headingindegrees = headingindegrees

    def get_journeydistance(self):
        return self.journeydistance

    def set_journeydistance(self, journeydistance):
        self.journeydistance = journeydistance

    def get_totaldevicemileage(self):
        return self.totaldevicemileage

    def set_totaldevicemileage(self, totaldevicemileage):
        self.totaldevicemileage = totaldevicemileage

    def get_temperaturecelsius(self):
        return self.temperaturecelsius

    def set_temperaturecelsius(self, temperaturecelsius):
        self.temperaturecelsius = temperaturecelsius

    def get_temperaturefahrenheit(self):
        return self.temperaturefahrenheit

    def set_temperaturefahrenheit(self, temperaturefahrenheit):
        self.temperaturefahrenheit = temperaturefahrenheit

    def get_battery(self):
        return self.battery

    def set_battery(self, battery):
        self.battery = battery

    def get_time(self):
        return self.time

    def set_time(self, time):
        self.time = time

    def get_time_iso8601(self):
        return self.time_iso8601

    def set_time_iso8601(self, time_iso8601):
        self.time_iso8601 = time_iso8601

    def get_quality(self):
        return self.quality

    def set_quality(self, quality):
        self.quality = quality

    def get_landmark(self):
        return self.landmark

    def set_landmark(self, landmark):
        self.landmark = landmark

    def get_address(self):
        return self.address

    def set_address(self, address):
        self.address = address

    def get_skyfence(self):
        return self.skyfence

    def set_skyfence(self, skyfence):
        self.skyfence = skyfence

    def get_idle(self):
        return self.idle

    def set_idle(self, idle):
        self.idle = idle

    def get_epmflag(self):
        return self.epmflag

    def set_epmflag(self, epmflag):
        self.epmflag = epmflag

    def get_ehmeter(self):
        return self.ehmeter

    def set_ehmeter(self, ehmeter):
        self.ehmeter = ehmeter

    def get_ehcounter(self):
        return self.ehcounter

    def set_ehcounter(self, ehcounter):
        self.ehcounter = ehcounter

    def get_ats(self):
        return self.ats

    def set_ats(self, ats):
        self.ats = ats

    def get_reeferstate(self):
        return self.reeferstate

    def set_reeferstate(self, reeferstate):
        self.reeferstate = reeferstate

    def get_transid(self):
        return self.transid

    def set_transid(self, transid):
        self.transid = transid

    def get_messagereceivedtime(self):
        return self.messagereceivedtime

    def set_messagereceivedtime(self, messagereceivedtime):
        self.messagereceivedtime = messagereceivedtime

    def get_messagereceivedtime_iso8601(self):
        return self.messagereceivedtime_iso8601

    def set_messagereceivedtime_iso8601(self, messagereceivedtime_iso8601):
        self.messagereceivedtime_iso8601 = messagereceivedtime_iso8601

    def get_devicetype(self):
        return self.devicetype

    def set_devicetype(self, devicetype):
        self.devicetype = devicetype

    def get_departurelocation(self):
        return self.departurelocation

    def set_departurelocation(self, departurelocation):
        self.departurelocation = departurelocation

    def _has_content(self):
        if (
            self.mtsn is not None
            or self.dttsstatus is not None
            or self.turnupdate is not None
            or self.turnupdate_iso8601 is not None
            or self.activationstatus is not None
            or self.transferdate is not None
            or self.transferdate_iso8601 is not None
            or self.shippingaddress is not None
            or self.asset is not None
            or self.messagetype is not None
            or self.binary
            or self.extpwr is not None
            or self.serial
            or self.volumetricdata is not None
            or self.latitude is not None
            or self.latitude_iso6709 is not None
            or self.longitude is not None
            or self.longitude_iso6709 is not None
            or self.speed is not None
            or self.heading is not None
            or self.headingindegrees is not None
            or self.journeydistance is not None
            or self.totaldevicemileage is not None
            or self.temperaturecelsius is not None
            or self.temperaturefahrenheit is not None
            or self.battery is not None
            or self.time is not None
            or self.time_iso8601 is not None
            or self.quality is not None
            or self.landmark is not None
            or self.address is not None
            or self.skyfence is not None
            or self.idle is not None
            or self.epmflag is not None
            or self.ehmeter is not None
            or self.ehcounter is not None
            or self.ats is not None
            or self.reeferstate is not None
            or self.transid is not None
            or self.messagereceivedtime is not None
            or self.messagereceivedtime_iso8601 is not None
            or self.devicetype is not None
            or self.departurelocation is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="gls",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("gls")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "gls":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="gls"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="gls",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="gls"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="gls",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.mtsn is not None:
            namespace_prefix = (
                self.mtsn_nsprefix_ + ":"
                if (UseCapturedNS and self.mtsn_nsprefix_)
                else ""
            )
            self.mtsn.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="mtsn",
                pretty_print=pretty_print,
            )
        if self.dttsstatus is not None:
            namespace_prefix = (
                self.dttsstatus_nsprefix_ + ":"
                if (UseCapturedNS and self.dttsstatus_nsprefix_)
                else ""
            )
            self.dttsstatus.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="dttsstatus",
                pretty_print=pretty_print,
            )
        if self.turnupdate is not None:
            namespace_prefix = (
                self.turnupdate_nsprefix_ + ":"
                if (UseCapturedNS and self.turnupdate_nsprefix_)
                else ""
            )
            self.turnupdate.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="turnupdate",
                pretty_print=pretty_print,
            )
        if self.turnupdate_iso8601 is not None:
            namespace_prefix = (
                self.turnupdate_iso8601_nsprefix_ + ":"
                if (UseCapturedNS and self.turnupdate_iso8601_nsprefix_)
                else ""
            )
            self.turnupdate_iso8601.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="turnupdate-iso8601",
                pretty_print=pretty_print,
            )
        if self.activationstatus is not None:
            namespace_prefix = (
                self.activationstatus_nsprefix_ + ":"
                if (UseCapturedNS and self.activationstatus_nsprefix_)
                else ""
            )
            self.activationstatus.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="activationstatus",
                pretty_print=pretty_print,
            )
        if self.transferdate is not None:
            namespace_prefix = (
                self.transferdate_nsprefix_ + ":"
                if (UseCapturedNS and self.transferdate_nsprefix_)
                else ""
            )
            self.transferdate.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="transferdate",
                pretty_print=pretty_print,
            )
        if self.transferdate_iso8601 is not None:
            namespace_prefix = (
                self.transferdate_iso8601_nsprefix_ + ":"
                if (UseCapturedNS and self.transferdate_iso8601_nsprefix_)
                else ""
            )
            self.transferdate_iso8601.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="transferdate-iso8601",
                pretty_print=pretty_print,
            )
        if self.shippingaddress is not None:
            namespace_prefix = (
                self.shippingaddress_nsprefix_ + ":"
                if (UseCapturedNS and self.shippingaddress_nsprefix_)
                else ""
            )
            self.shippingaddress.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="shippingaddress",
                pretty_print=pretty_print,
            )
        if self.asset is not None:
            namespace_prefix = (
                self.asset_nsprefix_ + ":"
                if (UseCapturedNS and self.asset_nsprefix_)
                else ""
            )
            self.asset.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="asset",
                pretty_print=pretty_print,
            )
        if self.messagetype is not None:
            namespace_prefix = (
                self.messagetype_nsprefix_ + ":"
                if (UseCapturedNS and self.messagetype_nsprefix_)
                else ""
            )
            self.messagetype.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="messagetype",
                pretty_print=pretty_print,
            )
        for binary_ in self.binary:
            namespace_prefix = (
                self.binary_nsprefix_ + ":"
                if (UseCapturedNS and self.binary_nsprefix_)
                else ""
            )
            binary_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="binary",
                pretty_print=pretty_print,
            )
        if self.extpwr is not None:
            namespace_prefix = (
                self.extpwr_nsprefix_ + ":"
                if (UseCapturedNS and self.extpwr_nsprefix_)
                else ""
            )
            self.extpwr.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="extpwr",
                pretty_print=pretty_print,
            )
        for serial_ in self.serial:
            namespace_prefix = (
                self.serial_nsprefix_ + ":"
                if (UseCapturedNS and self.serial_nsprefix_)
                else ""
            )
            serial_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="serial",
                pretty_print=pretty_print,
            )
        if self.volumetricdata is not None:
            namespace_prefix = (
                self.volumetricdata_nsprefix_ + ":"
                if (UseCapturedNS and self.volumetricdata_nsprefix_)
                else ""
            )
            self.volumetricdata.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="volumetricdata",
                pretty_print=pretty_print,
            )
        if self.latitude is not None:
            namespace_prefix = (
                self.latitude_nsprefix_ + ":"
                if (UseCapturedNS and self.latitude_nsprefix_)
                else ""
            )
            self.latitude.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="latitude",
                pretty_print=pretty_print,
            )
        if self.latitude_iso6709 is not None:
            namespace_prefix = (
                self.latitude_iso6709_nsprefix_ + ":"
                if (UseCapturedNS and self.latitude_iso6709_nsprefix_)
                else ""
            )
            self.latitude_iso6709.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="latitude-iso6709",
                pretty_print=pretty_print,
            )
        if self.longitude is not None:
            namespace_prefix = (
                self.longitude_nsprefix_ + ":"
                if (UseCapturedNS and self.longitude_nsprefix_)
                else ""
            )
            self.longitude.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="longitude",
                pretty_print=pretty_print,
            )
        if self.longitude_iso6709 is not None:
            namespace_prefix = (
                self.longitude_iso6709_nsprefix_ + ":"
                if (UseCapturedNS and self.longitude_iso6709_nsprefix_)
                else ""
            )
            self.longitude_iso6709.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="longitude-iso6709",
                pretty_print=pretty_print,
            )
        if self.speed is not None:
            namespace_prefix = (
                self.speed_nsprefix_ + ":"
                if (UseCapturedNS and self.speed_nsprefix_)
                else ""
            )
            self.speed.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="speed",
                pretty_print=pretty_print,
            )
        if self.heading is not None:
            namespace_prefix = (
                self.heading_nsprefix_ + ":"
                if (UseCapturedNS and self.heading_nsprefix_)
                else ""
            )
            self.heading.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="heading",
                pretty_print=pretty_print,
            )
        if self.headingindegrees is not None:
            namespace_prefix = (
                self.headingindegrees_nsprefix_ + ":"
                if (UseCapturedNS and self.headingindegrees_nsprefix_)
                else ""
            )
            self.headingindegrees.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="headingindegrees",
                pretty_print=pretty_print,
            )
        if self.journeydistance is not None:
            namespace_prefix = (
                self.journeydistance_nsprefix_ + ":"
                if (UseCapturedNS and self.journeydistance_nsprefix_)
                else ""
            )
            self.journeydistance.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="journeydistance",
                pretty_print=pretty_print,
            )
        if self.totaldevicemileage is not None:
            namespace_prefix = (
                self.totaldevicemileage_nsprefix_ + ":"
                if (UseCapturedNS and self.totaldevicemileage_nsprefix_)
                else ""
            )
            self.totaldevicemileage.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="totaldevicemileage",
                pretty_print=pretty_print,
            )
        if self.temperaturecelsius is not None:
            namespace_prefix = (
                self.temperaturecelsius_nsprefix_ + ":"
                if (UseCapturedNS and self.temperaturecelsius_nsprefix_)
                else ""
            )
            self.temperaturecelsius.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="temperaturecelsius",
                pretty_print=pretty_print,
            )
        if self.temperaturefahrenheit is not None:
            namespace_prefix = (
                self.temperaturefahrenheit_nsprefix_ + ":"
                if (UseCapturedNS and self.temperaturefahrenheit_nsprefix_)
                else ""
            )
            self.temperaturefahrenheit.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="temperaturefahrenheit",
                pretty_print=pretty_print,
            )
        if self.battery is not None:
            namespace_prefix = (
                self.battery_nsprefix_ + ":"
                if (UseCapturedNS and self.battery_nsprefix_)
                else ""
            )
            self.battery.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="battery",
                pretty_print=pretty_print,
            )
        if self.time is not None:
            namespace_prefix = (
                self.time_nsprefix_ + ":"
                if (UseCapturedNS and self.time_nsprefix_)
                else ""
            )
            show_indent(outfile, level, pretty_print)
            outfile.write(
                "<%stime>%s</%stime>%s"
                % (
                    namespace_prefix,
                    self.gds_format_time(self.time, input_name="time"),
                    namespace_prefix,
                    eol_,
                )
            )
        if self.time_iso8601 is not None:
            namespace_prefix = (
                self.time_iso8601_nsprefix_ + ":"
                if (UseCapturedNS and self.time_iso8601_nsprefix_)
                else ""
            )
            self.time_iso8601.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="time-iso8601",
                pretty_print=pretty_print,
            )
        if self.quality is not None:
            namespace_prefix = (
                self.quality_nsprefix_ + ":"
                if (UseCapturedNS and self.quality_nsprefix_)
                else ""
            )
            self.quality.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="quality",
                pretty_print=pretty_print,
            )
        if self.landmark is not None:
            namespace_prefix = (
                self.landmark_nsprefix_ + ":"
                if (UseCapturedNS and self.landmark_nsprefix_)
                else ""
            )
            self.landmark.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="landmark",
                pretty_print=pretty_print,
            )
        if self.address is not None:
            namespace_prefix = (
                self.address_nsprefix_ + ":"
                if (UseCapturedNS and self.address_nsprefix_)
                else ""
            )
            self.address.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="address",
                pretty_print=pretty_print,
            )
        if self.skyfence is not None:
            namespace_prefix = (
                self.skyfence_nsprefix_ + ":"
                if (UseCapturedNS and self.skyfence_nsprefix_)
                else ""
            )
            self.skyfence.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="skyfence",
                pretty_print=pretty_print,
            )
        if self.idle is not None:
            namespace_prefix = (
                self.idle_nsprefix_ + ":"
                if (UseCapturedNS and self.idle_nsprefix_)
                else ""
            )
            self.idle.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="idle",
                pretty_print=pretty_print,
            )
        if self.epmflag is not None:
            namespace_prefix = (
                self.epmflag_nsprefix_ + ":"
                if (UseCapturedNS and self.epmflag_nsprefix_)
                else ""
            )
            self.epmflag.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="epmflag",
                pretty_print=pretty_print,
            )
        if self.ehmeter is not None:
            namespace_prefix = (
                self.ehmeter_nsprefix_ + ":"
                if (UseCapturedNS and self.ehmeter_nsprefix_)
                else ""
            )
            self.ehmeter.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="ehmeter",
                pretty_print=pretty_print,
            )
        if self.ehcounter is not None:
            namespace_prefix = (
                self.ehcounter_nsprefix_ + ":"
                if (UseCapturedNS and self.ehcounter_nsprefix_)
                else ""
            )
            self.ehcounter.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="ehcounter",
                pretty_print=pretty_print,
            )
        if self.ats is not None:
            namespace_prefix = (
                self.ats_nsprefix_ + ":"
                if (UseCapturedNS and self.ats_nsprefix_)
                else ""
            )
            self.ats.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="ats",
                pretty_print=pretty_print,
            )
        if self.reeferstate is not None:
            namespace_prefix = (
                self.reeferstate_nsprefix_ + ":"
                if (UseCapturedNS and self.reeferstate_nsprefix_)
                else ""
            )
            self.reeferstate.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="reeferstate",
                pretty_print=pretty_print,
            )
        if self.transid is not None:
            namespace_prefix = (
                self.transid_nsprefix_ + ":"
                if (UseCapturedNS and self.transid_nsprefix_)
                else ""
            )
            self.transid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="transid",
                pretty_print=pretty_print,
            )
        if self.messagereceivedtime is not None:
            namespace_prefix = (
                self.messagereceivedtime_nsprefix_ + ":"
                if (UseCapturedNS and self.messagereceivedtime_nsprefix_)
                else ""
            )
            self.messagereceivedtime.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="messagereceivedtime",
                pretty_print=pretty_print,
            )
        if self.messagereceivedtime_iso8601 is not None:
            namespace_prefix = (
                self.messagereceivedtime_iso8601_nsprefix_ + ":"
                if (UseCapturedNS and self.messagereceivedtime_iso8601_nsprefix_)
                else ""
            )
            self.messagereceivedtime_iso8601.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="messagereceivedtime-iso8601",
                pretty_print=pretty_print,
            )
        if self.devicetype is not None:
            namespace_prefix = (
                self.devicetype_nsprefix_ + ":"
                if (UseCapturedNS and self.devicetype_nsprefix_)
                else ""
            )
            self.devicetype.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="devicetype",
                pretty_print=pretty_print,
            )
        if self.departurelocation is not None:
            namespace_prefix = (
                self.departurelocation_nsprefix_ + ":"
                if (UseCapturedNS and self.departurelocation_nsprefix_)
                else ""
            )
            self.departurelocation.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departurelocation",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "mtsn":
            obj_ = MTSN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mtsn = obj_
            obj_.original_tagname_ = "mtsn"
        elif node_name == "dttsstatus":
            obj_ = DTTSStatus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dttsstatus = obj_
            obj_.original_tagname_ = "dttsstatus"
        elif node_name == "turnupdate":
            obj_ = TurnUpdate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.turnupdate = obj_
            obj_.original_tagname_ = "turnupdate"
        elif node_name == "turnupdate-iso8601":
            obj_ = TurnUpdateISO8601.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.turnupdate_iso8601 = obj_
            obj_.original_tagname_ = "turnupdate-iso8601"
        elif node_name == "activationstatus":
            obj_ = ActivationStatus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activationstatus = obj_
            obj_.original_tagname_ = "activationstatus"
        elif node_name == "transferdate":
            obj_ = TransferDate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transferdate = obj_
            obj_.original_tagname_ = "transferdate"
        elif node_name == "transferdate-iso8601":
            obj_ = TransferDateISO8601.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transferdate_iso8601 = obj_
            obj_.original_tagname_ = "transferdate-iso8601"
        elif node_name == "shippingaddress":
            obj_ = ShippingAddress.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.shippingaddress = obj_
            obj_.original_tagname_ = "shippingaddress"
        elif node_name == "asset":
            obj_ = Asset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asset = obj_
            obj_.original_tagname_ = "asset"
        elif node_name == "messagetype":
            obj_ = MessageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.messagetype = obj_
            obj_.original_tagname_ = "messagetype"
        elif node_name == "binary":
            obj_ = Binary.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.binary.append(obj_)
            obj_.original_tagname_ = "binary"
        elif node_name == "extpwr":
            obj_ = ExtPwr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extpwr = obj_
            obj_.original_tagname_ = "extpwr"
        elif node_name == "serial":
            obj_ = Serial.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serial.append(obj_)
            obj_.original_tagname_ = "serial"
        elif node_name == "volumetricdata":
            obj_ = VolumetricData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.volumetricdata = obj_
            obj_.original_tagname_ = "volumetricdata"
        elif node_name == "latitude":
            obj_ = Latitude.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.latitude = obj_
            obj_.original_tagname_ = "latitude"
        elif node_name == "latitude-iso6709":
            obj_ = LatitudeISO6709.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.latitude_iso6709 = obj_
            obj_.original_tagname_ = "latitude-iso6709"
        elif node_name == "longitude":
            obj_ = Longitude.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.longitude = obj_
            obj_.original_tagname_ = "longitude"
        elif node_name == "longitude-iso6709":
            obj_ = LongitudeISO6709.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.longitude_iso6709 = obj_
            obj_.original_tagname_ = "longitude-iso6709"
        elif node_name == "speed":
            obj_ = Speed.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.speed = obj_
            obj_.original_tagname_ = "speed"
        elif node_name == "heading":
            obj_ = Heading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.heading = obj_
            obj_.original_tagname_ = "heading"
        elif node_name == "headingindegrees":
            obj_ = HeadingInDegrees.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.headingindegrees = obj_
            obj_.original_tagname_ = "headingindegrees"
        elif node_name == "journeydistance":
            obj_ = JourneyDistance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.journeydistance = obj_
            obj_.original_tagname_ = "journeydistance"
        elif node_name == "totaldevicemileage":
            obj_ = TotalDeviceMileage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.totaldevicemileage = obj_
            obj_.original_tagname_ = "totaldevicemileage"
        elif node_name == "temperaturecelsius":
            obj_ = TemperatureCelsius.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.temperaturecelsius = obj_
            obj_.original_tagname_ = "temperaturecelsius"
        elif node_name == "temperaturefahrenheit":
            obj_ = TemperatureFahrenheit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.temperaturefahrenheit = obj_
            obj_.original_tagname_ = "temperaturefahrenheit"
        elif node_name == "battery":
            obj_ = Battery.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.battery = obj_
            obj_.original_tagname_ = "battery"
        elif node_name == "time":
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.time = dval_
            self.time_nsprefix_ = child_.prefix
        elif node_name == "time-iso8601":
            obj_ = TimeISO8601.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_iso8601 = obj_
            obj_.original_tagname_ = "time-iso8601"
        elif node_name == "quality":
            obj_ = Quality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quality = obj_
            obj_.original_tagname_ = "quality"
        elif node_name == "landmark":
            obj_ = LandMark.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.landmark = obj_
            obj_.original_tagname_ = "landmark"
        elif node_name == "address":
            obj_ = Address.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.address = obj_
            obj_.original_tagname_ = "address"
        elif node_name == "skyfence":
            obj_ = SkyFence.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.skyfence = obj_
            obj_.original_tagname_ = "skyfence"
        elif node_name == "idle":
            obj_ = Idle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.idle = obj_
            obj_.original_tagname_ = "idle"
        elif node_name == "epmflag":
            obj_ = EPMFlag.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.epmflag = obj_
            obj_.original_tagname_ = "epmflag"
        elif node_name == "ehmeter":
            obj_ = EHMeter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ehmeter = obj_
            obj_.original_tagname_ = "ehmeter"
        elif node_name == "ehcounter":
            obj_ = EHCounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ehcounter = obj_
            obj_.original_tagname_ = "ehcounter"
        elif node_name == "ats":
            obj_ = ATS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ats = obj_
            obj_.original_tagname_ = "ats"
        elif node_name == "reeferstate":
            obj_ = ReeferState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reeferstate = obj_
            obj_.original_tagname_ = "reeferstate"
        elif node_name == "transid":
            obj_ = TransId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transid = obj_
            obj_.original_tagname_ = "transid"
        elif node_name == "messagereceivedtime":
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.messagereceivedtime = dval_
        elif node_name == "messagereceivedtime-iso8601":
            obj_ = MessageReceivedTimeISO8601.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.messagereceivedtime_iso8601 = obj_
            obj_.original_tagname_ = "messagereceivedtime-iso8601"
        elif node_name == "devicetype":
            obj_ = DeviceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.devicetype = obj_
            obj_.original_tagname_ = "devicetype"
        elif node_name == "departurelocation":
            obj_ = DepartureLocation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departurelocation = obj_
            obj_.original_tagname_ = "departurelocation"


# end class gls


class MTSN(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mtsn",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("mtsn")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "mtsn":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="mtsn"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="mtsn"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mtsn",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class mtsn


class DTTSStatus(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="dttsstatus",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("dttsstatus")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "dttsstatus":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="dttsstatus"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="dttsstatus"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="dttsstatus",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class dttsstatus


class DeviceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="devicetype",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("devicetype")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "devicetype":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="devicetype"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="devicetype"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="devicetype",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class devicetype


class Asset(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        assetid=None,
        tractorid=None,
        assettype=None,
        owner=None,
        ownerscac=None,
        lessee=None,
        lesseescac=None,
        lessor=None,
        lessorscac=None,
        note=None,
        installdate=None,
        installdate_iso8601=None,
        installlocation=None,
        secondaryid=None,
        acctid=None,
        agreementtype=None,
        branchname=None,
        groups=None,
        container=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.assetid = assetid
        self.assetid_nsprefix_ = None
        self.tractorid = tractorid
        self.tractorid_nsprefix_ = None
        self.assettype = assettype
        self.assettype_nsprefix_ = None
        self.owner = owner
        self.owner_nsprefix_ = None
        self.ownerscac = ownerscac
        self.ownerscac_nsprefix_ = None
        self.lessee = lessee
        self.lessee_nsprefix_ = None
        self.lesseescac = lesseescac
        self.lesseescac_nsprefix_ = None
        self.lessor = lessor
        self.lessor_nsprefix_ = None
        self.lessorscac = lessorscac
        self.lessorscac_nsprefix_ = None
        self.note = note
        self.note_nsprefix_ = None
        self.installdate = installdate
        self.installdate_nsprefix_ = None
        self.installdate_iso8601 = installdate_iso8601
        self.installdate_iso8601_nsprefix_ = None
        self.installlocation = installlocation
        self.installlocation_nsprefix_ = None
        self.secondaryid = secondaryid
        self.secondaryid_nsprefix_ = None
        self.acctid = acctid
        self.acctid_nsprefix_ = None
        self.agreementtype = agreementtype
        self.agreementtype_nsprefix_ = None
        self.branchname = branchname
        self.branchname_nsprefix_ = None
        self.groups = groups
        self.groups_nsprefix_ = None
        self.container = container
        self.container_nsprefix_ = None

    def get_assetid(self):
        return self.assetid

    def set_assetid(self, assetid):
        self.assetid = assetid

    def get_tractorid(self):
        return self.tractorid

    def set_tractorid(self, tractorid):
        self.tractorid = tractorid

    def get_assettype(self):
        return self.assettype

    def set_assettype(self, assettype):
        self.assettype = assettype

    def get_owner(self):
        return self.owner

    def set_owner(self, owner):
        self.owner = owner

    def get_ownerscac(self):
        return self.ownerscac

    def set_ownerscac(self, ownerscac):
        self.ownerscac = ownerscac

    def get_lessee(self):
        return self.lessee

    def set_lessee(self, lessee):
        self.lessee = lessee

    def get_lesseescac(self):
        return self.lesseescac

    def set_lesseescac(self, lesseescac):
        self.lesseescac = lesseescac

    def get_lessor(self):
        return self.lessor

    def set_lessor(self, lessor):
        self.lessor = lessor

    def get_lessorscac(self):
        return self.lessorscac

    def set_lessorscac(self, lessorscac):
        self.lessorscac = lessorscac

    def get_note(self):
        return self.note

    def set_note(self, note):
        self.note = note

    def get_installdate(self):
        return self.installdate

    def set_installdate(self, installdate):
        self.installdate = installdate

    def get_installdate_iso8601(self):
        return self.installdate_iso8601

    def set_installdate_iso8601(self, installdate_iso8601):
        self.installdate_iso8601 = installdate_iso8601

    def get_installlocation(self):
        return self.installlocation

    def set_installlocation(self, installlocation):
        self.installlocation = installlocation

    def get_secondaryid(self):
        return self.secondaryid

    def set_secondaryid(self, secondaryid):
        self.secondaryid = secondaryid

    def get_acctid(self):
        return self.acctid

    def set_acctid(self, acctid):
        self.acctid = acctid

    def get_agreementtype(self):
        return self.agreementtype

    def set_agreementtype(self, agreementtype):
        self.agreementtype = agreementtype

    def get_branchname(self):
        return self.branchname

    def set_branchname(self, branchname):
        self.branchname = branchname

    def get_groups(self):
        return self.groups

    def set_groups(self, groups):
        self.groups = groups

    def get_container(self):
        return self.container

    def set_container(self, container):
        self.container = container

    def _has_content(self):
        if (
            self.assetid is not None
            or self.tractorid is not None
            or self.assettype is not None
            or self.owner is not None
            or self.ownerscac is not None
            or self.lessee is not None
            or self.lesseescac is not None
            or self.lessor is not None
            or self.lessorscac is not None
            or self.note is not None
            or self.installdate is not None
            or self.installdate_iso8601 is not None
            or self.installlocation is not None
            or self.secondaryid is not None
            or self.acctid is not None
            or self.agreementtype is not None
            or self.branchname is not None
            or self.groups is not None
            or self.container is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="asset",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("asset")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "asset":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="asset"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="asset",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="asset"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="asset",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.assetid is not None:
            namespace_prefix = (
                self.assetid_nsprefix_ + ":"
                if (UseCapturedNS and self.assetid_nsprefix_)
                else ""
            )
            self.assetid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="assetid",
                pretty_print=pretty_print,
            )
        if self.tractorid is not None:
            namespace_prefix = (
                self.tractorid_nsprefix_ + ":"
                if (UseCapturedNS and self.tractorid_nsprefix_)
                else ""
            )
            self.tractorid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="tractorid",
                pretty_print=pretty_print,
            )
        if self.assettype is not None:
            namespace_prefix = (
                self.assettype_nsprefix_ + ":"
                if (UseCapturedNS and self.assettype_nsprefix_)
                else ""
            )
            self.assettype.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="assettype",
                pretty_print=pretty_print,
            )
        if self.owner is not None:
            namespace_prefix = (
                self.owner_nsprefix_ + ":"
                if (UseCapturedNS and self.owner_nsprefix_)
                else ""
            )
            self.owner.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="owner",
                pretty_print=pretty_print,
            )
        if self.ownerscac is not None:
            namespace_prefix = (
                self.ownerscac_nsprefix_ + ":"
                if (UseCapturedNS and self.ownerscac_nsprefix_)
                else ""
            )
            self.ownerscac.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="ownerscac",
                pretty_print=pretty_print,
            )
        if self.lessee is not None:
            namespace_prefix = (
                self.lessee_nsprefix_ + ":"
                if (UseCapturedNS and self.lessee_nsprefix_)
                else ""
            )
            self.lessee.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="lessee",
                pretty_print=pretty_print,
            )
        if self.lesseescac is not None:
            namespace_prefix = (
                self.lesseescac_nsprefix_ + ":"
                if (UseCapturedNS and self.lesseescac_nsprefix_)
                else ""
            )
            self.lesseescac.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="lesseescac",
                pretty_print=pretty_print,
            )
        if self.lessor is not None:
            namespace_prefix = (
                self.lessor_nsprefix_ + ":"
                if (UseCapturedNS and self.lessor_nsprefix_)
                else ""
            )
            self.lessor.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="lessor",
                pretty_print=pretty_print,
            )
        if self.lessorscac is not None:
            namespace_prefix = (
                self.lessorscac_nsprefix_ + ":"
                if (UseCapturedNS and self.lessorscac_nsprefix_)
                else ""
            )
            self.lessorscac.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="lessorscac",
                pretty_print=pretty_print,
            )
        if self.note is not None:
            namespace_prefix = (
                self.note_nsprefix_ + ":"
                if (UseCapturedNS and self.note_nsprefix_)
                else ""
            )
            self.note.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="note",
                pretty_print=pretty_print,
            )
        if self.installdate is not None:
            namespace_prefix = (
                self.installdate_nsprefix_ + ":"
                if (UseCapturedNS and self.installdate_nsprefix_)
                else ""
            )
            self.installdate.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installdate",
                pretty_print=pretty_print,
            )
        if self.installdate_iso8601 is not None:
            namespace_prefix = (
                self.installdate_iso8601_nsprefix_ + ":"
                if (UseCapturedNS and self.installdate_iso8601_nsprefix_)
                else ""
            )
            self.installdate_iso8601.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installdate-iso8601",
                pretty_print=pretty_print,
            )
        if self.installlocation is not None:
            namespace_prefix = (
                self.installlocation_nsprefix_ + ":"
                if (UseCapturedNS and self.installlocation_nsprefix_)
                else ""
            )
            self.installlocation.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installlocation",
                pretty_print=pretty_print,
            )
        if self.secondaryid is not None:
            namespace_prefix = (
                self.secondaryid_nsprefix_ + ":"
                if (UseCapturedNS and self.secondaryid_nsprefix_)
                else ""
            )
            self.secondaryid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="secondaryid",
                pretty_print=pretty_print,
            )
        if self.acctid is not None:
            namespace_prefix = (
                self.acctid_nsprefix_ + ":"
                if (UseCapturedNS and self.acctid_nsprefix_)
                else ""
            )
            self.acctid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="acctid",
                pretty_print=pretty_print,
            )
        if self.agreementtype is not None:
            namespace_prefix = (
                self.agreementtype_nsprefix_ + ":"
                if (UseCapturedNS and self.agreementtype_nsprefix_)
                else ""
            )
            self.agreementtype.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="agreementtype",
                pretty_print=pretty_print,
            )
        if self.branchname is not None:
            namespace_prefix = (
                self.branchname_nsprefix_ + ":"
                if (UseCapturedNS and self.branchname_nsprefix_)
                else ""
            )
            self.branchname.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="branchname",
                pretty_print=pretty_print,
            )
        if self.groups is not None:
            namespace_prefix = (
                self.groups_nsprefix_ + ":"
                if (UseCapturedNS and self.groups_nsprefix_)
                else ""
            )
            self.groups.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="groups",
                pretty_print=pretty_print,
            )
        if self.container is not None:
            namespace_prefix = (
                self.container_nsprefix_ + ":"
                if (UseCapturedNS and self.container_nsprefix_)
                else ""
            )
            self.container.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="container",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "assetid":
            obj_ = AssetId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assetid = obj_
            obj_.original_tagname_ = "assetid"
        elif node_name == "tractorid":
            obj_ = TractorId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tractorid = obj_
            obj_.original_tagname_ = "tractorid"
        elif node_name == "assettype":
            obj_ = AssetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assettype = obj_
            obj_.original_tagname_ = "assettype"
        elif node_name == "owner":
            obj_ = Owner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.owner = obj_
            obj_.original_tagname_ = "owner"
        elif node_name == "ownerscac":
            obj_ = OwnersCac.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ownerscac = obj_
            obj_.original_tagname_ = "ownerscac"
        elif node_name == "lessee":
            obj_ = Lessee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lessee = obj_
            obj_.original_tagname_ = "lessee"
        elif node_name == "lesseescac":
            obj_ = LesseesCac.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lesseescac = obj_
            obj_.original_tagname_ = "lesseescac"
        elif node_name == "lessor":
            obj_ = Lessor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lessor = obj_
            obj_.original_tagname_ = "lessor"
        elif node_name == "lessorscac":
            obj_ = LessorsCac.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lessorscac = obj_
            obj_.original_tagname_ = "lessorscac"
        elif node_name == "note":
            obj_ = Note.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.note = obj_
            obj_.original_tagname_ = "note"
        elif node_name == "installdate":
            obj_ = InstallDate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installdate = obj_
            obj_.original_tagname_ = "installdate"
        elif node_name == "installdate-iso8601":
            obj_ = InstallDateISO8601.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installdate_iso8601 = obj_
            obj_.original_tagname_ = "installdate-iso8601"
        elif node_name == "installlocation":
            obj_ = InstallLocation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installlocation = obj_
            obj_.original_tagname_ = "installlocation"
        elif node_name == "secondaryid":
            obj_ = SecondaryId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.secondaryid = obj_
            obj_.original_tagname_ = "secondaryid"
        elif node_name == "acctid":
            obj_ = AcctId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.acctid = obj_
            obj_.original_tagname_ = "acctid"
        elif node_name == "agreementtype":
            obj_ = AgreementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.agreementtype = obj_
            obj_.original_tagname_ = "agreementtype"
        elif node_name == "branchname":
            obj_ = BranchName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.branchname = obj_
            obj_.original_tagname_ = "branchname"
        elif node_name == "groups":
            obj_ = Groups.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groups = obj_
            obj_.original_tagname_ = "groups"
        elif node_name == "container":
            obj_ = Container.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.container = obj_
            obj_.original_tagname_ = "container"


# end class asset


class TractorId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="tractorid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("tractorid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "tractorid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="tractorid"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="tractorid"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="tractorid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class tractorid


class AssetId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assetid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("assetid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "assetid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="assetid"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="assetid"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assetid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class assetid


class AssetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assettype",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("assettype")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "assettype":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="assettype"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="assettype"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assettype",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class assettype


class Owner(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="owner",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("owner")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "owner":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="owner"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="owner"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="owner",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class owner


class SecondaryId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="secondaryid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("secondaryid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "secondaryid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="secondaryid"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="secondaryid",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="secondaryid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class secondaryid


class AcctId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="acctid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("acctid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "acctid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="acctid"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="acctid"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="acctid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class acctid


class AgreementType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="agreementtype",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("agreementtype")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "agreementtype":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="agreementtype"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="agreementtype",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="agreementtype",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class agreementtype


class BranchName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="branchname",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("branchname")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "branchname":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="branchname"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="branchname"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="branchname",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class branchname


class Note(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="note",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("note")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "note":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="note"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="note"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="note",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class note


class Lessor(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lessor",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("lessor")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "lessor":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="lessor"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="lessor"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lessor",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class lessor


class Lessee(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lessee",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("lessee")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "lessee":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="lessee"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="lessee"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lessee",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class lessee


class OwnersCac(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="ownerscac",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("ownerscac")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ownerscac":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="ownerscac"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="ownerscac"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="ownerscac",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class ownerscac


class LessorsCac(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lessorscac",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("lessorscac")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "lessorscac":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="lessorscac"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="lessorscac"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lessorscac",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class lessorscac


class LesseesCac(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lesseescac",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("lesseescac")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "lesseescac":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="lesseescac"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="lesseescac"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lesseescac",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class lesseescac


class TurnUpdate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="turnupdate",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("turnupdate")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "turnupdate":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="turnupdate"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="turnupdate"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="turnupdate",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class turnupdate


class TurnUpdateISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="turnupdate-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("turnupdate-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "turnupdate-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="turnupdate-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="turnupdate-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="turnupdate-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class turnupdate_iso8601


class ActivationStatus(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="activationstatus",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("activationstatus")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "activationstatus":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="activationstatus",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="activationstatus",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="activationstatus",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class activationstatus


class InstallDate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installdate",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installdate")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installdate":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="installdate"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installdate",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installdate",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installdate


class InstallDateISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installdate-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installdate-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installdate-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="installdate-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installdate-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installdate-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installdate_iso8601


class InstallLocation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        installlatitude=None,
        installlongitude=None,
        installlatitude_iso6709=None,
        installlongitude_iso6709=None,
        installtime=None,
        installtime_iso8601=None,
        installlandmark=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.installlatitude = installlatitude
        self.installlatitude_nsprefix_ = None
        self.installlongitude = installlongitude
        self.installlongitude_nsprefix_ = None
        self.installlatitude_iso6709 = installlatitude_iso6709
        self.installlatitude_iso6709_nsprefix_ = None
        self.installlongitude_iso6709 = installlongitude_iso6709
        self.installlongitude_iso6709_nsprefix_ = None
        self.installtime = installtime
        self.installtime_nsprefix_ = None
        self.installtime_iso8601 = installtime_iso8601
        self.installtime_iso8601_nsprefix_ = None
        self.installlandmark = installlandmark
        self.installlandmark_nsprefix_ = None

    def get_installlatitude(self):
        return self.installlatitude

    def set_installlatitude(self, installlatitude):
        self.installlatitude = installlatitude

    def get_installlongitude(self):
        return self.installlongitude

    def set_installlongitude(self, installlongitude):
        self.installlongitude = installlongitude

    def get_installlatitude_iso6709(self):
        return self.installlatitude_iso6709

    def set_installlatitude_iso6709(self, installlatitude_iso6709):
        self.installlatitude_iso6709 = installlatitude_iso6709

    def get_installlongitude_iso6709(self):
        return self.installlongitude_iso6709

    def set_installlongitude_iso6709(self, installlongitude_iso6709):
        self.installlongitude_iso6709 = installlongitude_iso6709

    def get_installtime(self):
        return self.installtime

    def set_installtime(self, installtime):
        self.installtime = installtime

    def get_installtime_iso8601(self):
        return self.installtime_iso8601

    def set_installtime_iso8601(self, installtime_iso8601):
        self.installtime_iso8601 = installtime_iso8601

    def get_installlandmark(self):
        return self.installlandmark

    def set_installlandmark(self, installlandmark):
        self.installlandmark = installlandmark

    def _has_content(self):
        if (
            self.installlatitude is not None
            or self.installlongitude is not None
            or self.installlatitude_iso6709 is not None
            or self.installlongitude_iso6709 is not None
            or self.installtime is not None
            or self.installtime_iso8601 is not None
            or self.installlandmark is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlocation",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installlocation")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installlocation":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="installlocation"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="installlocation",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installlocation",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlocation",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.installlatitude is not None:
            namespace_prefix = (
                self.installlatitude_nsprefix_ + ":"
                if (UseCapturedNS and self.installlatitude_nsprefix_)
                else ""
            )
            self.installlatitude.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installlatitude",
                pretty_print=pretty_print,
            )
        if self.installlongitude is not None:
            namespace_prefix = (
                self.installlongitude_nsprefix_ + ":"
                if (UseCapturedNS and self.installlongitude_nsprefix_)
                else ""
            )
            self.installlongitude.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installlongitude",
                pretty_print=pretty_print,
            )
        if self.installlatitude_iso6709 is not None:
            namespace_prefix = (
                self.installlatitude_iso6709_nsprefix_ + ":"
                if (UseCapturedNS and self.installlatitude_iso6709_nsprefix_)
                else ""
            )
            self.installlatitude_iso6709.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installlatitude-iso6709",
                pretty_print=pretty_print,
            )
        if self.installlongitude_iso6709 is not None:
            namespace_prefix = (
                self.installlongitude_iso6709_nsprefix_ + ":"
                if (UseCapturedNS and self.installlongitude_iso6709_nsprefix_)
                else ""
            )
            self.installlongitude_iso6709.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installlongitude-iso6709",
                pretty_print=pretty_print,
            )
        if self.installtime is not None:
            namespace_prefix = (
                self.installtime_nsprefix_ + ":"
                if (UseCapturedNS and self.installtime_nsprefix_)
                else ""
            )
            self.installtime.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installtime",
                pretty_print=pretty_print,
            )
        if self.installtime_iso8601 is not None:
            namespace_prefix = (
                self.installtime_iso8601_nsprefix_ + ":"
                if (UseCapturedNS and self.installtime_iso8601_nsprefix_)
                else ""
            )
            self.installtime_iso8601.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installtime-iso8601",
                pretty_print=pretty_print,
            )
        if self.installlandmark is not None:
            namespace_prefix = (
                self.installlandmark_nsprefix_ + ":"
                if (UseCapturedNS and self.installlandmark_nsprefix_)
                else ""
            )
            self.installlandmark.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installlandmark",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "installlatitude":
            obj_ = InstallLatitude.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installlatitude = obj_
            obj_.original_tagname_ = "installlatitude"
        elif node_name == "installlongitude":
            obj_ = InstallLongitude.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installlongitude = obj_
            obj_.original_tagname_ = "installlongitude"
        elif node_name == "installlatitude-iso6709":
            obj_ = InstallLatitudeISO6709.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installlatitude_iso6709 = obj_
            obj_.original_tagname_ = "installlatitude-iso6709"
        elif node_name == "installlongitude-iso6709":
            obj_ = InstallLongitudeISO6709.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installlongitude_iso6709 = obj_
            obj_.original_tagname_ = "installlongitude-iso6709"
        elif node_name == "installtime":
            obj_ = InstallTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installtime = obj_
            obj_.original_tagname_ = "installtime"
        elif node_name == "installtime-iso8601":
            obj_ = InstallTimeISO8601.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installtime_iso8601 = obj_
            obj_.original_tagname_ = "installtime-iso8601"
        elif node_name == "installlandmark":
            obj_ = InstallLandMark.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installlandmark = obj_
            obj_.original_tagname_ = "installlandmark"


# end class installlocation


class InstallLatitude(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlatitude",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installlatitude")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installlatitude":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="installlatitude"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installlatitude",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlatitude",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installlatitude


class InstallLongitude(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlongitude",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installlongitude")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installlongitude":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="installlongitude",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installlongitude",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlongitude",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installlongitude


class InstallLatitudeISO6709(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlatitude-iso6709",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installlatitude-iso6709")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installlatitude-iso6709":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="installlatitude-iso6709",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installlatitude-iso6709",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlatitude-iso6709",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installlatitude_iso6709


class InstallLongitudeISO6709(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlongitude-iso6709",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installlongitude-iso6709")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installlongitude-iso6709":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="installlongitude-iso6709",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installlongitude-iso6709",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlongitude-iso6709",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installlongitude_iso6709


class InstallTime(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installtime",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installtime")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installtime":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="installtime"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installtime",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installtime",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installtime


class InstallTimeISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installtime-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installtime-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installtime-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="installtime-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installtime-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installtime-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installtime_iso8601


class InstallLandMark(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        installgeoname=None,
        installlocationid=None,
        installcity=None,
        installstate=None,
        installcountry=None,
        installdistance=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.installgeoname = installgeoname
        self.installgeoname_nsprefix_ = None
        self.installlocationid = installlocationid
        self.installlocationid_nsprefix_ = None
        self.installcity = installcity
        self.installcity_nsprefix_ = None
        self.installstate = installstate
        self.installstate_nsprefix_ = None
        self.installcountry = installcountry
        self.installcountry_nsprefix_ = None
        self.installdistance = installdistance
        self.installdistance_nsprefix_ = None

    def get_installgeoname(self):
        return self.installgeoname

    def set_installgeoname(self, installgeoname):
        self.installgeoname = installgeoname

    def get_installlocationid(self):
        return self.installlocationid

    def set_installlocationid(self, installlocationid):
        self.installlocationid = installlocationid

    def get_installcity(self):
        return self.installcity

    def set_installcity(self, installcity):
        self.installcity = installcity

    def get_installstate(self):
        return self.installstate

    def set_installstate(self, installstate):
        self.installstate = installstate

    def get_installcountry(self):
        return self.installcountry

    def set_installcountry(self, installcountry):
        self.installcountry = installcountry

    def get_installdistance(self):
        return self.installdistance

    def set_installdistance(self, installdistance):
        self.installdistance = installdistance

    def _has_content(self):
        if (
            self.installgeoname is not None
            or self.installlocationid is not None
            or self.installcity is not None
            or self.installstate is not None
            or self.installcountry is not None
            or self.installdistance is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlandmark",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installlandmark")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installlandmark":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="installlandmark"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="installlandmark",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installlandmark",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlandmark",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.installgeoname is not None:
            namespace_prefix = (
                self.installgeoname_nsprefix_ + ":"
                if (UseCapturedNS and self.installgeoname_nsprefix_)
                else ""
            )
            self.installgeoname.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installgeoname",
                pretty_print=pretty_print,
            )
        if self.installlocationid is not None:
            namespace_prefix = (
                self.installlocationid_nsprefix_ + ":"
                if (UseCapturedNS and self.installlocationid_nsprefix_)
                else ""
            )
            self.installlocationid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installlocationid",
                pretty_print=pretty_print,
            )
        if self.installcity is not None:
            namespace_prefix = (
                self.installcity_nsprefix_ + ":"
                if (UseCapturedNS and self.installcity_nsprefix_)
                else ""
            )
            self.installcity.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installcity",
                pretty_print=pretty_print,
            )
        if self.installstate is not None:
            namespace_prefix = (
                self.installstate_nsprefix_ + ":"
                if (UseCapturedNS and self.installstate_nsprefix_)
                else ""
            )
            self.installstate.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installstate",
                pretty_print=pretty_print,
            )
        if self.installcountry is not None:
            namespace_prefix = (
                self.installcountry_nsprefix_ + ":"
                if (UseCapturedNS and self.installcountry_nsprefix_)
                else ""
            )
            self.installcountry.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installcountry",
                pretty_print=pretty_print,
            )
        if self.installdistance is not None:
            namespace_prefix = (
                self.installdistance_nsprefix_ + ":"
                if (UseCapturedNS and self.installdistance_nsprefix_)
                else ""
            )
            self.installdistance.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="installdistance",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "installgeoname":
            obj_ = InstallGeoName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installgeoname = obj_
            obj_.original_tagname_ = "installgeoname"
        elif node_name == "installlocationid":
            obj_ = InstallLocationId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installlocationid = obj_
            obj_.original_tagname_ = "installlocationid"
        elif node_name == "installcity":
            obj_ = InstallCity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installcity = obj_
            obj_.original_tagname_ = "installcity"
        elif node_name == "installstate":
            obj_ = InstallState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installstate = obj_
            obj_.original_tagname_ = "installstate"
        elif node_name == "installcountry":
            obj_ = InstallCountry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installcountry = obj_
            obj_.original_tagname_ = "installcountry"
        elif node_name == "installdistance":
            obj_ = InstallDistance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.installdistance = obj_
            obj_.original_tagname_ = "installdistance"


# end class installlandmark


class InstallGeoName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installgeoname",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installgeoname")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installgeoname":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="installgeoname"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installgeoname",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installgeoname",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installgeoname


class InstallLocationId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlocationid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installlocationid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installlocationid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="installlocationid",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installlocationid",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installlocationid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installlocationid


class InstallCity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installcity",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installcity")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installcity":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="installcity"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installcity",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installcity",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installcity


class InstallState(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installstate",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installstate")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installstate":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="installstate"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installstate",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installstate",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installstate


class InstallCountry(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installcountry",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installcountry")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installcountry":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="installcountry"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installcountry",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installcountry",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installcountry


class InstallDistance(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installdistance",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("installdistance")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "installdistance":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="installdistance"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="installdistance",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="installdistance",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class installdistance


class DepartureLocation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        departurelatitude=None,
        departurelongitude=None,
        departurelatitude_iso6709=None,
        departurelongitude_iso6709=None,
        departuretime=None,
        departuretime_iso8601=None,
        departurelandmark=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.departurelatitude = departurelatitude
        self.departurelatitude_nsprefix_ = None
        self.departurelongitude = departurelongitude
        self.departurelongitude_nsprefix_ = None
        self.departurelatitude_iso6709 = departurelatitude_iso6709
        self.departurelatitude_iso6709_nsprefix_ = None
        self.departurelongitude_iso6709 = departurelongitude_iso6709
        self.departurelongitude_iso6709_nsprefix_ = None
        self.departuretime = departuretime
        self.departuretime_nsprefix_ = None
        self.departuretime_iso8601 = departuretime_iso8601
        self.departuretime_iso8601_nsprefix_ = None
        self.departurelandmark = departurelandmark
        self.departurelandmark_nsprefix_ = None

    def get_departurelatitude(self):
        return self.departurelatitude

    def set_departurelatitude(self, departurelatitude):
        self.departurelatitude = departurelatitude

    def get_departurelongitude(self):
        return self.departurelongitude

    def set_departurelongitude(self, departurelongitude):
        self.departurelongitude = departurelongitude

    def get_departurelatitude_iso6709(self):
        return self.departurelatitude_iso6709

    def set_departurelatitude_iso6709(self, departurelatitude_iso6709):
        self.departurelatitude_iso6709 = departurelatitude_iso6709

    def get_departurelongitude_iso6709(self):
        return self.departurelongitude_iso6709

    def set_departurelongitude_iso6709(self, departurelongitude_iso6709):
        self.departurelongitude_iso6709 = departurelongitude_iso6709

    def get_departuretime(self):
        return self.departuretime

    def set_departuretime(self, departuretime):
        self.departuretime = departuretime

    def get_departuretime_iso8601(self):
        return self.departuretime_iso8601

    def set_departuretime_iso8601(self, departuretime_iso8601):
        self.departuretime_iso8601 = departuretime_iso8601

    def get_departurelandmark(self):
        return self.departurelandmark

    def set_departurelandmark(self, departurelandmark):
        self.departurelandmark = departurelandmark

    def _has_content(self):
        if (
            self.departurelatitude is not None
            or self.departurelongitude is not None
            or self.departurelatitude_iso6709 is not None
            or self.departurelongitude_iso6709 is not None
            or self.departuretime is not None
            or self.departuretime_iso8601 is not None
            or self.departurelandmark is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelocation",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departurelocation")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departurelocation":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="departurelocation",
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="departurelocation",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departurelocation",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelocation",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.departurelatitude is not None:
            namespace_prefix = (
                self.departurelatitude_nsprefix_ + ":"
                if (UseCapturedNS and self.departurelatitude_nsprefix_)
                else ""
            )
            self.departurelatitude.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departurelatitude",
                pretty_print=pretty_print,
            )
        if self.departurelongitude is not None:
            namespace_prefix = (
                self.departurelongitude_nsprefix_ + ":"
                if (UseCapturedNS and self.departurelongitude_nsprefix_)
                else ""
            )
            self.departurelongitude.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departurelongitude",
                pretty_print=pretty_print,
            )
        if self.departurelatitude_iso6709 is not None:
            namespace_prefix = (
                self.departurelatitude_iso6709_nsprefix_ + ":"
                if (UseCapturedNS and self.departurelatitude_iso6709_nsprefix_)
                else ""
            )
            self.departurelatitude_iso6709.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departurelatitude-iso6709",
                pretty_print=pretty_print,
            )
        if self.departurelongitude_iso6709 is not None:
            namespace_prefix = (
                self.departurelongitude_iso6709_nsprefix_ + ":"
                if (UseCapturedNS and self.departurelongitude_iso6709_nsprefix_)
                else ""
            )
            self.departurelongitude_iso6709.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departurelongitude-iso6709",
                pretty_print=pretty_print,
            )
        if self.departuretime is not None:
            namespace_prefix = (
                self.departuretime_nsprefix_ + ":"
                if (UseCapturedNS and self.departuretime_nsprefix_)
                else ""
            )
            self.departuretime.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departuretime",
                pretty_print=pretty_print,
            )
        if self.departuretime_iso8601 is not None:
            namespace_prefix = (
                self.departuretime_iso8601_nsprefix_ + ":"
                if (UseCapturedNS and self.departuretime_iso8601_nsprefix_)
                else ""
            )
            self.departuretime_iso8601.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departuretime-iso8601",
                pretty_print=pretty_print,
            )
        if self.departurelandmark is not None:
            namespace_prefix = (
                self.departurelandmark_nsprefix_ + ":"
                if (UseCapturedNS and self.departurelandmark_nsprefix_)
                else ""
            )
            self.departurelandmark.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departurelandmark",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "departurelatitude":
            obj_ = DepartureLatitude.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departurelatitude = obj_
            obj_.original_tagname_ = "departurelatitude"
        elif node_name == "departurelongitude":
            obj_ = DepartureLongitude.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departurelongitude = obj_
            obj_.original_tagname_ = "departurelongitude"
        elif node_name == "departurelatitude-iso6709":
            obj_ = DepartureLatitudeISO6709.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departurelatitude_iso6709 = obj_
            obj_.original_tagname_ = "departurelatitude-iso6709"
        elif node_name == "departurelongitude-iso6709":
            obj_ = DepartureLongitudeISO6709.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departurelongitude_iso6709 = obj_
            obj_.original_tagname_ = "departurelongitude-iso6709"
        elif node_name == "departuretime":
            obj_ = DepartureTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departuretime = obj_
            obj_.original_tagname_ = "departuretime"
        elif node_name == "departuretime-iso8601":
            obj_ = DepartureTimeISO8601.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departuretime_iso8601 = obj_
            obj_.original_tagname_ = "departuretime-iso8601"
        elif node_name == "departurelandmark":
            obj_ = DepartureLandMark.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departurelandmark = obj_
            obj_.original_tagname_ = "departurelandmark"


# end class departurelocation


class DepartureLatitude(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelatitude",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departurelatitude")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departurelatitude":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="departurelatitude",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departurelatitude",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelatitude",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departurelatitude


class DepartureLongitude(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelongitude",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departurelongitude")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departurelongitude":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="departurelongitude",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departurelongitude",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelongitude",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departurelongitude


class DepartureLatitudeISO6709(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelatitude-iso6709",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departurelatitude-iso6709")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departurelatitude-iso6709":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="departurelatitude-iso6709",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departurelatitude-iso6709",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelatitude-iso6709",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departurelatitude_iso6709


class DepartureLongitudeISO6709(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelongitude-iso6709",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departurelongitude-iso6709")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departurelongitude-iso6709":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="departurelongitude-iso6709",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departurelongitude-iso6709",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelongitude-iso6709",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departurelongitude_iso6709


class DepartureTime(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departuretime",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departuretime")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departuretime":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="departuretime"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departuretime",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departuretime",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departuretime


class DepartureTimeISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departuretime-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departuretime-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departuretime-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="departuretime-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departuretime-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departuretime-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departuretime_iso8601


class DepartureLandMark(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        departuregeoname=None,
        departurelocationid=None,
        departurecity=None,
        departurestate=None,
        departurecountry=None,
        departuredistance=None,
        departurepostal=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.departuregeoname = departuregeoname
        self.departuregeoname_nsprefix_ = None
        self.departurelocationid = departurelocationid
        self.departurelocationid_nsprefix_ = None
        self.departurecity = departurecity
        self.departurecity_nsprefix_ = None
        self.departurestate = departurestate
        self.departurestate_nsprefix_ = None
        self.departurecountry = departurecountry
        self.departurecountry_nsprefix_ = None
        self.departuredistance = departuredistance
        self.departuredistance_nsprefix_ = None
        self.departurepostal = departurepostal
        self.departurepostal_nsprefix_ = None

    def get_departuregeoname(self):
        return self.departuregeoname

    def set_departuregeoname(self, departuregeoname):
        self.departuregeoname = departuregeoname

    def get_departurelocationid(self):
        return self.departurelocationid

    def set_departurelocationid(self, departurelocationid):
        self.departurelocationid = departurelocationid

    def get_departurecity(self):
        return self.departurecity

    def set_departurecity(self, departurecity):
        self.departurecity = departurecity

    def get_departurestate(self):
        return self.departurestate

    def set_departurestate(self, departurestate):
        self.departurestate = departurestate

    def get_departurecountry(self):
        return self.departurecountry

    def set_departurecountry(self, departurecountry):
        self.departurecountry = departurecountry

    def get_departuredistance(self):
        return self.departuredistance

    def set_departuredistance(self, departuredistance):
        self.departuredistance = departuredistance

    def get_departurepostal(self):
        return self.departurepostal

    def set_departurepostal(self, departurepostal):
        self.departurepostal = departurepostal

    def _has_content(self):
        if (
            self.departuregeoname is not None
            or self.departurelocationid is not None
            or self.departurecity is not None
            or self.departurestate is not None
            or self.departurecountry is not None
            or self.departuredistance is not None
            or self.departurepostal is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelandmark",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departurelandmark")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departurelandmark":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="departurelandmark",
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="departurelandmark",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departurelandmark",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelandmark",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.departuregeoname is not None:
            namespace_prefix = (
                self.departuregeoname_nsprefix_ + ":"
                if (UseCapturedNS and self.departuregeoname_nsprefix_)
                else ""
            )
            self.departuregeoname.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departuregeoname",
                pretty_print=pretty_print,
            )
        if self.departurelocationid is not None:
            namespace_prefix = (
                self.departurelocationid_nsprefix_ + ":"
                if (UseCapturedNS and self.departurelocationid_nsprefix_)
                else ""
            )
            self.departurelocationid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departurelocationid",
                pretty_print=pretty_print,
            )
        if self.departurecity is not None:
            namespace_prefix = (
                self.departurecity_nsprefix_ + ":"
                if (UseCapturedNS and self.departurecity_nsprefix_)
                else ""
            )
            self.departurecity.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departurecity",
                pretty_print=pretty_print,
            )
        if self.departurestate is not None:
            namespace_prefix = (
                self.departurestate_nsprefix_ + ":"
                if (UseCapturedNS and self.departurestate_nsprefix_)
                else ""
            )
            self.departurestate.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departurestate",
                pretty_print=pretty_print,
            )
        if self.departurecountry is not None:
            namespace_prefix = (
                self.departurecountry_nsprefix_ + ":"
                if (UseCapturedNS and self.departurecountry_nsprefix_)
                else ""
            )
            self.departurecountry.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departurecountry",
                pretty_print=pretty_print,
            )
        if self.departuredistance is not None:
            namespace_prefix = (
                self.departuredistance_nsprefix_ + ":"
                if (UseCapturedNS and self.departuredistance_nsprefix_)
                else ""
            )
            self.departuredistance.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departuredistance",
                pretty_print=pretty_print,
            )
        if self.departurepostal is not None:
            namespace_prefix = (
                self.departurepostal_nsprefix_ + ":"
                if (UseCapturedNS and self.departurepostal_nsprefix_)
                else ""
            )
            self.departurepostal.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departurepostal",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "departuregeoname":
            obj_ = DepartureGeoName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departuregeoname = obj_
            obj_.original_tagname_ = "departuregeoname"
        elif node_name == "departurelocationid":
            obj_ = DepartureLocationId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departurelocationid = obj_
            obj_.original_tagname_ = "departurelocationid"
        elif node_name == "departurecity":
            obj_ = DepartureCity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departurecity = obj_
            obj_.original_tagname_ = "departurecity"
        elif node_name == "departurestate":
            obj_ = DepartureState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departurestate = obj_
            obj_.original_tagname_ = "departurestate"
        elif node_name == "departurecountry":
            obj_ = DepartureCountry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departurecountry = obj_
            obj_.original_tagname_ = "departurecountry"
        elif node_name == "departuredistance":
            obj_ = DepartureDistance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departuredistance = obj_
            obj_.original_tagname_ = "departuredistance"
        elif node_name == "departurepostal":
            obj_ = DeparturePostal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departurepostal = obj_
            obj_.original_tagname_ = "departurepostal"


# end class departurelandmark


class DepartureGeoName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departuregeoname",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departuregeoname")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departuregeoname":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="departuregeoname",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departuregeoname",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departuregeoname",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departuregeoname


class DepartureLocationId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelocationid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departurelocationid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departurelocationid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="departurelocationid",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departurelocationid",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurelocationid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departurelocationid


class DepartureCity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurecity",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departurecity")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departurecity":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="departurecity"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departurecity",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurecity",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departurecity


class DepartureState(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurestate",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departurestate")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departurestate":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="departurestate"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departurestate",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurestate",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departurestate


class DeparturePostal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurepostal",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departurepostal")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departurepostal":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="departurepostal"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departurepostal",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurepostal",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departurepostal


class DepartureCountry(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurecountry",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departurecountry")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departurecountry":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="departurecountry",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departurecountry",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departurecountry",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departurecountry


class DepartureDistance(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departuredistance",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departuredistance")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departuredistance":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="departuredistance",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departuredistance",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departuredistance",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departuredistance


class TransferDate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="transferdate",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("transferdate")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "transferdate":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="transferdate"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="transferdate",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="transferdate",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class transferdate


class TransferDateISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="transferdate-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("transferdate-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "transferdate-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="transferdate-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="transferdate-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="transferdate-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class transferdate_iso8601


class ShippingAddress(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        street=None,
        city=None,
        state=None,
        country=None,
        postal=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.street = street
        self.street_nsprefix_ = None
        self.city = city
        self.city_nsprefix_ = None
        self.state = state
        self.state_nsprefix_ = None
        self.country = country
        self.country_nsprefix_ = None
        self.postal = postal
        self.postal_nsprefix_ = None

    def get_street(self):
        return self.street

    def set_street(self, street):
        self.street = street

    def get_city(self):
        return self.city

    def set_city(self, city):
        self.city = city

    def get_state(self):
        return self.state

    def set_state(self, state):
        self.state = state

    def get_country(self):
        return self.country

    def set_country(self, country):
        self.country = country

    def get_postal(self):
        return self.postal

    def set_postal(self, postal):
        self.postal = postal

    def _has_content(self):
        if (
            self.street is not None
            or self.city is not None
            or self.state is not None
            or self.country is not None
            or self.postal is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="shippingaddress",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("shippingaddress")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "shippingaddress":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="shippingaddress"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="shippingaddress",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="shippingaddress",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="shippingaddress",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.street is not None:
            namespace_prefix = (
                self.street_nsprefix_ + ":"
                if (UseCapturedNS and self.street_nsprefix_)
                else ""
            )
            self.street.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="street",
                pretty_print=pretty_print,
            )
        if self.city is not None:
            namespace_prefix = (
                self.city_nsprefix_ + ":"
                if (UseCapturedNS and self.city_nsprefix_)
                else ""
            )
            self.city.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="city",
                pretty_print=pretty_print,
            )
        if self.state is not None:
            namespace_prefix = (
                self.state_nsprefix_ + ":"
                if (UseCapturedNS and self.state_nsprefix_)
                else ""
            )
            self.state.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="state",
                pretty_print=pretty_print,
            )
        if self.country is not None:
            namespace_prefix = (
                self.country_nsprefix_ + ":"
                if (UseCapturedNS and self.country_nsprefix_)
                else ""
            )
            self.country.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="country",
                pretty_print=pretty_print,
            )
        if self.postal is not None:
            namespace_prefix = (
                self.postal_nsprefix_ + ":"
                if (UseCapturedNS and self.postal_nsprefix_)
                else ""
            )
            self.postal.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="postal",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "street":
            obj_ = Street.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.street = obj_
            obj_.original_tagname_ = "street"
        elif node_name == "city":
            obj_ = City.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.city = obj_
            obj_.original_tagname_ = "city"
        elif node_name == "state":
            obj_ = State.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.state = obj_
            obj_.original_tagname_ = "state"
        elif node_name == "country":
            obj_ = Country.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = "country"
        elif node_name == "postal":
            obj_ = Postal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.postal = obj_
            obj_.original_tagname_ = "postal"


# end class shippingaddress


class Groups(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, groupname=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if groupname is None:
            self.groupname = []
        else:
            self.groupname = groupname
        self.groupname_nsprefix_ = None

    def get_groupname(self):
        return self.groupname

    def set_groupname(self, groupname):
        self.groupname = groupname

    def add_groupname(self, value):
        self.groupname.append(value)

    def insert_groupname_at(self, index, value):
        self.groupname.insert(index, value)

    def replace_groupname_at(self, index, value):
        self.groupname[index] = value

    def _has_content(self):
        if self.groupname:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="groups",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("groups")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "groups":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="groups"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="groups",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="groups"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="groups",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for groupname_ in self.groupname:
            namespace_prefix = (
                self.groupname_nsprefix_ + ":"
                if (UseCapturedNS and self.groupname_nsprefix_)
                else ""
            )
            groupname_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="groupname",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "groupname":
            obj_ = GroupName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groupname.append(obj_)
            obj_.original_tagname_ = "groupname"


# end class groups


class Container(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        containerid=None,
        scac=None,
        size=None,
        truckingcompany=None,
        associateddttm=None,
        associateddttm_iso8601=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.containerid = containerid
        self.containerid_nsprefix_ = None
        self.scac = scac
        self.scac_nsprefix_ = None
        self.size = size
        self.size_nsprefix_ = None
        self.truckingcompany = truckingcompany
        self.truckingcompany_nsprefix_ = None
        self.associateddttm = associateddttm
        self.associateddttm_nsprefix_ = None
        self.associateddttm_iso8601 = associateddttm_iso8601
        self.associateddttm_iso8601_nsprefix_ = None

    def get_containerid(self):
        return self.containerid

    def set_containerid(self, containerid):
        self.containerid = containerid

    def get_scac(self):
        return self.scac

    def set_scac(self, scac):
        self.scac = scac

    def get_size(self):
        return self.size

    def set_size(self, size):
        self.size = size

    def get_truckingcompany(self):
        return self.truckingcompany

    def set_truckingcompany(self, truckingcompany):
        self.truckingcompany = truckingcompany

    def get_associateddttm(self):
        return self.associateddttm

    def set_associateddttm(self, associateddttm):
        self.associateddttm = associateddttm

    def get_associateddttm_iso8601(self):
        return self.associateddttm_iso8601

    def set_associateddttm_iso8601(self, associateddttm_iso8601):
        self.associateddttm_iso8601 = associateddttm_iso8601

    def _has_content(self):
        if (
            self.containerid is not None
            or self.scac is not None
            or self.size is not None
            or self.truckingcompany is not None
            or self.associateddttm is not None
            or self.associateddttm_iso8601 is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="container",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("container")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "container":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="container"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="container",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="container"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="container",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.containerid is not None:
            namespace_prefix = (
                self.containerid_nsprefix_ + ":"
                if (UseCapturedNS and self.containerid_nsprefix_)
                else ""
            )
            self.containerid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="containerid",
                pretty_print=pretty_print,
            )
        if self.scac is not None:
            namespace_prefix = (
                self.scac_nsprefix_ + ":"
                if (UseCapturedNS and self.scac_nsprefix_)
                else ""
            )
            self.scac.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="scac",
                pretty_print=pretty_print,
            )
        if self.size is not None:
            namespace_prefix = (
                self.size_nsprefix_ + ":"
                if (UseCapturedNS and self.size_nsprefix_)
                else ""
            )
            self.size.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="size",
                pretty_print=pretty_print,
            )
        if self.truckingcompany is not None:
            namespace_prefix = (
                self.truckingcompany_nsprefix_ + ":"
                if (UseCapturedNS and self.truckingcompany_nsprefix_)
                else ""
            )
            self.truckingcompany.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="truckingcompany",
                pretty_print=pretty_print,
            )
        if self.associateddttm is not None:
            namespace_prefix = (
                self.associateddttm_nsprefix_ + ":"
                if (UseCapturedNS and self.associateddttm_nsprefix_)
                else ""
            )
            self.associateddttm.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="associateddttm",
                pretty_print=pretty_print,
            )
        if self.associateddttm_iso8601 is not None:
            namespace_prefix = (
                self.associateddttm_iso8601_nsprefix_ + ":"
                if (UseCapturedNS and self.associateddttm_iso8601_nsprefix_)
                else ""
            )
            self.associateddttm_iso8601.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="associateddttm-iso8601",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "containerid":
            obj_ = ContainerId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.containerid = obj_
            obj_.original_tagname_ = "containerid"
        elif node_name == "scac":
            obj_ = SCac.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scac = obj_
            obj_.original_tagname_ = "scac"
        elif node_name == "size":
            obj_ = Size.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.size = obj_
            obj_.original_tagname_ = "size"
        elif node_name == "truckingcompany":
            obj_ = TruckingCompany.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.truckingcompany = obj_
            obj_.original_tagname_ = "truckingcompany"
        elif node_name == "associateddttm":
            obj_ = AssociatedDTTM.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.associateddttm = obj_
            obj_.original_tagname_ = "associateddttm"
        elif node_name == "associateddttm-iso8601":
            obj_ = AssociatedDTTMISO8601.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.associateddttm_iso8601 = obj_
            obj_.original_tagname_ = "associateddttm-iso8601"


# end class container


class ContainerId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="containerid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("containerid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "containerid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="containerid"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="containerid",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="containerid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class containerid


class SCac(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="scac",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("scac")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "scac":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="scac"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="scac"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="scac",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class scac


class Size(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="size",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("size")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "size":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="size"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="size"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="size",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class size


class TruckingCompany(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="truckingcompany",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("truckingcompany")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "truckingcompany":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="truckingcompany"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="truckingcompany",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="truckingcompany",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class truckingcompany


class AssociatedDTTM(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="associateddttm",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("associateddttm")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "associateddttm":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="associateddttm"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="associateddttm",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="associateddttm",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class associateddttm


class AssociatedDTTMISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="associateddttm-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("associateddttm-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "associateddttm-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="associateddttm-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="associateddttm-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="associateddttm-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class associateddttm_iso8601


class GroupName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="groupname",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("groupname")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "groupname":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="groupname"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="groupname"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="groupname",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class groupname


class MessageType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="messagetype",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("messagetype")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "messagetype":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="messagetype"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="messagetype",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="messagetype",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class messagetype


class Binary(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        inputname=None,
        inputid=None,
        event=None,
        inputval=None,
        inputstate=None,
        timeofreading=None,
        timeofreading_iso8601=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.inputname = inputname
        self.inputname_nsprefix_ = None
        self.inputid = inputid
        self.inputid_nsprefix_ = None
        self.event = event
        self.event_nsprefix_ = None
        self.inputval = inputval
        self.inputval_nsprefix_ = None
        self.inputstate = inputstate
        self.inputstate_nsprefix_ = None
        self.timeofreading = timeofreading
        self.timeofreading_nsprefix_ = None
        self.timeofreading_iso8601 = timeofreading_iso8601
        self.timeofreading_iso8601_nsprefix_ = None

    def get_inputname(self):
        return self.inputname

    def set_inputname(self, inputname):
        self.inputname = inputname

    def get_inputid(self):
        return self.inputid

    def set_inputid(self, inputid):
        self.inputid = inputid

    def get_event(self):
        return self.event

    def set_event(self, event):
        self.event = event

    def get_inputval(self):
        return self.inputval

    def set_inputval(self, inputval):
        self.inputval = inputval

    def get_inputstate(self):
        return self.inputstate

    def set_inputstate(self, inputstate):
        self.inputstate = inputstate

    def get_timeofreading(self):
        return self.timeofreading

    def set_timeofreading(self, timeofreading):
        self.timeofreading = timeofreading

    def get_timeofreading_iso8601(self):
        return self.timeofreading_iso8601

    def set_timeofreading_iso8601(self, timeofreading_iso8601):
        self.timeofreading_iso8601 = timeofreading_iso8601

    def _has_content(self):
        if (
            self.inputname is not None
            or self.inputid is not None
            or self.event is not None
            or self.inputval is not None
            or self.inputstate is not None
            or self.timeofreading is not None
            or self.timeofreading_iso8601 is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="binary",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("binary")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "binary":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="binary"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="binary",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="binary"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="binary",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.inputname is not None:
            namespace_prefix = (
                self.inputname_nsprefix_ + ":"
                if (UseCapturedNS and self.inputname_nsprefix_)
                else ""
            )
            self.inputname.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="inputname",
                pretty_print=pretty_print,
            )
        if self.inputid is not None:
            namespace_prefix = (
                self.inputid_nsprefix_ + ":"
                if (UseCapturedNS and self.inputid_nsprefix_)
                else ""
            )
            self.inputid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="inputid",
                pretty_print=pretty_print,
            )
        if self.event is not None:
            namespace_prefix = (
                self.event_nsprefix_ + ":"
                if (UseCapturedNS and self.event_nsprefix_)
                else ""
            )
            self.event.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="event",
                pretty_print=pretty_print,
            )
        if self.inputval is not None:
            namespace_prefix = (
                self.inputval_nsprefix_ + ":"
                if (UseCapturedNS and self.inputval_nsprefix_)
                else ""
            )
            self.inputval.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="inputval",
                pretty_print=pretty_print,
            )
        if self.inputstate is not None:
            namespace_prefix = (
                self.inputstate_nsprefix_ + ":"
                if (UseCapturedNS and self.inputstate_nsprefix_)
                else ""
            )
            self.inputstate.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="inputstate",
                pretty_print=pretty_print,
            )
        if self.timeofreading is not None:
            namespace_prefix = (
                self.timeofreading_nsprefix_ + ":"
                if (UseCapturedNS and self.timeofreading_nsprefix_)
                else ""
            )
            self.timeofreading.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="timeofreading",
                pretty_print=pretty_print,
            )
        if self.timeofreading_iso8601 is not None:
            namespace_prefix = (
                self.timeofreading_iso8601_nsprefix_ + ":"
                if (UseCapturedNS and self.timeofreading_iso8601_nsprefix_)
                else ""
            )
            self.timeofreading_iso8601.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="timeofreading-iso8601",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "inputname":
            obj_ = InputName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inputname = obj_
            obj_.original_tagname_ = "inputname"
        elif node_name == "inputid":
            obj_ = InputId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inputid = obj_
            obj_.original_tagname_ = "inputid"
        elif node_name == "event":
            obj_ = Event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event = obj_
            obj_.original_tagname_ = "event"
        elif node_name == "inputval":
            obj_ = InputVal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inputval = obj_
            obj_.original_tagname_ = "inputval"
        elif node_name == "inputstate":
            obj_ = InputState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inputstate = obj_
            obj_.original_tagname_ = "inputstate"
        elif node_name == "timeofreading":
            obj_ = TimeOfReading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeofreading = obj_
            obj_.original_tagname_ = "timeofreading"
        elif node_name == "timeofreading-iso8601":
            obj_ = TimeOfReadingISO8601.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeofreading_iso8601 = obj_
            obj_.original_tagname_ = "timeofreading-iso8601"


# end class binary


class InputId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="inputid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("inputid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "inputid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="inputid"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="inputid"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="inputid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class inputid


class InputName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="inputname",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("inputname")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "inputname":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="inputname"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="inputname"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="inputname",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class inputname


class InputVal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="inputval",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("inputval")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "inputval":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="inputval"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="inputval"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="inputval",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class inputval


class InputState(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="inputstate",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("inputstate")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "inputstate":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="inputstate"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="inputstate"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="inputstate",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class inputstate


class TimeOfReading(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="timeofreading",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("timeofreading")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "timeofreading":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="timeofreading"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="timeofreading",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="timeofreading",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class timeofreading


class TimeOfReadingISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="timeofreading-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("timeofreading-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "timeofreading-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="timeofreading-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="timeofreading-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="timeofreading-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class timeofreading_iso8601


class Event(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="event",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("event")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "event":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="event"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="event"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="event",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class event


class ExtPwr(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="extpwr",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("extpwr")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "extpwr":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="extpwr"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="extpwr"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="extpwr",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class extpwr


class Serial(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        serialtype=None,
        serialid=None,
        serialname=None,
        serialdata=None,
        timeofreading=None,
        timeofreading_iso8601=None,
        event=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.serialtype = serialtype
        self.serialtype_nsprefix_ = None
        self.serialid = serialid
        self.serialid_nsprefix_ = None
        self.serialname = serialname
        self.serialname_nsprefix_ = None
        self.serialdata = serialdata
        self.serialdata_nsprefix_ = None
        self.timeofreading = timeofreading
        self.timeofreading_nsprefix_ = None
        self.timeofreading_iso8601 = timeofreading_iso8601
        self.timeofreading_iso8601_nsprefix_ = None
        self.event = event
        self.event_nsprefix_ = None

    def get_serialtype(self):
        return self.serialtype

    def set_serialtype(self, serialtype):
        self.serialtype = serialtype

    def get_serialid(self):
        return self.serialid

    def set_serialid(self, serialid):
        self.serialid = serialid

    def get_serialname(self):
        return self.serialname

    def set_serialname(self, serialname):
        self.serialname = serialname

    def get_serialdata(self):
        return self.serialdata

    def set_serialdata(self, serialdata):
        self.serialdata = serialdata

    def get_timeofreading(self):
        return self.timeofreading

    def set_timeofreading(self, timeofreading):
        self.timeofreading = timeofreading

    def get_timeofreading_iso8601(self):
        return self.timeofreading_iso8601

    def set_timeofreading_iso8601(self, timeofreading_iso8601):
        self.timeofreading_iso8601 = timeofreading_iso8601

    def get_event(self):
        return self.event

    def set_event(self, event):
        self.event = event

    def _has_content(self):
        if (
            self.serialtype is not None
            or self.serialid is not None
            or self.serialname is not None
            or self.serialdata is not None
            or self.timeofreading is not None
            or self.timeofreading_iso8601 is not None
            or self.event is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="serial",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("serial")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "serial":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="serial"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="serial",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="serial"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="serial",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.serialtype is not None:
            namespace_prefix = (
                self.serialtype_nsprefix_ + ":"
                if (UseCapturedNS and self.serialtype_nsprefix_)
                else ""
            )
            self.serialtype.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="serialtype",
                pretty_print=pretty_print,
            )
        if self.serialid is not None:
            namespace_prefix = (
                self.serialid_nsprefix_ + ":"
                if (UseCapturedNS and self.serialid_nsprefix_)
                else ""
            )
            self.serialid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="serialid",
                pretty_print=pretty_print,
            )
        if self.serialname is not None:
            namespace_prefix = (
                self.serialname_nsprefix_ + ":"
                if (UseCapturedNS and self.serialname_nsprefix_)
                else ""
            )
            self.serialname.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="serialname",
                pretty_print=pretty_print,
            )
        if self.serialdata is not None:
            namespace_prefix = (
                self.serialdata_nsprefix_ + ":"
                if (UseCapturedNS and self.serialdata_nsprefix_)
                else ""
            )
            self.serialdata.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="serialdata",
                pretty_print=pretty_print,
            )
        if self.timeofreading is not None:
            namespace_prefix = (
                self.timeofreading_nsprefix_ + ":"
                if (UseCapturedNS and self.timeofreading_nsprefix_)
                else ""
            )
            self.timeofreading.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="timeofreading",
                pretty_print=pretty_print,
            )
        if self.timeofreading_iso8601 is not None:
            namespace_prefix = (
                self.timeofreading_iso8601_nsprefix_ + ":"
                if (UseCapturedNS and self.timeofreading_iso8601_nsprefix_)
                else ""
            )
            self.timeofreading_iso8601.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="timeofreading-iso8601",
                pretty_print=pretty_print,
            )
        if self.event is not None:
            namespace_prefix = (
                self.event_nsprefix_ + ":"
                if (UseCapturedNS and self.event_nsprefix_)
                else ""
            )
            self.event.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="event",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "serialtype":
            obj_ = SerialType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serialtype = obj_
            obj_.original_tagname_ = "serialtype"
        elif node_name == "serialid":
            obj_ = SerialId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serialid = obj_
            obj_.original_tagname_ = "serialid"
        elif node_name == "serialname":
            obj_ = SerialName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serialname = obj_
            obj_.original_tagname_ = "serialname"
        elif node_name == "serialdata":
            obj_ = SerialData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serialdata = obj_
            obj_.original_tagname_ = "serialdata"
        elif node_name == "timeofreading":
            obj_ = TimeOfReading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeofreading = obj_
            obj_.original_tagname_ = "timeofreading"
        elif node_name == "timeofreading-iso8601":
            obj_ = TimeOfReadingISO8601.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeofreading_iso8601 = obj_
            obj_.original_tagname_ = "timeofreading-iso8601"
        elif node_name == "event":
            obj_ = Event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event = obj_
            obj_.original_tagname_ = "event"


# end class serial


class SerialType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="serialtype",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("serialtype")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "serialtype":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="serialtype"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="serialtype"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="serialtype",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class serialtype


class SerialId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="serialid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("serialid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "serialid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="serialid"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="serialid"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="serialid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class serialid


class SerialName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="serialname",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("serialname")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "serialname":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="serialname"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="serialname"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="serialname",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class serialname


class SerialData(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="serialdata",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("serialdata")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "serialdata":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="serialdata"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="serialdata"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="serialdata",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class serialdata


class Latitude(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="latitude",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("latitude")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "latitude":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="latitude"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="latitude"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="latitude",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class latitude


class LatitudeISO6709(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="latitude-iso6709",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("latitude-iso6709")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "latitude-iso6709":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="latitude-iso6709",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="latitude-iso6709",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="latitude-iso6709",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class latitude_iso6709


class Longitude(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="longitude",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("longitude")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "longitude":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="longitude"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="longitude"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="longitude",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class longitude


class LongitudeISO6709(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="longitude-iso6709",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("longitude-iso6709")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "longitude-iso6709":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="longitude-iso6709",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="longitude-iso6709",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="longitude-iso6709",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class longitude_iso6709


class Speed(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="speed",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("speed")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "speed":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="speed"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="speed"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="speed",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class speed


class Heading(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="heading",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("heading")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "heading":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="heading"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="heading"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="heading",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class heading


class HeadingInDegrees(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="headingindegrees",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("headingindegrees")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "headingindegrees":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="headingindegrees",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="headingindegrees",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="headingindegrees",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class headingindegrees


class JourneyDistance(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="journeydistance",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("journeydistance")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "journeydistance":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="journeydistance"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="journeydistance",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="journeydistance",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class journeydistance


class TotalDeviceMileage(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="totaldevicemileage",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("totaldevicemileage")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "totaldevicemileage":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="totaldevicemileage",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="totaldevicemileage",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="totaldevicemileage",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class totaldevicemileage


class TemperatureCelsius(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="temperaturecelsius",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("temperaturecelsius")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "temperaturecelsius":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="temperaturecelsius",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="temperaturecelsius",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="temperaturecelsius",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class temperaturecelsius


class TemperatureFahrenheit(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="temperaturefahrenheit",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("temperaturefahrenheit")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "temperaturefahrenheit":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="temperaturefahrenheit",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="temperaturefahrenheit",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="temperaturefahrenheit",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class temperaturefahrenheit


class Battery(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="battery",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("battery")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "battery":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="battery"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="battery"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="battery",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class battery


class Time(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="time",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("time")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "time":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="time"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="time"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="time",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class time


class TimeISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="time-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("time-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "time-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="time-iso8601"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="time-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="time-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class time_iso8601


class Quality(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="quality",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("quality")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "quality":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="quality"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="quality"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="quality",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class quality


class LandMark(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        geoname=None,
        locationid=None,
        city=None,
        state=None,
        country=None,
        postal=None,
        distance=None,
        direction=None,
        geotypename=None,
        geoshape=None,
        locationids=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.geoname = geoname
        self.geoname_nsprefix_ = None
        self.locationid = locationid
        self.locationid_nsprefix_ = None
        self.city = city
        self.city_nsprefix_ = None
        self.state = state
        self.state_nsprefix_ = None
        self.country = country
        self.country_nsprefix_ = None
        self.postal = postal
        self.postal_nsprefix_ = None
        self.distance = distance
        self.distance_nsprefix_ = None
        self.direction = direction
        self.direction_nsprefix_ = None
        self.geotypename = geotypename
        self.geotypename_nsprefix_ = None
        self.geoshape = geoshape
        self.geoshape_nsprefix_ = None
        self.locationids = locationids
        self.locationids_nsprefix_ = None

    def get_geoname(self):
        return self.geoname

    def set_geoname(self, geoname):
        self.geoname = geoname

    def get_locationid(self):
        return self.locationid

    def set_locationid(self, locationid):
        self.locationid = locationid

    def get_city(self):
        return self.city

    def set_city(self, city):
        self.city = city

    def get_state(self):
        return self.state

    def set_state(self, state):
        self.state = state

    def get_country(self):
        return self.country

    def set_country(self, country):
        self.country = country

    def get_postal(self):
        return self.postal

    def set_postal(self, postal):
        self.postal = postal

    def get_distance(self):
        return self.distance

    def set_distance(self, distance):
        self.distance = distance

    def get_direction(self):
        return self.direction

    def set_direction(self, direction):
        self.direction = direction

    def get_geotypename(self):
        return self.geotypename

    def set_geotypename(self, geotypename):
        self.geotypename = geotypename

    def get_geoshape(self):
        return self.geoshape

    def set_geoshape(self, geoshape):
        self.geoshape = geoshape

    def get_locationids(self):
        return self.locationids

    def set_locationids(self, locationids):
        self.locationids = locationids

    def _has_content(self):
        if (
            self.geoname is not None
            or self.locationid is not None
            or self.city is not None
            or self.state is not None
            or self.country is not None
            or self.postal is not None
            or self.distance is not None
            or self.direction is not None
            or self.geotypename is not None
            or self.geoshape is not None
            or self.locationids is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="landmark",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("landmark")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "landmark":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="landmark"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="landmark",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="landmark"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="landmark",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.geoname is not None:
            namespace_prefix = (
                self.geoname_nsprefix_ + ":"
                if (UseCapturedNS and self.geoname_nsprefix_)
                else ""
            )
            self.geoname.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="geoname",
                pretty_print=pretty_print,
            )
        if self.locationid is not None:
            namespace_prefix = (
                self.locationid_nsprefix_ + ":"
                if (UseCapturedNS and self.locationid_nsprefix_)
                else ""
            )
            self.locationid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="locationid",
                pretty_print=pretty_print,
            )
        if self.city is not None:
            namespace_prefix = (
                self.city_nsprefix_ + ":"
                if (UseCapturedNS and self.city_nsprefix_)
                else ""
            )
            self.city.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="city",
                pretty_print=pretty_print,
            )
        if self.state is not None:
            namespace_prefix = (
                self.state_nsprefix_ + ":"
                if (UseCapturedNS and self.state_nsprefix_)
                else ""
            )
            self.state.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="state",
                pretty_print=pretty_print,
            )
        if self.country is not None:
            namespace_prefix = (
                self.country_nsprefix_ + ":"
                if (UseCapturedNS and self.country_nsprefix_)
                else ""
            )
            self.country.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="country",
                pretty_print=pretty_print,
            )
        if self.postal is not None:
            namespace_prefix = (
                self.postal_nsprefix_ + ":"
                if (UseCapturedNS and self.postal_nsprefix_)
                else ""
            )
            self.postal.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="postal",
                pretty_print=pretty_print,
            )
        if self.distance is not None:
            namespace_prefix = (
                self.distance_nsprefix_ + ":"
                if (UseCapturedNS and self.distance_nsprefix_)
                else ""
            )
            self.distance.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="distance",
                pretty_print=pretty_print,
            )
        if self.direction is not None:
            namespace_prefix = (
                self.direction_nsprefix_ + ":"
                if (UseCapturedNS and self.direction_nsprefix_)
                else ""
            )
            self.direction.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="direction",
                pretty_print=pretty_print,
            )
        if self.geotypename is not None:
            namespace_prefix = (
                self.geotypename_nsprefix_ + ":"
                if (UseCapturedNS and self.geotypename_nsprefix_)
                else ""
            )
            self.geotypename.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="geotypename",
                pretty_print=pretty_print,
            )
        if self.geoshape is not None:
            namespace_prefix = (
                self.geoshape_nsprefix_ + ":"
                if (UseCapturedNS and self.geoshape_nsprefix_)
                else ""
            )
            self.geoshape.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="geoshape",
                pretty_print=pretty_print,
            )
        if self.locationids is not None:
            namespace_prefix = (
                self.locationids_nsprefix_ + ":"
                if (UseCapturedNS and self.locationids_nsprefix_)
                else ""
            )
            self.locationids.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="locationids",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "geoname":
            obj_ = GeoName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geoname = obj_
            obj_.original_tagname_ = "geoname"
        elif node_name == "locationid":
            obj_ = LocationId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.locationid = obj_
            obj_.original_tagname_ = "locationid"
        elif node_name == "city":
            obj_ = City.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.city = obj_
            obj_.original_tagname_ = "city"
        elif node_name == "state":
            obj_ = State.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.state = obj_
            obj_.original_tagname_ = "state"
        elif node_name == "country":
            obj_ = Country.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = "country"
        elif node_name == "postal":
            obj_ = Postal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.postal = obj_
            obj_.original_tagname_ = "postal"
        elif node_name == "distance":
            obj_ = Distance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distance = obj_
            obj_.original_tagname_ = "distance"
        elif node_name == "direction":
            obj_ = Direction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.direction = obj_
            obj_.original_tagname_ = "direction"
        elif node_name == "geotypename":
            obj_ = GeoTypeName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geotypename = obj_
            obj_.original_tagname_ = "geotypename"
        elif node_name == "geoshape":
            obj_ = GeoShape.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geoshape = obj_
            obj_.original_tagname_ = "geoshape"
        elif node_name == "locationids":
            obj_ = LocationIds.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.locationids = obj_
            obj_.original_tagname_ = "locationids"


# end class landmark


class GeoName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="geoname",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("geoname")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "geoname":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="geoname"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="geoname"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="geoname",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class geoname


class LocationId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="locationid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("locationid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "locationid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="locationid"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="locationid"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="locationid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class locationid


class City(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="city",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("city")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "city":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="city"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="city"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="city",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class city


class GeoTypeName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="geotypename",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("geotypename")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "geotypename":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="geotypename"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="geotypename",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="geotypename",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class geotypename


class State(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="state",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("state")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "state":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="state"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="state"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="state",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class state


class Country(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="country",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("country")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "country":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="country"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="country"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="country",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class country


class Distance(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="distance",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("distance")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "distance":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="distance"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="distance"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="distance",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class distance


class Direction(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="direction",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("direction")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "direction":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="direction"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="direction"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="direction",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class direction


class Address(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        street=None,
        city=None,
        state=None,
        country=None,
        postal=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.street = street
        self.street_nsprefix_ = None
        self.city = city
        self.city_nsprefix_ = None
        self.state = state
        self.state_nsprefix_ = None
        self.country = country
        self.country_nsprefix_ = None
        self.postal = postal
        self.postal_nsprefix_ = None

    def get_street(self):
        return self.street

    def set_street(self, street):
        self.street = street

    def get_city(self):
        return self.city

    def set_city(self, city):
        self.city = city

    def get_state(self):
        return self.state

    def set_state(self, state):
        self.state = state

    def get_country(self):
        return self.country

    def set_country(self, country):
        self.country = country

    def get_postal(self):
        return self.postal

    def set_postal(self, postal):
        self.postal = postal

    def _has_content(self):
        if (
            self.street is not None
            or self.city is not None
            or self.state is not None
            or self.country is not None
            or self.postal is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="address",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("address")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "address":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="address"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="address",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="address"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="address",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.street is not None:
            namespace_prefix = (
                self.street_nsprefix_ + ":"
                if (UseCapturedNS and self.street_nsprefix_)
                else ""
            )
            self.street.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="street",
                pretty_print=pretty_print,
            )
        if self.city is not None:
            namespace_prefix = (
                self.city_nsprefix_ + ":"
                if (UseCapturedNS and self.city_nsprefix_)
                else ""
            )
            self.city.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="city",
                pretty_print=pretty_print,
            )
        if self.state is not None:
            namespace_prefix = (
                self.state_nsprefix_ + ":"
                if (UseCapturedNS and self.state_nsprefix_)
                else ""
            )
            self.state.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="state",
                pretty_print=pretty_print,
            )
        if self.country is not None:
            namespace_prefix = (
                self.country_nsprefix_ + ":"
                if (UseCapturedNS and self.country_nsprefix_)
                else ""
            )
            self.country.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="country",
                pretty_print=pretty_print,
            )
        if self.postal is not None:
            namespace_prefix = (
                self.postal_nsprefix_ + ":"
                if (UseCapturedNS and self.postal_nsprefix_)
                else ""
            )
            self.postal.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="postal",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "street":
            obj_ = Street.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.street = obj_
            obj_.original_tagname_ = "street"
        elif node_name == "city":
            obj_ = City.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.city = obj_
            obj_.original_tagname_ = "city"
        elif node_name == "state":
            obj_ = State.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.state = obj_
            obj_.original_tagname_ = "state"
        elif node_name == "country":
            obj_ = Country.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = "country"
        elif node_name == "postal":
            obj_ = Postal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.postal = obj_
            obj_.original_tagname_ = "postal"


# end class address


class Street(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="street",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("street")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "street":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="street"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="street"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="street",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class street


class Postal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="postal",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("postal")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "postal":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="postal"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="postal"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="postal",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class postal


class GeoShape(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="geoshape",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("geoshape")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "geoshape":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="geoshape"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="geoshape"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="geoshape",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class geoshape


class LocationIds(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, locationid=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if locationid is None:
            self.locationid = []
        else:
            self.locationid = locationid
        self.locationid_nsprefix_ = None

    def get_locationid(self):
        return self.locationid

    def set_locationid(self, locationid):
        self.locationid = locationid

    def add_locationid(self, value):
        self.locationid.append(value)

    def insert_locationid_at(self, index, value):
        self.locationid.insert(index, value)

    def replace_locationid_at(self, index, value):
        self.locationid[index] = value

    def _has_content(self):
        if self.locationid:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="locationids",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("locationids")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "locationids":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="locationids"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="locationids",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="locationids",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="locationids",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for locationid_ in self.locationid:
            namespace_prefix = (
                self.locationid_nsprefix_ + ":"
                if (UseCapturedNS and self.locationid_nsprefix_)
                else ""
            )
            locationid_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="locationid",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "locationid":
            obj_ = LocationId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.locationid.append(obj_)
            obj_.original_tagname_ = "locationid"


# end class locationids


class Idle(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        idlestatus=None,
        idleduration=None,
        idlegap=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.idlestatus = idlestatus
        self.idlestatus_nsprefix_ = None
        self.idleduration = idleduration
        self.idleduration_nsprefix_ = None
        self.idlegap = idlegap
        self.idlegap_nsprefix_ = None

    def get_idlestatus(self):
        return self.idlestatus

    def set_idlestatus(self, idlestatus):
        self.idlestatus = idlestatus

    def get_idleduration(self):
        return self.idleduration

    def set_idleduration(self, idleduration):
        self.idleduration = idleduration

    def get_idlegap(self):
        return self.idlegap

    def set_idlegap(self, idlegap):
        self.idlegap = idlegap

    def _has_content(self):
        if (
            self.idlestatus is not None
            or self.idleduration is not None
            or self.idlegap is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="idle",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("idle")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "idle":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="idle"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="idle",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="idle"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="idle",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.idlestatus is not None:
            namespace_prefix = (
                self.idlestatus_nsprefix_ + ":"
                if (UseCapturedNS and self.idlestatus_nsprefix_)
                else ""
            )
            self.idlestatus.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="idlestatus",
                pretty_print=pretty_print,
            )
        if self.idleduration is not None:
            namespace_prefix = (
                self.idleduration_nsprefix_ + ":"
                if (UseCapturedNS and self.idleduration_nsprefix_)
                else ""
            )
            self.idleduration.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="idleduration",
                pretty_print=pretty_print,
            )
        if self.idlegap is not None:
            namespace_prefix = (
                self.idlegap_nsprefix_ + ":"
                if (UseCapturedNS and self.idlegap_nsprefix_)
                else ""
            )
            self.idlegap.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="idlegap",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "idlestatus":
            obj_ = IdleStatus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.idlestatus = obj_
            obj_.original_tagname_ = "idlestatus"
        elif node_name == "idleduration":
            obj_ = IdleDuration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.idleduration = obj_
            obj_.original_tagname_ = "idleduration"
        elif node_name == "idlegap":
            obj_ = IdleGap.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.idlegap = obj_
            obj_.original_tagname_ = "idlegap"


# end class idle


class IdleStatus(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="idlestatus",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("idlestatus")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "idlestatus":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="idlestatus"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="idlestatus"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="idlestatus",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class idlestatus


class IdleDuration(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="idleduration",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("idleduration")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "idleduration":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="idleduration"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="idleduration",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="idleduration",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class idleduration


class IdleGap(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="idlegap",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("idlegap")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "idlegap":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="idlegap"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="idlegap"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="idlegap",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class idlegap


class EPMFlag(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="epmflag",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("epmflag")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "epmflag":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="epmflag"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="epmflag"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="epmflag",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class epmflag


class EHMeter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="ehmeter",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("ehmeter")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ehmeter":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="ehmeter"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="ehmeter"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="ehmeter",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class ehmeter


class EHCounter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="ehcounter",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("ehcounter")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ehcounter":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="ehcounter"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="ehcounter"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="ehcounter",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class ehcounter


class ATS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        lsd=None,
        meridian=None,
        township=None,
        range_=None,
        section=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.lsd = lsd
        self.lsd_nsprefix_ = None
        self.meridian = meridian
        self.meridian_nsprefix_ = None
        self.township = township
        self.township_nsprefix_ = None
        self.range_ = range_
        self.range__nsprefix_ = None
        self.section = section
        self.section_nsprefix_ = None

    def get_lsd(self):
        return self.lsd

    def set_lsd(self, lsd):
        self.lsd = lsd

    def get_meridian(self):
        return self.meridian

    def set_meridian(self, meridian):
        self.meridian = meridian

    def get_township(self):
        return self.township

    def set_township(self, township):
        self.township = township

    def get_range(self):
        return self.range_

    def set_range(self, range_):
        self.range_ = range_

    def get_section(self):
        return self.section

    def set_section(self, section):
        self.section = section

    def _has_content(self):
        if (
            self.lsd is not None
            or self.meridian is not None
            or self.township is not None
            or self.range_ is not None
            or self.section is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="ats",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("ats")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ats":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="ats"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="ats",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="ats"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="ats",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.lsd is not None:
            namespace_prefix = (
                self.lsd_nsprefix_ + ":"
                if (UseCapturedNS and self.lsd_nsprefix_)
                else ""
            )
            self.lsd.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="lsd",
                pretty_print=pretty_print,
            )
        if self.meridian is not None:
            namespace_prefix = (
                self.meridian_nsprefix_ + ":"
                if (UseCapturedNS and self.meridian_nsprefix_)
                else ""
            )
            self.meridian.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="meridian",
                pretty_print=pretty_print,
            )
        if self.township is not None:
            namespace_prefix = (
                self.township_nsprefix_ + ":"
                if (UseCapturedNS and self.township_nsprefix_)
                else ""
            )
            self.township.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="township",
                pretty_print=pretty_print,
            )
        if self.range_ is not None:
            namespace_prefix = (
                self.range__nsprefix_ + ":"
                if (UseCapturedNS and self.range__nsprefix_)
                else ""
            )
            self.range_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="range",
                pretty_print=pretty_print,
            )
        if self.section is not None:
            namespace_prefix = (
                self.section_nsprefix_ + ":"
                if (UseCapturedNS and self.section_nsprefix_)
                else ""
            )
            self.section.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="section",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "lsd":
            obj_ = LSD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lsd = obj_
            obj_.original_tagname_ = "lsd"
        elif node_name == "meridian":
            obj_ = Meridian.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.meridian = obj_
            obj_.original_tagname_ = "meridian"
        elif node_name == "township":
            obj_ = Township.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.township = obj_
            obj_.original_tagname_ = "township"
        elif node_name == "range":
            obj_ = Range.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.range_ = obj_
            obj_.original_tagname_ = "range"
        elif node_name == "section":
            obj_ = Section.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.section = obj_
            obj_.original_tagname_ = "section"


# end class ats


class LSD(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lsd",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("lsd")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "lsd":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="lsd"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="lsd"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lsd",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class lsd


class Meridian(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="meridian",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("meridian")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "meridian":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="meridian"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="meridian"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="meridian",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class meridian


class Township(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="township",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("township")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "township":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="township"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="township"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="township",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class township


class Range(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="range",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("range")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "range":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="range"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="range"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="range",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class range_


class Section(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="section",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("section")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "section":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="section"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="section"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="section",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class section

# end class lastupdate


class LastUpdateISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lastupdate-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("lastupdate-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "lastupdate-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="lastupdate-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="lastupdate-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="lastupdate-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class lastupdate_iso8601


class ExpirationISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="expiration-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("expiration-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "expiration-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="expiration-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="expiration-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="expiration-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class expiration_iso8601


class NextActionISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="nextaction-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("nextaction-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "nextaction-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="nextaction-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="nextaction-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="nextaction-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class nextaction_iso8601


class AssetTypeDef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        assettype=None,
        assettypebase=None,
        customassettype=None,
        assettypeattr=None,
        note=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.assettype = assettype
        self.assettype_nsprefix_ = None
        self.assettypebase = assettypebase
        self.assettypebase_nsprefix_ = None
        self.customassettype = customassettype
        self.customassettype_nsprefix_ = None
        if assettypeattr is None:
            self.assettypeattr = []
        else:
            self.assettypeattr = assettypeattr
        self.assettypeattr_nsprefix_ = None
        if note is None:
            self.note = []
        else:
            self.note = note
        self.note_nsprefix_ = None

    def get_assettype(self):
        return self.assettype

    def set_assettype(self, assettype):
        self.assettype = assettype

    def get_assettypebase(self):
        return self.assettypebase

    def set_assettypebase(self, assettypebase):
        self.assettypebase = assettypebase

    def get_customassettype(self):
        return self.customassettype

    def set_customassettype(self, customassettype):
        self.customassettype = customassettype

    def get_assettypeattr(self):
        return self.assettypeattr

    def set_assettypeattr(self, assettypeattr):
        self.assettypeattr = assettypeattr

    def add_assettypeattr(self, value):
        self.assettypeattr.append(value)

    def insert_assettypeattr_at(self, index, value):
        self.assettypeattr.insert(index, value)

    def replace_assettypeattr_at(self, index, value):
        self.assettypeattr[index] = value

    def get_note(self):
        return self.note

    def set_note(self, note):
        self.note = note

    def add_note(self, value):
        self.note.append(value)

    def insert_note_at(self, index, value):
        self.note.insert(index, value)

    def replace_note_at(self, index, value):
        self.note[index] = value

    def _has_content(self):
        if (
            self.assettype is not None
            or self.assettypebase is not None
            or self.customassettype is not None
            or self.assettypeattr
            or self.note
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assettypedef",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("assettypedef")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "assettypedef":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="assettypedef"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="assettypedef",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="assettypedef",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assettypedef",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.assettype is not None:
            namespace_prefix = (
                self.assettype_nsprefix_ + ":"
                if (UseCapturedNS and self.assettype_nsprefix_)
                else ""
            )
            self.assettype.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="assettype",
                pretty_print=pretty_print,
            )
        if self.assettypebase is not None:
            namespace_prefix = (
                self.assettypebase_nsprefix_ + ":"
                if (UseCapturedNS and self.assettypebase_nsprefix_)
                else ""
            )
            self.assettypebase.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="assettypebase",
                pretty_print=pretty_print,
            )
        if self.customassettype is not None:
            namespace_prefix = (
                self.customassettype_nsprefix_ + ":"
                if (UseCapturedNS and self.customassettype_nsprefix_)
                else ""
            )
            self.customassettype.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="customassettype",
                pretty_print=pretty_print,
            )
        for assettypeattr_ in self.assettypeattr:
            namespace_prefix = (
                self.assettypeattr_nsprefix_ + ":"
                if (UseCapturedNS and self.assettypeattr_nsprefix_)
                else ""
            )
            assettypeattr_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="assettypeattr",
                pretty_print=pretty_print,
            )
        for note_ in self.note:
            namespace_prefix = (
                self.note_nsprefix_ + ":"
                if (UseCapturedNS and self.note_nsprefix_)
                else ""
            )
            note_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="note",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "assettype":
            obj_ = AssetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assettype = obj_
            obj_.original_tagname_ = "assettype"
        elif node_name == "assettypebase":
            obj_ = AssetTypeBase.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assettypebase = obj_
            obj_.original_tagname_ = "assettypebase"
        elif node_name == "customassettype":
            obj_ = CustomAssetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customassettype = obj_
            obj_.original_tagname_ = "customassettype"
        elif node_name == "assettypeattr":
            obj_ = AssetTypeAttr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assettypeattr.append(obj_)
            obj_.original_tagname_ = "assettypeattr"
        elif node_name == "note":
            obj_ = Note.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.note.append(obj_)
            obj_.original_tagname_ = "note"


# end class assettypedef


class AssetTypeBase(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assettypebase",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("assettypebase")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "assettypebase":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="assettypebase"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="assettypebase",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assettypebase",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class assettypebase


class CustomAssetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="customassettype",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("customassettype")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "customassettype":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="customassettype"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="customassettype",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="customassettype",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class customassettype


class AssetTypeAttr(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        assettypeattrname=None,
        assettypeattrval=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.assettypeattrname = assettypeattrname
        self.assettypeattrname_nsprefix_ = None
        self.assettypeattrval = assettypeattrval
        self.assettypeattrval_nsprefix_ = None

    def get_assettypeattrname(self):
        return self.assettypeattrname

    def set_assettypeattrname(self, assettypeattrname):
        self.assettypeattrname = assettypeattrname

    def get_assettypeattrval(self):
        return self.assettypeattrval

    def set_assettypeattrval(self, assettypeattrval):
        self.assettypeattrval = assettypeattrval

    def _has_content(self):
        if self.assettypeattrname is not None or self.assettypeattrval is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assettypeattr",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("assettypeattr")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "assettypeattr":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="assettypeattr"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="assettypeattr",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="assettypeattr",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assettypeattr",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.assettypeattrname is not None:
            namespace_prefix = (
                self.assettypeattrname_nsprefix_ + ":"
                if (UseCapturedNS and self.assettypeattrname_nsprefix_)
                else ""
            )
            self.assettypeattrname.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="assettypeattrname",
                pretty_print=pretty_print,
            )
        if self.assettypeattrval is not None:
            namespace_prefix = (
                self.assettypeattrval_nsprefix_ + ":"
                if (UseCapturedNS and self.assettypeattrval_nsprefix_)
                else ""
            )
            self.assettypeattrval.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="assettypeattrval",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "assettypeattrname":
            obj_ = AssetTypeAttrName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assettypeattrname = obj_
            obj_.original_tagname_ = "assettypeattrname"
        elif node_name == "assettypeattrval":
            obj_ = AssetTypeAttrVal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assettypeattrval = obj_
            obj_.original_tagname_ = "assettypeattrval"


# end class assettypeattr


class AssetTypeAttrName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assettypeattrname",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("assettypeattrname")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "assettypeattrname":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="assettypeattrname",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="assettypeattrname",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assettypeattrname",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class assettypeattrname


class AssetTypeAttrVal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assettypeattrval",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("assettypeattrval")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "assettypeattrval":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="assettypeattrval",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="assettypeattrval",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assettypeattrval",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class assettypeattrval


class ReeferState(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        reefermake=None,
        interfacetype=None,
        contenttype=None,
        controlleron=None,
        fuelpercent=None,
        assetbatteryvoltage=None,
        engineon=None,
        enginemode=None,
        enginesize=None,
        enginespeed=None,
        enginerunhours=None,
        engineswitchonhours=None,
        enginestandbyhours=None,
        reeferoperatingstatus=None,
        reeferalarmstatus=None,
        activeprofileslotnumber=None,
        ambienttemperature=None,
        modezone1=None,
        setpointtemperaturezone1=None,
        supplyairtemperaturezone1=None,
        returnairtemperaturezone1=None,
        modezone2=None,
        setpointtemperaturezone2=None,
        returnairtemperaturezone2=None,
        modezone3=None,
        setpointtemperaturezone3=None,
        returnairtemperaturezone3=None,
        reeferremotetemperaturesensor1=None,
        reeferremotetemperaturesensor2=None,
        reeferremotetemperaturesensor3=None,
        doorstateopen=None,
        doorswitchopen=None,
        remoteswitch1open=None,
        remoteswitch2open=None,
        remotetemperaturesensor1=None,
        remotetemperaturesensor2=None,
        remotetemperaturesensor3=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.reefermake = reefermake
        self.reefermake_nsprefix_ = None
        self.interfacetype = interfacetype
        self.interfacetype_nsprefix_ = None
        self.contenttype = contenttype
        self.contenttype_nsprefix_ = None
        self.controlleron = controlleron
        self.controlleron_nsprefix_ = None
        self.fuelpercent = fuelpercent
        self.fuelpercent_nsprefix_ = None
        self.assetbatteryvoltage = assetbatteryvoltage
        self.assetbatteryvoltage_nsprefix_ = None
        self.engineon = engineon
        self.engineon_nsprefix_ = None
        self.enginemode = enginemode
        self.enginemode_nsprefix_ = None
        self.enginesize = enginesize
        self.enginesize_nsprefix_ = None
        self.enginespeed = enginespeed
        self.enginespeed_nsprefix_ = None
        self.enginerunhours = enginerunhours
        self.enginerunhours_nsprefix_ = None
        self.engineswitchonhours = engineswitchonhours
        self.engineswitchonhours_nsprefix_ = None
        self.enginestandbyhours = enginestandbyhours
        self.enginestandbyhours_nsprefix_ = None
        self.reeferoperatingstatus = reeferoperatingstatus
        self.reeferoperatingstatus_nsprefix_ = None
        self.reeferalarmstatus = reeferalarmstatus
        self.reeferalarmstatus_nsprefix_ = None
        self.activeprofileslotnumber = activeprofileslotnumber
        self.activeprofileslotnumber_nsprefix_ = None
        self.ambienttemperature = ambienttemperature
        self.ambienttemperature_nsprefix_ = None
        self.modezone1 = modezone1
        self.modezone1_nsprefix_ = None
        self.setpointtemperaturezone1 = setpointtemperaturezone1
        self.setpointtemperaturezone1_nsprefix_ = None
        self.supplyairtemperaturezone1 = supplyairtemperaturezone1
        self.supplyairtemperaturezone1_nsprefix_ = None
        self.returnairtemperaturezone1 = returnairtemperaturezone1
        self.returnairtemperaturezone1_nsprefix_ = None
        self.modezone2 = modezone2
        self.modezone2_nsprefix_ = None
        self.setpointtemperaturezone2 = setpointtemperaturezone2
        self.setpointtemperaturezone2_nsprefix_ = None
        self.returnairtemperaturezone2 = returnairtemperaturezone2
        self.returnairtemperaturezone2_nsprefix_ = None
        self.modezone3 = modezone3
        self.modezone3_nsprefix_ = None
        self.setpointtemperaturezone3 = setpointtemperaturezone3
        self.setpointtemperaturezone3_nsprefix_ = None
        self.returnairtemperaturezone3 = returnairtemperaturezone3
        self.returnairtemperaturezone3_nsprefix_ = None
        self.reeferremotetemperaturesensor1 = reeferremotetemperaturesensor1
        self.reeferremotetemperaturesensor1_nsprefix_ = None
        self.reeferremotetemperaturesensor2 = reeferremotetemperaturesensor2
        self.reeferremotetemperaturesensor2_nsprefix_ = None
        self.reeferremotetemperaturesensor3 = reeferremotetemperaturesensor3
        self.reeferremotetemperaturesensor3_nsprefix_ = None
        self.doorstateopen = doorstateopen
        self.doorstateopen_nsprefix_ = None
        self.doorswitchopen = doorswitchopen
        self.doorswitchopen_nsprefix_ = None
        self.remoteswitch1open = remoteswitch1open
        self.remoteswitch1open_nsprefix_ = None
        self.remoteswitch2open = remoteswitch2open
        self.remoteswitch2open_nsprefix_ = None
        self.remotetemperaturesensor1 = remotetemperaturesensor1
        self.remotetemperaturesensor1_nsprefix_ = None
        self.remotetemperaturesensor2 = remotetemperaturesensor2
        self.remotetemperaturesensor2_nsprefix_ = None
        self.remotetemperaturesensor3 = remotetemperaturesensor3
        self.remotetemperaturesensor3_nsprefix_ = None

    def get_reefermake(self):
        return self.reefermake

    def set_reefermake(self, reefermake):
        self.reefermake = reefermake

    def get_interfacetype(self):
        return self.interfacetype

    def set_interfacetype(self, interfacetype):
        self.interfacetype = interfacetype

    def get_contenttype(self):
        return self.contenttype

    def set_contenttype(self, contenttype):
        self.contenttype = contenttype

    def get_controlleron(self):
        return self.controlleron

    def set_controlleron(self, controlleron):
        self.controlleron = controlleron

    def get_fuelpercent(self):
        return self.fuelpercent

    def set_fuelpercent(self, fuelpercent):
        self.fuelpercent = fuelpercent

    def get_assetbatteryvoltage(self):
        return self.assetbatteryvoltage

    def set_assetbatteryvoltage(self, assetbatteryvoltage):
        self.assetbatteryvoltage = assetbatteryvoltage

    def get_engineon(self):
        return self.engineon

    def set_engineon(self, engineon):
        self.engineon = engineon

    def get_enginemode(self):
        return self.enginemode

    def set_enginemode(self, enginemode):
        self.enginemode = enginemode

    def get_enginesize(self):
        return self.enginesize

    def set_enginesize(self, enginesize):
        self.enginesize = enginesize

    def get_enginespeed(self):
        return self.enginespeed

    def set_enginespeed(self, enginespeed):
        self.enginespeed = enginespeed

    def get_enginerunhours(self):
        return self.enginerunhours

    def set_enginerunhours(self, enginerunhours):
        self.enginerunhours = enginerunhours

    def get_engineswitchonhours(self):
        return self.engineswitchonhours

    def set_engineswitchonhours(self, engineswitchonhours):
        self.engineswitchonhours = engineswitchonhours

    def get_enginestandbyhours(self):
        return self.enginestandbyhours

    def set_enginestandbyhours(self, enginestandbyhours):
        self.enginestandbyhours = enginestandbyhours

    def get_reeferoperatingstatus(self):
        return self.reeferoperatingstatus

    def set_reeferoperatingstatus(self, reeferoperatingstatus):
        self.reeferoperatingstatus = reeferoperatingstatus

    def get_reeferalarmstatus(self):
        return self.reeferalarmstatus

    def set_reeferalarmstatus(self, reeferalarmstatus):
        self.reeferalarmstatus = reeferalarmstatus

    def get_activeprofileslotnumber(self):
        return self.activeprofileslotnumber

    def set_activeprofileslotnumber(self, activeprofileslotnumber):
        self.activeprofileslotnumber = activeprofileslotnumber

    def get_ambienttemperature(self):
        return self.ambienttemperature

    def set_ambienttemperature(self, ambienttemperature):
        self.ambienttemperature = ambienttemperature

    def get_modezone1(self):
        return self.modezone1

    def set_modezone1(self, modezone1):
        self.modezone1 = modezone1

    def get_setpointtemperaturezone1(self):
        return self.setpointtemperaturezone1

    def set_setpointtemperaturezone1(self, setpointtemperaturezone1):
        self.setpointtemperaturezone1 = setpointtemperaturezone1

    def get_supplyairtemperaturezone1(self):
        return self.supplyairtemperaturezone1

    def set_supplyairtemperaturezone1(self, supplyairtemperaturezone1):
        self.supplyairtemperaturezone1 = supplyairtemperaturezone1

    def get_returnairtemperaturezone1(self):
        return self.returnairtemperaturezone1

    def set_returnairtemperaturezone1(self, returnairtemperaturezone1):
        self.returnairtemperaturezone1 = returnairtemperaturezone1

    def get_modezone2(self):
        return self.modezone2

    def set_modezone2(self, modezone2):
        self.modezone2 = modezone2

    def get_setpointtemperaturezone2(self):
        return self.setpointtemperaturezone2

    def set_setpointtemperaturezone2(self, setpointtemperaturezone2):
        self.setpointtemperaturezone2 = setpointtemperaturezone2

    def get_returnairtemperaturezone2(self):
        return self.returnairtemperaturezone2

    def set_returnairtemperaturezone2(self, returnairtemperaturezone2):
        self.returnairtemperaturezone2 = returnairtemperaturezone2

    def get_modezone3(self):
        return self.modezone3

    def set_modezone3(self, modezone3):
        self.modezone3 = modezone3

    def get_setpointtemperaturezone3(self):
        return self.setpointtemperaturezone3

    def set_setpointtemperaturezone3(self, setpointtemperaturezone3):
        self.setpointtemperaturezone3 = setpointtemperaturezone3

    def get_returnairtemperaturezone3(self):
        return self.returnairtemperaturezone3

    def set_returnairtemperaturezone3(self, returnairtemperaturezone3):
        self.returnairtemperaturezone3 = returnairtemperaturezone3

    def get_reeferremotetemperaturesensor1(self):
        return self.reeferremotetemperaturesensor1

    def set_reeferremotetemperaturesensor1(self, reeferremotetemperaturesensor1):
        self.reeferremotetemperaturesensor1 = reeferremotetemperaturesensor1

    def get_reeferremotetemperaturesensor2(self):
        return self.reeferremotetemperaturesensor2

    def set_reeferremotetemperaturesensor2(self, reeferremotetemperaturesensor2):
        self.reeferremotetemperaturesensor2 = reeferremotetemperaturesensor2

    def get_reeferremotetemperaturesensor3(self):
        return self.reeferremotetemperaturesensor3

    def set_reeferremotetemperaturesensor3(self, reeferremotetemperaturesensor3):
        self.reeferremotetemperaturesensor3 = reeferremotetemperaturesensor3

    def get_doorstateopen(self):
        return self.doorstateopen

    def set_doorstateopen(self, doorstateopen):
        self.doorstateopen = doorstateopen

    def get_doorswitchopen(self):
        return self.doorswitchopen

    def set_doorswitchopen(self, doorswitchopen):
        self.doorswitchopen = doorswitchopen

    def get_remoteswitch1open(self):
        return self.remoteswitch1open

    def set_remoteswitch1open(self, remoteswitch1open):
        self.remoteswitch1open = remoteswitch1open

    def get_remoteswitch2open(self):
        return self.remoteswitch2open

    def set_remoteswitch2open(self, remoteswitch2open):
        self.remoteswitch2open = remoteswitch2open

    def get_remotetemperaturesensor1(self):
        return self.remotetemperaturesensor1

    def set_remotetemperaturesensor1(self, remotetemperaturesensor1):
        self.remotetemperaturesensor1 = remotetemperaturesensor1

    def get_remotetemperaturesensor2(self):
        return self.remotetemperaturesensor2

    def set_remotetemperaturesensor2(self, remotetemperaturesensor2):
        self.remotetemperaturesensor2 = remotetemperaturesensor2

    def get_remotetemperaturesensor3(self):
        return self.remotetemperaturesensor3

    def set_remotetemperaturesensor3(self, remotetemperaturesensor3):
        self.remotetemperaturesensor3 = remotetemperaturesensor3

    def _has_content(self):
        if (
            self.reefermake is not None
            or self.interfacetype is not None
            or self.contenttype is not None
            or self.controlleron is not None
            or self.fuelpercent is not None
            or self.assetbatteryvoltage is not None
            or self.engineon is not None
            or self.enginemode is not None
            or self.enginesize is not None
            or self.enginespeed is not None
            or self.enginerunhours is not None
            or self.engineswitchonhours is not None
            or self.enginestandbyhours is not None
            or self.reeferoperatingstatus is not None
            or self.reeferalarmstatus is not None
            or self.activeprofileslotnumber is not None
            or self.ambienttemperature is not None
            or self.modezone1 is not None
            or self.setpointtemperaturezone1 is not None
            or self.supplyairtemperaturezone1 is not None
            or self.returnairtemperaturezone1 is not None
            or self.modezone2 is not None
            or self.setpointtemperaturezone2 is not None
            or self.returnairtemperaturezone2 is not None
            or self.modezone3 is not None
            or self.setpointtemperaturezone3 is not None
            or self.returnairtemperaturezone3 is not None
            or self.reeferremotetemperaturesensor1 is not None
            or self.reeferremotetemperaturesensor2 is not None
            or self.reeferremotetemperaturesensor3 is not None
            or self.doorstateopen is not None
            or self.doorswitchopen is not None
            or self.remoteswitch1open is not None
            or self.remoteswitch2open is not None
            or self.remotetemperaturesensor1 is not None
            or self.remotetemperaturesensor2 is not None
            or self.remotetemperaturesensor3 is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferstate",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("reeferstate")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "reeferstate":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="reeferstate"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="reeferstate",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="reeferstate",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferstate",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.reefermake is not None:
            namespace_prefix = (
                self.reefermake_nsprefix_ + ":"
                if (UseCapturedNS and self.reefermake_nsprefix_)
                else ""
            )
            self.reefermake.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="reefermake",
                pretty_print=pretty_print,
            )
        if self.interfacetype is not None:
            namespace_prefix = (
                self.interfacetype_nsprefix_ + ":"
                if (UseCapturedNS and self.interfacetype_nsprefix_)
                else ""
            )
            self.interfacetype.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="interfacetype",
                pretty_print=pretty_print,
            )
        if self.contenttype is not None:
            namespace_prefix = (
                self.contenttype_nsprefix_ + ":"
                if (UseCapturedNS and self.contenttype_nsprefix_)
                else ""
            )
            self.contenttype.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="contenttype",
                pretty_print=pretty_print,
            )
        if self.controlleron is not None:
            namespace_prefix = (
                self.controlleron_nsprefix_ + ":"
                if (UseCapturedNS and self.controlleron_nsprefix_)
                else ""
            )
            self.controlleron.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="controlleron",
                pretty_print=pretty_print,
            )
        if self.fuelpercent is not None:
            namespace_prefix = (
                self.fuelpercent_nsprefix_ + ":"
                if (UseCapturedNS and self.fuelpercent_nsprefix_)
                else ""
            )
            self.fuelpercent.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="fuelpercent",
                pretty_print=pretty_print,
            )
        if self.assetbatteryvoltage is not None:
            namespace_prefix = (
                self.assetbatteryvoltage_nsprefix_ + ":"
                if (UseCapturedNS and self.assetbatteryvoltage_nsprefix_)
                else ""
            )
            self.assetbatteryvoltage.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="assetbatteryvoltage",
                pretty_print=pretty_print,
            )
        if self.engineon is not None:
            namespace_prefix = (
                self.engineon_nsprefix_ + ":"
                if (UseCapturedNS and self.engineon_nsprefix_)
                else ""
            )
            self.engineon.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="engineon",
                pretty_print=pretty_print,
            )
        if self.enginemode is not None:
            namespace_prefix = (
                self.enginemode_nsprefix_ + ":"
                if (UseCapturedNS and self.enginemode_nsprefix_)
                else ""
            )
            self.enginemode.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="enginemode",
                pretty_print=pretty_print,
            )
        if self.enginesize is not None:
            namespace_prefix = (
                self.enginesize_nsprefix_ + ":"
                if (UseCapturedNS and self.enginesize_nsprefix_)
                else ""
            )
            self.enginesize.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="enginesize",
                pretty_print=pretty_print,
            )
        if self.enginespeed is not None:
            namespace_prefix = (
                self.enginespeed_nsprefix_ + ":"
                if (UseCapturedNS and self.enginespeed_nsprefix_)
                else ""
            )
            self.enginespeed.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="enginespeed",
                pretty_print=pretty_print,
            )
        if self.enginerunhours is not None:
            namespace_prefix = (
                self.enginerunhours_nsprefix_ + ":"
                if (UseCapturedNS and self.enginerunhours_nsprefix_)
                else ""
            )
            self.enginerunhours.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="enginerunhours",
                pretty_print=pretty_print,
            )
        if self.engineswitchonhours is not None:
            namespace_prefix = (
                self.engineswitchonhours_nsprefix_ + ":"
                if (UseCapturedNS and self.engineswitchonhours_nsprefix_)
                else ""
            )
            self.engineswitchonhours.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="engineswitchonhours",
                pretty_print=pretty_print,
            )
        if self.enginestandbyhours is not None:
            namespace_prefix = (
                self.enginestandbyhours_nsprefix_ + ":"
                if (UseCapturedNS and self.enginestandbyhours_nsprefix_)
                else ""
            )
            self.enginestandbyhours.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="enginestandbyhours",
                pretty_print=pretty_print,
            )
        if self.reeferoperatingstatus is not None:
            namespace_prefix = (
                self.reeferoperatingstatus_nsprefix_ + ":"
                if (UseCapturedNS and self.reeferoperatingstatus_nsprefix_)
                else ""
            )
            self.reeferoperatingstatus.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="reeferoperatingstatus",
                pretty_print=pretty_print,
            )
        if self.reeferalarmstatus is not None:
            namespace_prefix = (
                self.reeferalarmstatus_nsprefix_ + ":"
                if (UseCapturedNS and self.reeferalarmstatus_nsprefix_)
                else ""
            )
            self.reeferalarmstatus.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="reeferalarmstatus",
                pretty_print=pretty_print,
            )
        if self.activeprofileslotnumber is not None:
            namespace_prefix = (
                self.activeprofileslotnumber_nsprefix_ + ":"
                if (UseCapturedNS and self.activeprofileslotnumber_nsprefix_)
                else ""
            )
            self.activeprofileslotnumber.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="activeprofileslotnumber",
                pretty_print=pretty_print,
            )
        if self.ambienttemperature is not None:
            namespace_prefix = (
                self.ambienttemperature_nsprefix_ + ":"
                if (UseCapturedNS and self.ambienttemperature_nsprefix_)
                else ""
            )
            self.ambienttemperature.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="ambienttemperature",
                pretty_print=pretty_print,
            )
        if self.modezone1 is not None:
            namespace_prefix = (
                self.modezone1_nsprefix_ + ":"
                if (UseCapturedNS and self.modezone1_nsprefix_)
                else ""
            )
            self.modezone1.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="modezone1",
                pretty_print=pretty_print,
            )
        if self.setpointtemperaturezone1 is not None:
            namespace_prefix = (
                self.setpointtemperaturezone1_nsprefix_ + ":"
                if (UseCapturedNS and self.setpointtemperaturezone1_nsprefix_)
                else ""
            )
            self.setpointtemperaturezone1.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="setpointtemperaturezone1",
                pretty_print=pretty_print,
            )
        if self.supplyairtemperaturezone1 is not None:
            namespace_prefix = (
                self.supplyairtemperaturezone1_nsprefix_ + ":"
                if (UseCapturedNS and self.supplyairtemperaturezone1_nsprefix_)
                else ""
            )
            self.supplyairtemperaturezone1.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="supplyairtemperaturezone1",
                pretty_print=pretty_print,
            )
        if self.returnairtemperaturezone1 is not None:
            namespace_prefix = (
                self.returnairtemperaturezone1_nsprefix_ + ":"
                if (UseCapturedNS and self.returnairtemperaturezone1_nsprefix_)
                else ""
            )
            self.returnairtemperaturezone1.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="returnairtemperaturezone1",
                pretty_print=pretty_print,
            )
        if self.modezone2 is not None:
            namespace_prefix = (
                self.modezone2_nsprefix_ + ":"
                if (UseCapturedNS and self.modezone2_nsprefix_)
                else ""
            )
            self.modezone2.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="modezone2",
                pretty_print=pretty_print,
            )
        if self.setpointtemperaturezone2 is not None:
            namespace_prefix = (
                self.setpointtemperaturezone2_nsprefix_ + ":"
                if (UseCapturedNS and self.setpointtemperaturezone2_nsprefix_)
                else ""
            )
            self.setpointtemperaturezone2.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="setpointtemperaturezone2",
                pretty_print=pretty_print,
            )
        if self.returnairtemperaturezone2 is not None:
            namespace_prefix = (
                self.returnairtemperaturezone2_nsprefix_ + ":"
                if (UseCapturedNS and self.returnairtemperaturezone2_nsprefix_)
                else ""
            )
            self.returnairtemperaturezone2.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="returnairtemperaturezone2",
                pretty_print=pretty_print,
            )
        if self.modezone3 is not None:
            namespace_prefix = (
                self.modezone3_nsprefix_ + ":"
                if (UseCapturedNS and self.modezone3_nsprefix_)
                else ""
            )
            self.modezone3.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="modezone3",
                pretty_print=pretty_print,
            )
        if self.setpointtemperaturezone3 is not None:
            namespace_prefix = (
                self.setpointtemperaturezone3_nsprefix_ + ":"
                if (UseCapturedNS and self.setpointtemperaturezone3_nsprefix_)
                else ""
            )
            self.setpointtemperaturezone3.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="setpointtemperaturezone3",
                pretty_print=pretty_print,
            )
        if self.returnairtemperaturezone3 is not None:
            namespace_prefix = (
                self.returnairtemperaturezone3_nsprefix_ + ":"
                if (UseCapturedNS and self.returnairtemperaturezone3_nsprefix_)
                else ""
            )
            self.returnairtemperaturezone3.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="returnairtemperaturezone3",
                pretty_print=pretty_print,
            )
        if self.reeferremotetemperaturesensor1 is not None:
            namespace_prefix = (
                self.reeferremotetemperaturesensor1_nsprefix_ + ":"
                if (UseCapturedNS and self.reeferremotetemperaturesensor1_nsprefix_)
                else ""
            )
            self.reeferremotetemperaturesensor1.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="reeferremotetemperaturesensor1",
                pretty_print=pretty_print,
            )
        if self.reeferremotetemperaturesensor2 is not None:
            namespace_prefix = (
                self.reeferremotetemperaturesensor2_nsprefix_ + ":"
                if (UseCapturedNS and self.reeferremotetemperaturesensor2_nsprefix_)
                else ""
            )
            self.reeferremotetemperaturesensor2.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="reeferremotetemperaturesensor2",
                pretty_print=pretty_print,
            )
        if self.reeferremotetemperaturesensor3 is not None:
            namespace_prefix = (
                self.reeferremotetemperaturesensor3_nsprefix_ + ":"
                if (UseCapturedNS and self.reeferremotetemperaturesensor3_nsprefix_)
                else ""
            )
            self.reeferremotetemperaturesensor3.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="reeferremotetemperaturesensor3",
                pretty_print=pretty_print,
            )
        if self.doorstateopen is not None:
            namespace_prefix = (
                self.doorstateopen_nsprefix_ + ":"
                if (UseCapturedNS and self.doorstateopen_nsprefix_)
                else ""
            )
            self.doorstateopen.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="doorstateopen",
                pretty_print=pretty_print,
            )
        if self.doorswitchopen is not None:
            namespace_prefix = (
                self.doorswitchopen_nsprefix_ + ":"
                if (UseCapturedNS and self.doorswitchopen_nsprefix_)
                else ""
            )
            self.doorswitchopen.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="doorswitchopen",
                pretty_print=pretty_print,
            )
        if self.remoteswitch1open is not None:
            namespace_prefix = (
                self.remoteswitch1open_nsprefix_ + ":"
                if (UseCapturedNS and self.remoteswitch1open_nsprefix_)
                else ""
            )
            self.remoteswitch1open.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="remoteswitch1open",
                pretty_print=pretty_print,
            )
        if self.remoteswitch2open is not None:
            namespace_prefix = (
                self.remoteswitch2open_nsprefix_ + ":"
                if (UseCapturedNS and self.remoteswitch2open_nsprefix_)
                else ""
            )
            self.remoteswitch2open.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="remoteswitch2open",
                pretty_print=pretty_print,
            )
        if self.remotetemperaturesensor1 is not None:
            namespace_prefix = (
                self.remotetemperaturesensor1_nsprefix_ + ":"
                if (UseCapturedNS and self.remotetemperaturesensor1_nsprefix_)
                else ""
            )
            self.remotetemperaturesensor1.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="remotetemperaturesensor1",
                pretty_print=pretty_print,
            )
        if self.remotetemperaturesensor2 is not None:
            namespace_prefix = (
                self.remotetemperaturesensor2_nsprefix_ + ":"
                if (UseCapturedNS and self.remotetemperaturesensor2_nsprefix_)
                else ""
            )
            self.remotetemperaturesensor2.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="remotetemperaturesensor2",
                pretty_print=pretty_print,
            )
        if self.remotetemperaturesensor3 is not None:
            namespace_prefix = (
                self.remotetemperaturesensor3_nsprefix_ + ":"
                if (UseCapturedNS and self.remotetemperaturesensor3_nsprefix_)
                else ""
            )
            self.remotetemperaturesensor3.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="remotetemperaturesensor3",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "reefermake":
            obj_ = ReeferMake.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reefermake = obj_
            obj_.original_tagname_ = "reefermake"
        elif node_name == "interfacetype":
            obj_ = InterfaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interfacetype = obj_
            obj_.original_tagname_ = "interfacetype"
        elif node_name == "contenttype":
            obj_ = ContentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contenttype = obj_
            obj_.original_tagname_ = "contenttype"
        elif node_name == "controlleron":
            obj_ = ControllerOn.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.controlleron = obj_
            obj_.original_tagname_ = "controlleron"
        elif node_name == "fuelpercent":
            obj_ = FuelPercent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fuelpercent = obj_
            obj_.original_tagname_ = "fuelpercent"
        elif node_name == "assetbatteryvoltage":
            obj_ = AssetBatteryVoltage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assetbatteryvoltage = obj_
            obj_.original_tagname_ = "assetbatteryvoltage"
        elif node_name == "engineon":
            obj_ = EngineOn.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.engineon = obj_
            obj_.original_tagname_ = "engineon"
        elif node_name == "enginemode":
            obj_ = EngineMode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enginemode = obj_
            obj_.original_tagname_ = "enginemode"
        elif node_name == "enginesize":
            obj_ = EngineSize.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enginesize = obj_
            obj_.original_tagname_ = "enginesize"
        elif node_name == "enginespeed":
            obj_ = EngineSpeed.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enginespeed = obj_
            obj_.original_tagname_ = "enginespeed"
        elif node_name == "enginerunhours":
            obj_ = EngineRunHours.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enginerunhours = obj_
            obj_.original_tagname_ = "enginerunhours"
        elif node_name == "engineswitchonhours":
            obj_ = EngineSwitchOnHours.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.engineswitchonhours = obj_
            obj_.original_tagname_ = "engineswitchonhours"
        elif node_name == "enginestandbyhours":
            obj_ = EngineStandByHours.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enginestandbyhours = obj_
            obj_.original_tagname_ = "enginestandbyhours"
        elif node_name == "reeferoperatingstatus":
            obj_ = ReeferOperatingStatus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reeferoperatingstatus = obj_
            obj_.original_tagname_ = "reeferoperatingstatus"
        elif node_name == "reeferalarmstatus":
            obj_ = ReeferAlarmStatus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reeferalarmstatus = obj_
            obj_.original_tagname_ = "reeferalarmstatus"
        elif node_name == "activeprofileslotnumber":
            obj_ = ActiveProfileSlotNumber.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activeprofileslotnumber = obj_
            obj_.original_tagname_ = "activeprofileslotnumber"
        elif node_name == "ambienttemperature":
            obj_ = AmbientTemperature.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ambienttemperature = obj_
            obj_.original_tagname_ = "ambienttemperature"
        elif node_name == "modezone1":
            obj_ = ModeZone1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modezone1 = obj_
            obj_.original_tagname_ = "modezone1"
        elif node_name == "setpointtemperaturezone1":
            obj_ = SetPointTemperatureZone1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setpointtemperaturezone1 = obj_
            obj_.original_tagname_ = "setpointtemperaturezone1"
        elif node_name == "supplyairtemperaturezone1":
            obj_ = SupplyAirTemperatureZone1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supplyairtemperaturezone1 = obj_
            obj_.original_tagname_ = "supplyairtemperaturezone1"
        elif node_name == "returnairtemperaturezone1":
            obj_ = ReturnAirTemperatureZone1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.returnairtemperaturezone1 = obj_
            obj_.original_tagname_ = "returnairtemperaturezone1"
        elif node_name == "modezone2":
            obj_ = ModeZone2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modezone2 = obj_
            obj_.original_tagname_ = "modezone2"
        elif node_name == "setpointtemperaturezone2":
            obj_ = SetPointTemperatureZone2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setpointtemperaturezone2 = obj_
            obj_.original_tagname_ = "setpointtemperaturezone2"
        elif node_name == "returnairtemperaturezone2":
            obj_ = ReturnAirTemperatureZone2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.returnairtemperaturezone2 = obj_
            obj_.original_tagname_ = "returnairtemperaturezone2"
        elif node_name == "modezone3":
            obj_ = ModeZone3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modezone3 = obj_
            obj_.original_tagname_ = "modezone3"
        elif node_name == "setpointtemperaturezone3":
            obj_ = SetPointTemperatureZone3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setpointtemperaturezone3 = obj_
            obj_.original_tagname_ = "setpointtemperaturezone3"
        elif node_name == "returnairtemperaturezone3":
            obj_ = ReturnAirTemperatureZone3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.returnairtemperaturezone3 = obj_
            obj_.original_tagname_ = "returnairtemperaturezone3"
        elif node_name == "reeferremotetemperaturesensor1":
            obj_ = ReeferRemoteTemperatureSensor1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reeferremotetemperaturesensor1 = obj_
            obj_.original_tagname_ = "reeferremotetemperaturesensor1"
        elif node_name == "reeferremotetemperaturesensor2":
            obj_ = ReeferRemoteTemperatureSensor2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reeferremotetemperaturesensor2 = obj_
            obj_.original_tagname_ = "reeferremotetemperaturesensor2"
        elif node_name == "reeferremotetemperaturesensor3":
            obj_ = ReeferRemoteTemperatureSensor3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reeferremotetemperaturesensor3 = obj_
            obj_.original_tagname_ = "reeferremotetemperaturesensor3"
        elif node_name == "doorstateopen":
            obj_ = DoorStateOpen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.doorstateopen = obj_
            obj_.original_tagname_ = "doorstateopen"
        elif node_name == "doorswitchopen":
            obj_ = DoorSwitchOpen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.doorswitchopen = obj_
            obj_.original_tagname_ = "doorswitchopen"
        elif node_name == "remoteswitch1open":
            obj_ = RemoteSwitch1Open.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remoteswitch1open = obj_
            obj_.original_tagname_ = "remoteswitch1open"
        elif node_name == "remoteswitch2open":
            obj_ = RemoteSwitch2Open.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remoteswitch2open = obj_
            obj_.original_tagname_ = "remoteswitch2open"
        elif node_name == "remotetemperaturesensor1":
            obj_ = RemoteTemperatureSensor1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remotetemperaturesensor1 = obj_
            obj_.original_tagname_ = "remotetemperaturesensor1"
        elif node_name == "remotetemperaturesensor2":
            obj_ = RemoteTemperatureSensor2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remotetemperaturesensor2 = obj_
            obj_.original_tagname_ = "remotetemperaturesensor2"
        elif node_name == "remotetemperaturesensor3":
            obj_ = RemoteTemperatureSensor3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remotetemperaturesensor3 = obj_
            obj_.original_tagname_ = "remotetemperaturesensor3"


# end class reeferstate


class ReeferAlarmStatus(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self, reeferalarmtype=None, reeferalarm=None, gds_collector_=None, **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.reeferalarmtype = reeferalarmtype
        self.reeferalarmtype_nsprefix_ = None
        if reeferalarm is None:
            self.reeferalarm = []
        else:
            self.reeferalarm = reeferalarm
        self.reeferalarm_nsprefix_ = None

    def get_reeferalarmtype(self):
        return self.reeferalarmtype

    def set_reeferalarmtype(self, reeferalarmtype):
        self.reeferalarmtype = reeferalarmtype

    def get_reeferalarm(self):
        return self.reeferalarm

    def set_reeferalarm(self, reeferalarm):
        self.reeferalarm = reeferalarm

    def add_reeferalarm(self, value):
        self.reeferalarm.append(value)

    def insert_reeferalarm_at(self, index, value):
        self.reeferalarm.insert(index, value)

    def replace_reeferalarm_at(self, index, value):
        self.reeferalarm[index] = value

    def _has_content(self):
        if self.reeferalarmtype is not None or self.reeferalarm:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferalarmstatus",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("reeferalarmstatus")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "reeferalarmstatus":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="reeferalarmstatus",
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="reeferalarmstatus",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="reeferalarmstatus",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferalarmstatus",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.reeferalarmtype is not None:
            namespace_prefix = (
                self.reeferalarmtype_nsprefix_ + ":"
                if (UseCapturedNS and self.reeferalarmtype_nsprefix_)
                else ""
            )
            self.reeferalarmtype.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="reeferalarmtype",
                pretty_print=pretty_print,
            )
        for reeferalarm_ in self.reeferalarm:
            namespace_prefix = (
                self.reeferalarm_nsprefix_ + ":"
                if (UseCapturedNS and self.reeferalarm_nsprefix_)
                else ""
            )
            reeferalarm_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="reeferalarm",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "reeferalarmtype":
            obj_ = ReeferAlarmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reeferalarmtype = obj_
            obj_.original_tagname_ = "reeferalarmtype"
        elif node_name == "reeferalarm":
            obj_ = ReeferAlarm.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reeferalarm.append(obj_)
            obj_.original_tagname_ = "reeferalarm"


# end class reeferalarmstatus


class ReeferAlarm(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        alarmid=None,
        alarmactive=None,
        alarmdescr=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.alarmid = alarmid
        self.alarmid_nsprefix_ = None
        self.alarmactive = alarmactive
        self.alarmactive_nsprefix_ = None
        self.alarmdescr = alarmdescr
        self.alarmdescr_nsprefix_ = None

    def get_alarmid(self):
        return self.alarmid

    def set_alarmid(self, alarmid):
        self.alarmid = alarmid

    def get_alarmactive(self):
        return self.alarmactive

    def set_alarmactive(self, alarmactive):
        self.alarmactive = alarmactive

    def get_alarmdescr(self):
        return self.alarmdescr

    def set_alarmdescr(self, alarmdescr):
        self.alarmdescr = alarmdescr

    def _has_content(self):
        if (
            self.alarmid is not None
            or self.alarmactive is not None
            or self.alarmdescr is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferalarm",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("reeferalarm")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "reeferalarm":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="reeferalarm"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="reeferalarm",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="reeferalarm",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferalarm",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.alarmid is not None:
            namespace_prefix = (
                self.alarmid_nsprefix_ + ":"
                if (UseCapturedNS and self.alarmid_nsprefix_)
                else ""
            )
            self.alarmid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="alarmid",
                pretty_print=pretty_print,
            )
        if self.alarmactive is not None:
            namespace_prefix = (
                self.alarmactive_nsprefix_ + ":"
                if (UseCapturedNS and self.alarmactive_nsprefix_)
                else ""
            )
            self.alarmactive.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="alarmactive",
                pretty_print=pretty_print,
            )
        if self.alarmdescr is not None:
            namespace_prefix = (
                self.alarmdescr_nsprefix_ + ":"
                if (UseCapturedNS and self.alarmdescr_nsprefix_)
                else ""
            )
            self.alarmdescr.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="alarmdescr",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "alarmid":
            obj_ = AlarmId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alarmid = obj_
            obj_.original_tagname_ = "alarmid"
        elif node_name == "alarmactive":
            obj_ = AlarmActive.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alarmactive = obj_
            obj_.original_tagname_ = "alarmactive"
        elif node_name == "alarmdescr":
            obj_ = AlarmDescr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alarmdescr = obj_
            obj_.original_tagname_ = "alarmdescr"


# end class reeferalarm


class ReeferMake(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reefermake",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("reefermake")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "reefermake":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="reefermake"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="reefermake"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reefermake",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class reefermake


class InterfaceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="interfacetype",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("interfacetype")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "interfacetype":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="interfacetype"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="interfacetype",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="interfacetype",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class interfacetype


class ContentType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="contenttype",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("contenttype")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "contenttype":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="contenttype"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="contenttype",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="contenttype",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class contenttype


class ControllerOn(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="controlleron",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("controlleron")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "controlleron":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="controlleron"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="controlleron",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="controlleron",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class controlleron


class FuelPercent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="fuelpercent",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("fuelpercent")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "fuelpercent":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="fuelpercent"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="fuelpercent",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="fuelpercent",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class fuelpercent


class AssetBatteryVoltage(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assetbatteryvoltage",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("assetbatteryvoltage")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "assetbatteryvoltage":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="assetbatteryvoltage",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="assetbatteryvoltage",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="assetbatteryvoltage",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class assetbatteryvoltage


class EngineOn(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="engineon",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("engineon")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "engineon":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="engineon"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="engineon"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="engineon",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class engineon


class EngineMode(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="enginemode",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("enginemode")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "enginemode":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="enginemode"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="enginemode"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="enginemode",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class enginemode


class EngineSize(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="enginesize",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("enginesize")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "enginesize":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="enginesize"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="enginesize"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="enginesize",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class enginesize


class EngineSpeed(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="enginespeed",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("enginespeed")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "enginespeed":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="enginespeed"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="enginespeed",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="enginespeed",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class enginespeed


class EngineRunHours(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="enginerunhours",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("enginerunhours")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "enginerunhours":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="enginerunhours"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="enginerunhours",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="enginerunhours",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class enginerunhours


class EngineSwitchOnHours(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="engineswitchonhours",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("engineswitchonhours")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "engineswitchonhours":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="engineswitchonhours",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="engineswitchonhours",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="engineswitchonhours",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class engineswitchonhours


class EngineStandByHours(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="enginestandbyhours",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("enginestandbyhours")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "enginestandbyhours":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="enginestandbyhours",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="enginestandbyhours",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="enginestandbyhours",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class enginestandbyhours


class ReeferOperatingStatus(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferoperatingstatus",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("reeferoperatingstatus")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "reeferoperatingstatus":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="reeferoperatingstatus",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="reeferoperatingstatus",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferoperatingstatus",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class reeferoperatingstatus


class ActiveProfileSlotNumber(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="activeprofileslotnumber",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("activeprofileslotnumber")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "activeprofileslotnumber":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="activeprofileslotnumber",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="activeprofileslotnumber",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="activeprofileslotnumber",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class activeprofileslotnumber


class AmbientTemperature(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="ambienttemperature",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("ambienttemperature")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ambienttemperature":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="ambienttemperature",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="ambienttemperature",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="ambienttemperature",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class ambienttemperature


class ModeZone1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="modezone1",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("modezone1")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "modezone1":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="modezone1"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="modezone1"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="modezone1",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class modezone1


class SetPointTemperatureZone1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="setpointtemperaturezone1",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("setpointtemperaturezone1")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "setpointtemperaturezone1":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="setpointtemperaturezone1",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="setpointtemperaturezone1",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="setpointtemperaturezone1",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class setpointtemperaturezone1


class SupplyAirTemperatureZone1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="supplyairtemperaturezone1",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("supplyairtemperaturezone1")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "supplyairtemperaturezone1":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="supplyairtemperaturezone1",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="supplyairtemperaturezone1",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="supplyairtemperaturezone1",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class supplyairtemperaturezone1


class ReturnAirTemperatureZone1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="returnairtemperaturezone1",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("returnairtemperaturezone1")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "returnairtemperaturezone1":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="returnairtemperaturezone1",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="returnairtemperaturezone1",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="returnairtemperaturezone1",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class returnairtemperaturezone1


class ModeZone2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="modezone2",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("modezone2")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "modezone2":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="modezone2"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="modezone2"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="modezone2",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class modezone2


class SetPointTemperatureZone2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="setpointtemperaturezone2",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("setpointtemperaturezone2")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "setpointtemperaturezone2":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="setpointtemperaturezone2",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="setpointtemperaturezone2",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="setpointtemperaturezone2",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class setpointtemperaturezone2


class ReturnAirTemperatureZone2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="returnairtemperaturezone2",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("returnairtemperaturezone2")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "returnairtemperaturezone2":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="returnairtemperaturezone2",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="returnairtemperaturezone2",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="returnairtemperaturezone2",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class returnairtemperaturezone2


class ModeZone3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="modezone3",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("modezone3")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "modezone3":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="modezone3"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="modezone3"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="modezone3",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class modezone3


class SetPointTemperatureZone3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="setpointtemperaturezone3",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("setpointtemperaturezone3")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "setpointtemperaturezone3":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="setpointtemperaturezone3",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="setpointtemperaturezone3",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="setpointtemperaturezone3",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class setpointtemperaturezone3


class ReturnAirTemperatureZone3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="returnairtemperaturezone3",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("returnairtemperaturezone3")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "returnairtemperaturezone3":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="returnairtemperaturezone3",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="returnairtemperaturezone3",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="returnairtemperaturezone3",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class returnairtemperaturezone3


class ReeferRemoteTemperatureSensor1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferremotetemperaturesensor1",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("reeferremotetemperaturesensor1")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "reeferremotetemperaturesensor1"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="reeferremotetemperaturesensor1",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="reeferremotetemperaturesensor1",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferremotetemperaturesensor1",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class reeferremotetemperaturesensor1


class ReeferRemoteTemperatureSensor2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferremotetemperaturesensor2",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("reeferremotetemperaturesensor2")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "reeferremotetemperaturesensor2"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="reeferremotetemperaturesensor2",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="reeferremotetemperaturesensor2",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferremotetemperaturesensor2",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class reeferremotetemperaturesensor2


class ReeferRemoteTemperatureSensor3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferremotetemperaturesensor3",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("reeferremotetemperaturesensor3")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "reeferremotetemperaturesensor3"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="reeferremotetemperaturesensor3",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="reeferremotetemperaturesensor3",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferremotetemperaturesensor3",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class reeferremotetemperaturesensor3


class DoorStateOpen(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="doorstateopen",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("doorstateopen")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "doorstateopen":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="doorstateopen"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="doorstateopen",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="doorstateopen",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class doorstateopen


class DoorSwitchOpen(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="doorswitchopen",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("doorswitchopen")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "doorswitchopen":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="doorswitchopen"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="doorswitchopen",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="doorswitchopen",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class doorswitchopen


class RemoteSwitch1Open(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="remoteswitch1open",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("remoteswitch1open")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "remoteswitch1open":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="remoteswitch1open",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="remoteswitch1open",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="remoteswitch1open",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class remoteswitch1open


class RemoteSwitch2Open(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="remoteswitch2open",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("remoteswitch2open")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "remoteswitch2open":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="remoteswitch2open",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="remoteswitch2open",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="remoteswitch2open",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class remoteswitch2open


class RemoteTemperatureSensor1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="remotetemperaturesensor1",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("remotetemperaturesensor1")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "remotetemperaturesensor1":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="remotetemperaturesensor1",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="remotetemperaturesensor1",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="remotetemperaturesensor1",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class remotetemperaturesensor1


class RemoteTemperatureSensor2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="remotetemperaturesensor2",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("remotetemperaturesensor2")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "remotetemperaturesensor2":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="remotetemperaturesensor2",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="remotetemperaturesensor2",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="remotetemperaturesensor2",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class remotetemperaturesensor2


class RemoteTemperatureSensor3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="remotetemperaturesensor3",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("remotetemperaturesensor3")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "remotetemperaturesensor3":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="remotetemperaturesensor3",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="remotetemperaturesensor3",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="remotetemperaturesensor3",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class remotetemperaturesensor3


class ReeferAlarmType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferalarmtype",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("reeferalarmtype")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "reeferalarmtype":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="reeferalarmtype"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="reeferalarmtype",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="reeferalarmtype",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class reeferalarmtype


class AlarmId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="alarmid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("alarmid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "alarmid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="alarmid"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="alarmid"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="alarmid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class alarmid


class AlarmActive(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="alarmactive",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("alarmactive")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "alarmactive":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="alarmactive"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="alarmactive",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="alarmactive",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class alarmactive


class AlarmDescr(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="alarmdescr",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("alarmdescr")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "alarmdescr":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="alarmdescr"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="alarmdescr"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="alarmdescr",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class alarmdescr


class TransId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="transid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("transid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "transid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="transid"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="transid"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="transid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class transid


class CheckStatus(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, transid=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.transid = transid
        self.transid_nsprefix_ = None

    def get_transid(self):
        return self.transid

    def set_transid(self, transid):
        self.transid = transid

    def _has_content(self):
        if self.transid is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="checkstatus",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("checkstatus")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "checkstatus":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="checkstatus"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="checkstatus",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="checkstatus",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="checkstatus",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.transid is not None:
            namespace_prefix = (
                self.transid_nsprefix_ + ":"
                if (UseCapturedNS and self.transid_nsprefix_)
                else ""
            )
            self.transid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="transid",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "transid":
            obj_ = TransId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transid = obj_
            obj_.original_tagname_ = "transid"


# end class checkstatus


class Mileage(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        mtsn=None,
        asset=None,
        mileagecapable=None,
        mileagesetupstatus=None,
        mileagedetails=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.mtsn = mtsn
        self.mtsn_nsprefix_ = None
        self.asset = asset
        self.asset_nsprefix_ = None
        self.mileagecapable = mileagecapable
        self.mileagecapable_nsprefix_ = None
        self.mileagesetupstatus = mileagesetupstatus
        self.mileagesetupstatus_nsprefix_ = None
        if mileagedetails is None:
            self.mileagedetails = []
        else:
            self.mileagedetails = mileagedetails
        self.mileagedetails_nsprefix_ = None

    def get_mtsn(self):
        return self.mtsn

    def set_mtsn(self, mtsn):
        self.mtsn = mtsn

    def get_asset(self):
        return self.asset

    def set_asset(self, asset):
        self.asset = asset

    def get_mileagecapable(self):
        return self.mileagecapable

    def set_mileagecapable(self, mileagecapable):
        self.mileagecapable = mileagecapable

    def get_mileagesetupstatus(self):
        return self.mileagesetupstatus

    def set_mileagesetupstatus(self, mileagesetupstatus):
        self.mileagesetupstatus = mileagesetupstatus

    def get_mileagedetails(self):
        return self.mileagedetails

    def set_mileagedetails(self, mileagedetails):
        self.mileagedetails = mileagedetails

    def add_mileagedetails(self, value):
        self.mileagedetails.append(value)

    def insert_mileagedetails_at(self, index, value):
        self.mileagedetails.insert(index, value)

    def replace_mileagedetails_at(self, index, value):
        self.mileagedetails[index] = value

    def _has_content(self):
        if (
            self.mtsn is not None
            or self.asset is not None
            or self.mileagecapable is not None
            or self.mileagesetupstatus is not None
            or self.mileagedetails
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileage",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("mileage")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "mileage":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="mileage"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="mileage",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="mileage"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileage",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.mtsn is not None:
            namespace_prefix = (
                self.mtsn_nsprefix_ + ":"
                if (UseCapturedNS and self.mtsn_nsprefix_)
                else ""
            )
            self.mtsn.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="mtsn",
                pretty_print=pretty_print,
            )
        if self.asset is not None:
            namespace_prefix = (
                self.asset_nsprefix_ + ":"
                if (UseCapturedNS and self.asset_nsprefix_)
                else ""
            )
            self.asset.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="asset",
                pretty_print=pretty_print,
            )
        if self.mileagecapable is not None:
            namespace_prefix = (
                self.mileagecapable_nsprefix_ + ":"
                if (UseCapturedNS and self.mileagecapable_nsprefix_)
                else ""
            )
            self.mileagecapable.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="mileagecapable",
                pretty_print=pretty_print,
            )
        if self.mileagesetupstatus is not None:
            namespace_prefix = (
                self.mileagesetupstatus_nsprefix_ + ":"
                if (UseCapturedNS and self.mileagesetupstatus_nsprefix_)
                else ""
            )
            self.mileagesetupstatus.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="mileagesetupstatus",
                pretty_print=pretty_print,
            )
        for mileagedetails_ in self.mileagedetails:
            namespace_prefix = (
                self.mileagedetails_nsprefix_ + ":"
                if (UseCapturedNS and self.mileagedetails_nsprefix_)
                else ""
            )
            mileagedetails_.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="mileagedetails",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "mtsn":
            obj_ = MTSN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mtsn = obj_
            obj_.original_tagname_ = "mtsn"
        elif node_name == "asset":
            obj_ = Asset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asset = obj_
            obj_.original_tagname_ = "asset"
        elif node_name == "mileagecapable":
            obj_ = MileageCapable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mileagecapable = obj_
            obj_.original_tagname_ = "mileagecapable"
        elif node_name == "mileagesetupstatus":
            obj_ = MileageSetupStatus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mileagesetupstatus = obj_
            obj_.original_tagname_ = "mileagesetupstatus"
        elif node_name == "mileagedetails":
            obj_ = MileageDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mileagedetails.append(obj_)
            obj_.original_tagname_ = "mileagedetails"


# end class mileage


class MileageCapable(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileagecapable",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("mileagecapable")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "mileagecapable":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="mileagecapable"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="mileagecapable",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileagecapable",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class mileagecapable


class MileageSetupStatus(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileagesetupstatus",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("mileagesetupstatus")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "mileagesetupstatus":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="mileagesetupstatus",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="mileagesetupstatus",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileagesetupstatus",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class mileagesetupstatus


class MileageDetails(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        mileagedate=None,
        mileageInMiles=None,
        mileageInKM=None,
        timestamp=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.mileagedate = mileagedate
        self.mileagedate_nsprefix_ = None
        self.mileageInMiles = mileageInMiles
        self.mileageInMiles_nsprefix_ = None
        self.mileageInKM = mileageInKM
        self.mileageInKM_nsprefix_ = None
        self.timestamp = timestamp
        self.timestamp_nsprefix_ = None

    def get_mileagedate(self):
        return self.mileagedate

    def set_mileagedate(self, mileagedate):
        self.mileagedate = mileagedate

    def get_mileageInMiles(self):
        return self.mileageInMiles

    def set_mileageInMiles(self, mileageInMiles):
        self.mileageInMiles = mileageInMiles

    def get_mileageInKM(self):
        return self.mileageInKM

    def set_mileageInKM(self, mileageInKM):
        self.mileageInKM = mileageInKM

    def get_timestamp(self):
        return self.timestamp

    def set_timestamp(self, timestamp):
        self.timestamp = timestamp

    def _has_content(self):
        if (
            self.mileagedate is not None
            or self.mileageInMiles is not None
            or self.mileageInKM is not None
            or self.timestamp is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileagedetails",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("mileagedetails")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "mileagedetails":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="mileagedetails"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="mileagedetails",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="mileagedetails",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileagedetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.mileagedate is not None:
            namespace_prefix = (
                self.mileagedate_nsprefix_ + ":"
                if (UseCapturedNS and self.mileagedate_nsprefix_)
                else ""
            )
            self.mileagedate.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="mileagedate",
                pretty_print=pretty_print,
            )
        if self.mileageInMiles is not None:
            namespace_prefix = (
                self.mileageInMiles_nsprefix_ + ":"
                if (UseCapturedNS and self.mileageInMiles_nsprefix_)
                else ""
            )
            self.mileageInMiles.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="mileageInMiles",
                pretty_print=pretty_print,
            )
        if self.mileageInKM is not None:
            namespace_prefix = (
                self.mileageInKM_nsprefix_ + ":"
                if (UseCapturedNS and self.mileageInKM_nsprefix_)
                else ""
            )
            self.mileageInKM.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="mileageInKM",
                pretty_print=pretty_print,
            )
        if self.timestamp is not None:
            namespace_prefix = (
                self.timestamp_nsprefix_ + ":"
                if (UseCapturedNS and self.timestamp_nsprefix_)
                else ""
            )
            self.timestamp.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="timestamp",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "mileagedate":
            obj_ = MileageDate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mileagedate = obj_
            obj_.original_tagname_ = "mileagedate"
        elif node_name == "mileageInMiles":
            obj_ = MileageInMiles.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mileageInMiles = obj_
            obj_.original_tagname_ = "mileageInMiles"
        elif node_name == "mileageInKM":
            obj_ = MileageInKM.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mileageInKM = obj_
            obj_.original_tagname_ = "mileageInKM"
        elif node_name == "timestamp":
            obj_ = Timestamp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timestamp = obj_
            obj_.original_tagname_ = "timestamp"


# end class mileagedetails


class MileageDate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileagedate",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("mileagedate")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "mileagedate":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="mileagedate"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="mileagedate",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileagedate",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class mileagedate


class MileageInMiles(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileageInMiles",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("mileageInMiles")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "mileageInMiles":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="mileageInMiles"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="mileageInMiles",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileageInMiles",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class mileageInMiles


class MileageInKM(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileageInKM",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("mileageInKM")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "mileageInKM":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="mileageInKM"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="mileageInKM",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="mileageInKM",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class mileageInKM


class Timestamp(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="timestamp",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("timestamp")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "timestamp":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="timestamp"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="timestamp"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="timestamp",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class timestamp


class VolumetricData(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        volserialdata=None,
        skycamera_plan_type=None,
        nearly_empty=None,
        volevent=None,
        voltimeofreading=None,
        voltimeofreading_iso8601=None,
        cube=None,
        floorspace=None,
        emptynoncargo=None,
        triggeredby=None,
        imagelink=None,
        imagetime=None,
        imagetime_iso8601=None,
        imagelocation=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.volserialdata = volserialdata
        self.volserialdata_nsprefix_ = None
        self.skycamera_plan_type = skycamera_plan_type
        self.skycamera_plan_type_nsprefix_ = None
        self.nearly_empty = nearly_empty
        self.nearly_empty_nsprefix_ = None
        self.volevent = volevent
        self.volevent_nsprefix_ = None
        self.voltimeofreading = voltimeofreading
        self.voltimeofreading_nsprefix_ = None
        self.voltimeofreading_iso8601 = voltimeofreading_iso8601
        self.voltimeofreading_iso8601_nsprefix_ = None
        self.cube = cube
        self.cube_nsprefix_ = None
        self.floorspace = floorspace
        self.floorspace_nsprefix_ = None
        self.emptynoncargo = emptynoncargo
        self.emptynoncargo_nsprefix_ = None
        self.triggeredby = triggeredby
        self.triggeredby_nsprefix_ = None
        self.imagelink = imagelink
        self.imagelink_nsprefix_ = None
        self.imagetime = imagetime
        self.imagetime_nsprefix_ = None
        self.imagetime_iso8601 = imagetime_iso8601
        self.imagetime_iso8601_nsprefix_ = None
        self.imagelocation = imagelocation
        self.imagelocation_nsprefix_ = None

    def get_volserialdata(self):
        return self.volserialdata

    def set_volserialdata(self, volserialdata):
        self.volserialdata = volserialdata

    def get_skycamera_plan_type(self):
        return self.skycamera_plan_type

    def set_skycamera_plan_type(self, skycamera_plan_type):
        self.skycamera_plan_type = skycamera_plan_type

    def get_nearly_empty(self):
        return self.nearly_empty

    def set_nearly_empty(self, nearly_empty):
        self.nearly_empty = nearly_empty

    def get_volevent(self):
        return self.volevent

    def set_volevent(self, volevent):
        self.volevent = volevent

    def get_voltimeofreading(self):
        return self.voltimeofreading

    def set_voltimeofreading(self, voltimeofreading):
        self.voltimeofreading = voltimeofreading

    def get_voltimeofreading_iso8601(self):
        return self.voltimeofreading_iso8601

    def set_voltimeofreading_iso8601(self, voltimeofreading_iso8601):
        self.voltimeofreading_iso8601 = voltimeofreading_iso8601

    def get_cube(self):
        return self.cube

    def set_cube(self, cube):
        self.cube = cube

    def get_floorspace(self):
        return self.floorspace

    def set_floorspace(self, floorspace):
        self.floorspace = floorspace

    def get_emptynoncargo(self):
        return self.emptynoncargo

    def set_emptynoncargo(self, emptynoncargo):
        self.emptynoncargo = emptynoncargo

    def get_triggeredby(self):
        return self.triggeredby

    def set_triggeredby(self, triggeredby):
        self.triggeredby = triggeredby

    def get_imagelink(self):
        return self.imagelink

    def set_imagelink(self, imagelink):
        self.imagelink = imagelink

    def get_imagetime(self):
        return self.imagetime

    def set_imagetime(self, imagetime):
        self.imagetime = imagetime

    def get_imagetime_iso8601(self):
        return self.imagetime_iso8601

    def set_imagetime_iso8601(self, imagetime_iso8601):
        self.imagetime_iso8601 = imagetime_iso8601

    def get_imagelocation(self):
        return self.imagelocation

    def set_imagelocation(self, imagelocation):
        self.imagelocation = imagelocation

    def _has_content(self):
        if (
            self.volserialdata is not None
            or self.skycamera_plan_type is not None
            or self.nearly_empty is not None
            or self.volevent is not None
            or self.voltimeofreading is not None
            or self.voltimeofreading_iso8601 is not None
            or self.cube is not None
            or self.floorspace is not None
            or self.emptynoncargo is not None
            or self.triggeredby is not None
            or self.imagelink is not None
            or self.imagetime is not None
            or self.imagetime_iso8601 is not None
            or self.imagelocation is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="volumetricdata",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("volumetricdata")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "volumetricdata":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="volumetricdata"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="volumetricdata",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="volumetricdata",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="volumetricdata",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.volserialdata is not None:
            namespace_prefix = (
                self.volserialdata_nsprefix_ + ":"
                if (UseCapturedNS and self.volserialdata_nsprefix_)
                else ""
            )
            self.volserialdata.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="volserialdata",
                pretty_print=pretty_print,
            )
        if self.skycamera_plan_type is not None:
            namespace_prefix = (
                self.skycamera_plan_type_nsprefix_ + ":"
                if (UseCapturedNS and self.skycamera_plan_type_nsprefix_)
                else ""
            )
            self.skycamera_plan_type.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="skycamera_plan_type",
                pretty_print=pretty_print,
            )
        if self.nearly_empty is not None:
            namespace_prefix = (
                self.nearly_empty_nsprefix_ + ":"
                if (UseCapturedNS and self.nearly_empty_nsprefix_)
                else ""
            )
            self.nearly_empty.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="nearly_empty",
                pretty_print=pretty_print,
            )
        if self.volevent is not None:
            namespace_prefix = (
                self.volevent_nsprefix_ + ":"
                if (UseCapturedNS and self.volevent_nsprefix_)
                else ""
            )
            self.volevent.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="volevent",
                pretty_print=pretty_print,
            )
        if self.voltimeofreading is not None:
            namespace_prefix = (
                self.voltimeofreading_nsprefix_ + ":"
                if (UseCapturedNS and self.voltimeofreading_nsprefix_)
                else ""
            )
            self.voltimeofreading.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="voltimeofreading",
                pretty_print=pretty_print,
            )
        if self.voltimeofreading_iso8601 is not None:
            namespace_prefix = (
                self.voltimeofreading_iso8601_nsprefix_ + ":"
                if (UseCapturedNS and self.voltimeofreading_iso8601_nsprefix_)
                else ""
            )
            self.voltimeofreading_iso8601.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="voltimeofreading-iso8601",
                pretty_print=pretty_print,
            )
        if self.cube is not None:
            namespace_prefix = (
                self.cube_nsprefix_ + ":"
                if (UseCapturedNS and self.cube_nsprefix_)
                else ""
            )
            self.cube.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="cube",
                pretty_print=pretty_print,
            )
        if self.floorspace is not None:
            namespace_prefix = (
                self.floorspace_nsprefix_ + ":"
                if (UseCapturedNS and self.floorspace_nsprefix_)
                else ""
            )
            self.floorspace.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="floorspace",
                pretty_print=pretty_print,
            )
        if self.emptynoncargo is not None:
            namespace_prefix = (
                self.emptynoncargo_nsprefix_ + ":"
                if (UseCapturedNS and self.emptynoncargo_nsprefix_)
                else ""
            )
            self.emptynoncargo.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="emptynoncargo",
                pretty_print=pretty_print,
            )
        if self.triggeredby is not None:
            namespace_prefix = (
                self.triggeredby_nsprefix_ + ":"
                if (UseCapturedNS and self.triggeredby_nsprefix_)
                else ""
            )
            self.triggeredby.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="triggeredby",
                pretty_print=pretty_print,
            )
        if self.imagelink is not None:
            namespace_prefix = (
                self.imagelink_nsprefix_ + ":"
                if (UseCapturedNS and self.imagelink_nsprefix_)
                else ""
            )
            self.imagelink.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagelink",
                pretty_print=pretty_print,
            )
        if self.imagetime is not None:
            namespace_prefix = (
                self.imagetime_nsprefix_ + ":"
                if (UseCapturedNS and self.imagetime_nsprefix_)
                else ""
            )
            self.imagetime.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagetime",
                pretty_print=pretty_print,
            )
        if self.imagetime_iso8601 is not None:
            namespace_prefix = (
                self.imagetime_iso8601_nsprefix_ + ":"
                if (UseCapturedNS and self.imagetime_iso8601_nsprefix_)
                else ""
            )
            self.imagetime_iso8601.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagetime-iso8601",
                pretty_print=pretty_print,
            )
        if self.imagelocation is not None:
            namespace_prefix = (
                self.imagelocation_nsprefix_ + ":"
                if (UseCapturedNS and self.imagelocation_nsprefix_)
                else ""
            )
            self.imagelocation.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagelocation",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "volserialdata":
            obj_ = VolSerialData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.volserialdata = obj_
            obj_.original_tagname_ = "volserialdata"
        elif node_name == "skycamera_plan_type":
            obj_ = SkyCameraPlanType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.skycamera_plan_type = obj_
            obj_.original_tagname_ = "skycamera_plan_type"
        elif node_name == "nearly_empty":
            obj_ = NearlyEmpty.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nearly_empty = obj_
            obj_.original_tagname_ = "nearly_empty"
        elif node_name == "volevent":
            obj_ = VolEvent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.volevent = obj_
            obj_.original_tagname_ = "volevent"
        elif node_name == "voltimeofreading":
            obj_ = VolTimeOfReading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.voltimeofreading = obj_
            obj_.original_tagname_ = "voltimeofreading"
        elif node_name == "voltimeofreading-iso8601":
            obj_ = VolTimeOfReadingISO8601.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.voltimeofreading_iso8601 = obj_
            obj_.original_tagname_ = "voltimeofreading-iso8601"
        elif node_name == "cube":
            obj_ = Cube.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cube = obj_
            obj_.original_tagname_ = "cube"
        elif node_name == "floorspace":
            obj_ = FloorSpace.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.floorspace = obj_
            obj_.original_tagname_ = "floorspace"
        elif node_name == "emptynoncargo":
            obj_ = EmptyNonCargo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.emptynoncargo = obj_
            obj_.original_tagname_ = "emptynoncargo"
        elif node_name == "triggeredby":
            obj_ = TriggeredBy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.triggeredby = obj_
            obj_.original_tagname_ = "triggeredby"
        elif node_name == "imagelink":
            obj_ = ImageLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagelink = obj_
            obj_.original_tagname_ = "imagelink"
        elif node_name == "imagetime":
            obj_ = ImageTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagetime = obj_
            obj_.original_tagname_ = "imagetime"
        elif node_name == "imagetime-iso8601":
            obj_ = ImageTimeISO8601.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagetime_iso8601 = obj_
            obj_.original_tagname_ = "imagetime-iso8601"
        elif node_name == "imagelocation":
            obj_ = ImageLocation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagelocation = obj_
            obj_.original_tagname_ = "imagelocation"


# end class volumetricdata


class VolSerialData(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="volserialdata",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("volserialdata")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "volserialdata":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="volserialdata"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="volserialdata",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="volserialdata",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class volserialdata


class VolEvent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="volevent",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("volevent")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "volevent":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="volevent"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="volevent"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="volevent",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class volevent


class VolTimeOfReading(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="voltimeofreading",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("voltimeofreading")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "voltimeofreading":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="voltimeofreading",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="voltimeofreading",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="voltimeofreading",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class voltimeofreading


class VolTimeOfReadingISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="voltimeofreading-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("voltimeofreading-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "voltimeofreading-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="voltimeofreading-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="voltimeofreading-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="voltimeofreading-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class voltimeofreading_iso8601


class Cube(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="cube",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("cube")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "cube":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="cube"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="cube"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="cube",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class cube


class FloorSpace(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="floorspace",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("floorspace")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "floorspace":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="floorspace"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="floorspace"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="floorspace",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class floorspace


class EmptyNonCargo(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="emptynoncargo",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("emptynoncargo")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "emptynoncargo":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="emptynoncargo"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="emptynoncargo",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="emptynoncargo",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class emptynoncargo


class TriggeredBy(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="triggeredby",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("triggeredby")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "triggeredby":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="triggeredby"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="triggeredby",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="triggeredby",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class triggeredby


class ImageLink(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelink",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagelink")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagelink":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="imagelink"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="imagelink"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelink",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagelink


class ImageTime(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagetime",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagetime")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagetime":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="imagetime"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="imagetime"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagetime",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagetime


class ImageTimeISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagetime-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagetime-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagetime-iso8601":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="imagetime-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="imagetime-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagetime-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagetime_iso8601


class ImageLocation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        imagegeoname=None,
        imagelocationid=None,
        imagecity=None,
        imagestate=None,
        imagecountry=None,
        imagepostal=None,
        imagelat=None,
        imagelon=None,
        imagelat_iso6709=None,
        imagelon_iso6709=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.imagegeoname = imagegeoname
        self.imagegeoname_nsprefix_ = None
        self.imagelocationid = imagelocationid
        self.imagelocationid_nsprefix_ = None
        self.imagecity = imagecity
        self.imagecity_nsprefix_ = None
        self.imagestate = imagestate
        self.imagestate_nsprefix_ = None
        self.imagecountry = imagecountry
        self.imagecountry_nsprefix_ = None
        self.imagepostal = imagepostal
        self.imagepostal_nsprefix_ = None
        self.imagelat = imagelat
        self.imagelat_nsprefix_ = None
        self.imagelon = imagelon
        self.imagelon_nsprefix_ = None
        self.imagelat_iso6709 = imagelat_iso6709
        self.imagelat_iso6709_nsprefix_ = None
        self.imagelon_iso6709 = imagelon_iso6709
        self.imagelon_iso6709_nsprefix_ = None

    def get_imagegeoname(self):
        return self.imagegeoname

    def set_imagegeoname(self, imagegeoname):
        self.imagegeoname = imagegeoname

    def get_imagelocationid(self):
        return self.imagelocationid

    def set_imagelocationid(self, imagelocationid):
        self.imagelocationid = imagelocationid

    def get_imagecity(self):
        return self.imagecity

    def set_imagecity(self, imagecity):
        self.imagecity = imagecity

    def get_imagestate(self):
        return self.imagestate

    def set_imagestate(self, imagestate):
        self.imagestate = imagestate

    def get_imagecountry(self):
        return self.imagecountry

    def set_imagecountry(self, imagecountry):
        self.imagecountry = imagecountry

    def get_imagepostal(self):
        return self.imagepostal

    def set_imagepostal(self, imagepostal):
        self.imagepostal = imagepostal

    def get_imagelat(self):
        return self.imagelat

    def set_imagelat(self, imagelat):
        self.imagelat = imagelat

    def get_imagelon(self):
        return self.imagelon

    def set_imagelon(self, imagelon):
        self.imagelon = imagelon

    def get_imagelat_iso6709(self):
        return self.imagelat_iso6709

    def set_imagelat_iso6709(self, imagelat_iso6709):
        self.imagelat_iso6709 = imagelat_iso6709

    def get_imagelon_iso6709(self):
        return self.imagelon_iso6709

    def set_imagelon_iso6709(self, imagelon_iso6709):
        self.imagelon_iso6709 = imagelon_iso6709

    def _has_content(self):
        if (
            self.imagegeoname is not None
            or self.imagelocationid is not None
            or self.imagecity is not None
            or self.imagestate is not None
            or self.imagecountry is not None
            or self.imagepostal is not None
            or self.imagelat is not None
            or self.imagelon is not None
            or self.imagelat_iso6709 is not None
            or self.imagelon_iso6709 is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelocation",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagelocation")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagelocation":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="imagelocation"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="imagelocation",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="imagelocation",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelocation",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.imagegeoname is not None:
            namespace_prefix = (
                self.imagegeoname_nsprefix_ + ":"
                if (UseCapturedNS and self.imagegeoname_nsprefix_)
                else ""
            )
            self.imagegeoname.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagegeoname",
                pretty_print=pretty_print,
            )
        if self.imagelocationid is not None:
            namespace_prefix = (
                self.imagelocationid_nsprefix_ + ":"
                if (UseCapturedNS and self.imagelocationid_nsprefix_)
                else ""
            )
            self.imagelocationid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagelocationid",
                pretty_print=pretty_print,
            )
        if self.imagecity is not None:
            namespace_prefix = (
                self.imagecity_nsprefix_ + ":"
                if (UseCapturedNS and self.imagecity_nsprefix_)
                else ""
            )
            self.imagecity.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagecity",
                pretty_print=pretty_print,
            )
        if self.imagestate is not None:
            namespace_prefix = (
                self.imagestate_nsprefix_ + ":"
                if (UseCapturedNS and self.imagestate_nsprefix_)
                else ""
            )
            self.imagestate.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagestate",
                pretty_print=pretty_print,
            )
        if self.imagecountry is not None:
            namespace_prefix = (
                self.imagecountry_nsprefix_ + ":"
                if (UseCapturedNS and self.imagecountry_nsprefix_)
                else ""
            )
            self.imagecountry.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagecountry",
                pretty_print=pretty_print,
            )
        if self.imagepostal is not None:
            namespace_prefix = (
                self.imagepostal_nsprefix_ + ":"
                if (UseCapturedNS and self.imagepostal_nsprefix_)
                else ""
            )
            self.imagepostal.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagepostal",
                pretty_print=pretty_print,
            )
        if self.imagelat is not None:
            namespace_prefix = (
                self.imagelat_nsprefix_ + ":"
                if (UseCapturedNS and self.imagelat_nsprefix_)
                else ""
            )
            self.imagelat.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagelat",
                pretty_print=pretty_print,
            )
        if self.imagelon is not None:
            namespace_prefix = (
                self.imagelon_nsprefix_ + ":"
                if (UseCapturedNS and self.imagelon_nsprefix_)
                else ""
            )
            self.imagelon.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagelon",
                pretty_print=pretty_print,
            )
        if self.imagelat_iso6709 is not None:
            namespace_prefix = (
                self.imagelat_iso6709_nsprefix_ + ":"
                if (UseCapturedNS and self.imagelat_iso6709_nsprefix_)
                else ""
            )
            self.imagelat_iso6709.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagelat-iso6709",
                pretty_print=pretty_print,
            )
        if self.imagelon_iso6709 is not None:
            namespace_prefix = (
                self.imagelon_iso6709_nsprefix_ + ":"
                if (UseCapturedNS and self.imagelon_iso6709_nsprefix_)
                else ""
            )
            self.imagelon_iso6709.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="imagelon-iso6709",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "imagegeoname":
            obj_ = ImageGeoName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagegeoname = obj_
            obj_.original_tagname_ = "imagegeoname"
        elif node_name == "imagelocationid":
            obj_ = ImageLocationId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagelocationid = obj_
            obj_.original_tagname_ = "imagelocationid"
        elif node_name == "imagecity":
            obj_ = ImageCity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagecity = obj_
            obj_.original_tagname_ = "imagecity"
        elif node_name == "imagestate":
            obj_ = ImageState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagestate = obj_
            obj_.original_tagname_ = "imagestate"
        elif node_name == "imagecountry":
            obj_ = ImageCountry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagecountry = obj_
            obj_.original_tagname_ = "imagecountry"
        elif node_name == "imagepostal":
            obj_ = ImagePostal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagepostal = obj_
            obj_.original_tagname_ = "imagepostal"
        elif node_name == "imagelat":
            obj_ = ImageLat.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagelat = obj_
            obj_.original_tagname_ = "imagelat"
        elif node_name == "imagelon":
            obj_ = ImageLon.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagelon = obj_
            obj_.original_tagname_ = "imagelon"
        elif node_name == "imagelat-iso6709":
            obj_ = ImageLatISO6709.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagelat_iso6709 = obj_
            obj_.original_tagname_ = "imagelat-iso6709"
        elif node_name == "imagelon-iso6709":
            obj_ = ImageLonISO6709.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imagelon_iso6709 = obj_
            obj_.original_tagname_ = "imagelon-iso6709"


# end class imagelocation


class ImageGeoName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagegeoname",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagegeoname")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagegeoname":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="imagegeoname"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="imagegeoname",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagegeoname",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagegeoname


class ImageLocationId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelocationid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagelocationid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagelocationid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="imagelocationid"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="imagelocationid",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelocationid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagelocationid


class ImageCity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagecity",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagecity")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagecity":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="imagecity"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="imagecity"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagecity",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagecity


class ImageState(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagestate",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagestate")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagestate":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="imagestate"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="imagestate"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagestate",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagestate


class ImagePostal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagepostal",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagepostal")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagepostal":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="imagepostal"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="imagepostal",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagepostal",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagepostal


class ImageCountry(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagecountry",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagecountry")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagecountry":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="imagecountry"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="imagecountry",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagecountry",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagecountry


class ImageLat(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelat",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagelat")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagelat":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="imagelat"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="imagelat"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelat",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagelat


class ImageLon(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelon",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagelon")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagelon":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="imagelon"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="imagelon"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelon",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagelon


class ImageLatISO6709(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelat-iso6709",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagelat-iso6709")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagelat-iso6709":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="imagelat-iso6709",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="imagelat-iso6709",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelat-iso6709",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagelat_iso6709


class ImageLonISO6709(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelon-iso6709",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("imagelon-iso6709")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "imagelon-iso6709":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="imagelon-iso6709",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="imagelon-iso6709",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="imagelon-iso6709",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class imagelon_iso6709


class SkyCameraPlanType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="skycamera_plan_type",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("skycamera_plan_type")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "skycamera_plan_type":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="skycamera_plan_type",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="skycamera_plan_type",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="skycamera_plan_type",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class skycamera_plan_type


class NearlyEmpty(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="nearly_empty",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("nearly_empty")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "nearly_empty":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="nearly_empty"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="nearly_empty",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="nearly_empty",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class nearly_empty


class SkyFence(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        skyfencestatus=None,
        departureskyfence=None,
        departurelocationid=None,
        arrivalskyfence=None,
        arrivallocationid=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.skyfencestatus = skyfencestatus
        self.skyfencestatus_nsprefix_ = None
        self.departureskyfence = departureskyfence
        self.departureskyfence_nsprefix_ = None
        self.departurelocationid = departurelocationid
        self.departurelocationid_nsprefix_ = None
        self.arrivalskyfence = arrivalskyfence
        self.arrivalskyfence_nsprefix_ = None
        self.arrivallocationid = arrivallocationid
        self.arrivallocationid_nsprefix_ = None

    def get_skyfencestatus(self):
        return self.skyfencestatus

    def set_skyfencestatus(self, skyfencestatus):
        self.skyfencestatus = skyfencestatus

    def get_departureskyfence(self):
        return self.departureskyfence

    def set_departureskyfence(self, departureskyfence):
        self.departureskyfence = departureskyfence

    def get_departurelocationid(self):
        return self.departurelocationid

    def set_departurelocationid(self, departurelocationid):
        self.departurelocationid = departurelocationid

    def get_arrivalskyfence(self):
        return self.arrivalskyfence

    def set_arrivalskyfence(self, arrivalskyfence):
        self.arrivalskyfence = arrivalskyfence

    def get_arrivallocationid(self):
        return self.arrivallocationid

    def set_arrivallocationid(self, arrivallocationid):
        self.arrivallocationid = arrivallocationid

    def _has_content(self):
        if (
            self.skyfencestatus is not None
            or self.departureskyfence is not None
            or self.departurelocationid is not None
            or self.arrivalskyfence is not None
            or self.arrivallocationid is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="skyfence",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("skyfence")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "skyfence":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="skyfence"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="skyfence",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self, outfile, level, already_processed, namespace_prefix="", name_="skyfence"
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="skyfence",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.skyfencestatus is not None:
            namespace_prefix = (
                self.skyfencestatus_nsprefix_ + ":"
                if (UseCapturedNS and self.skyfencestatus_nsprefix_)
                else ""
            )
            self.skyfencestatus.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="skyfencestatus",
                pretty_print=pretty_print,
            )
        if self.departureskyfence is not None:
            namespace_prefix = (
                self.departureskyfence_nsprefix_ + ":"
                if (UseCapturedNS and self.departureskyfence_nsprefix_)
                else ""
            )
            self.departureskyfence.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departureskyfence",
                pretty_print=pretty_print,
            )
        if self.departurelocationid is not None:
            namespace_prefix = (
                self.departurelocationid_nsprefix_ + ":"
                if (UseCapturedNS and self.departurelocationid_nsprefix_)
                else ""
            )
            self.departurelocationid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="departurelocationid",
                pretty_print=pretty_print,
            )
        if self.arrivalskyfence is not None:
            namespace_prefix = (
                self.arrivalskyfence_nsprefix_ + ":"
                if (UseCapturedNS and self.arrivalskyfence_nsprefix_)
                else ""
            )
            self.arrivalskyfence.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="arrivalskyfence",
                pretty_print=pretty_print,
            )
        if self.arrivallocationid is not None:
            namespace_prefix = (
                self.arrivallocationid_nsprefix_ + ":"
                if (UseCapturedNS and self.arrivallocationid_nsprefix_)
                else ""
            )
            self.arrivallocationid.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="arrivallocationid",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "skyfencestatus":
            obj_ = SkyFenceStatus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.skyfencestatus = obj_
            obj_.original_tagname_ = "skyfencestatus"
        elif node_name == "departureskyfence":
            obj_ = DepartureSkyFence.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departureskyfence = obj_
            obj_.original_tagname_ = "departureskyfence"
        elif node_name == "departurelocationid":
            obj_ = DepartureLocationId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departurelocationid = obj_
            obj_.original_tagname_ = "departurelocationid"
        elif node_name == "arrivalskyfence":
            obj_ = ArrivalSkyFence.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arrivalskyfence = obj_
            obj_.original_tagname_ = "arrivalskyfence"
        elif node_name == "arrivallocationid":
            obj_ = ArrivalLocationId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arrivallocationid = obj_
            obj_.original_tagname_ = "arrivallocationid"


# end class skyfence


class SkyFenceStatus(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="skyfencestatus",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("skyfencestatus")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "skyfencestatus":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="skyfencestatus"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="skyfencestatus",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="skyfencestatus",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class skyfencestatus


class DepartureSkyFence(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departureskyfence",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("departureskyfence")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "departureskyfence":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="departureskyfence",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="departureskyfence",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="departureskyfence",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class departureskyfence


class ArrivalSkyFence(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="arrivalskyfence",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("arrivalskyfence")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "arrivalskyfence":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="arrivalskyfence"
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="arrivalskyfence",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="arrivalskyfence",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class arrivalskyfence


class ArrivalLocationId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="arrivallocationid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("arrivallocationid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "arrivallocationid":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="arrivallocationid",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="arrivallocationid",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="arrivallocationid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class arrivallocationid


class TotalMileage(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        mtsn=None,
        asset=None,
        totaldevicemileage=None,
        timestamp=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.mtsn = mtsn
        self.mtsn_nsprefix_ = None
        self.asset = asset
        self.asset_nsprefix_ = None
        self.totaldevicemileage = totaldevicemileage
        self.totaldevicemileage_nsprefix_ = None
        self.timestamp = timestamp
        self.timestamp_nsprefix_ = None

    def get_mtsn(self):
        return self.mtsn

    def set_mtsn(self, mtsn):
        self.mtsn = mtsn

    def get_asset(self):
        return self.asset

    def set_asset(self, asset):
        self.asset = asset

    def get_totaldevicemileage(self):
        return self.totaldevicemileage

    def set_totaldevicemileage(self, totaldevicemileage):
        self.totaldevicemileage = totaldevicemileage

    def get_timestamp(self):
        return self.timestamp

    def set_timestamp(self, timestamp):
        self.timestamp = timestamp

    def _has_content(self):
        if (
            self.mtsn is not None
            or self.asset is not None
            or self.totaldevicemileage is not None
            or self.timestamp is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="totalmileage",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("totalmileage")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "totalmileage":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile, level, already_processed, namespace_prefix, name_="totalmileage"
        )
        if self._has_content():
            outfile.write(">%s" % (eol_,))
            self._export_attributes(
                outfile,
                level + 1,
                namespace_prefix,
                namespacedef_,
                name_="totalmileage",
                pretty_print=pretty_print,
            )
            show_indent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="totalmileage",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="totalmileage",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.mtsn is not None:
            namespace_prefix = (
                self.mtsn_nsprefix_ + ":"
                if (UseCapturedNS and self.mtsn_nsprefix_)
                else ""
            )
            self.mtsn.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="mtsn",
                pretty_print=pretty_print,
            )
        if self.asset is not None:
            namespace_prefix = (
                self.asset_nsprefix_ + ":"
                if (UseCapturedNS and self.asset_nsprefix_)
                else ""
            )
            self.asset.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="asset",
                pretty_print=pretty_print,
            )
        if self.totaldevicemileage is not None:
            namespace_prefix = (
                self.totaldevicemileage_nsprefix_ + ":"
                if (UseCapturedNS and self.totaldevicemileage_nsprefix_)
                else ""
            )
            self.totaldevicemileage.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="totaldevicemileage",
                pretty_print=pretty_print,
            )
        if self.timestamp is not None:
            namespace_prefix = (
                self.timestamp_nsprefix_ + ":"
                if (UseCapturedNS and self.timestamp_nsprefix_)
                else ""
            )
            self.timestamp.export(
                outfile,
                level,
                namespace_prefix="t:",
                namespacedef_="",
                name_="timestamp",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if node_name == "mtsn":
            obj_ = MTSN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mtsn = obj_
            obj_.original_tagname_ = "mtsn"
        elif node_name == "asset":
            obj_ = Asset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asset = obj_
            obj_.original_tagname_ = "asset"
        elif node_name == "totaldevicemileage":
            obj_ = TotalDeviceMileage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.totaldevicemileage = obj_
            obj_.original_tagname_ = "totaldevicemileage"
        elif node_name == "timestamp":
            obj_ = Timestamp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timestamp = obj_
            obj_.original_tagname_ = "timestamp"


# end class totalmileage


class MessageReceivedTime(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="messagereceivedtime",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("messagereceivedtime")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "messagereceivedtime":
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="messagereceivedtime",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="messagereceivedtime",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="messagereceivedtime",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class messagereceivedtime


class MessageReceivedTimeISO8601(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        value=None,
        mixedclass_=None,
        content_=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.value = value

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def _has_content(self):
        if (1 if type(self.value) in [int, float] else self.value) or self.content_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="messagereceivedtime-iso8601",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs.get("messagereceivedtime-iso8601")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "messagereceivedtime-iso8601"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS and self.ns_prefix_:
            namespace_prefix = self.ns_prefix_ + ":"
        show_indent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespace_prefix,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._export_attributes(
            outfile,
            level,
            already_processed,
            namespace_prefix,
            name_="messagereceivedtime-iso8601",
        )
        outfile.write(">")
        self._export_attributes(
            outfile,
            level + 1,
            namespace_prefix,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.value))
        outfile.write("</%s%s>%s" % (namespace_prefix, name_, eol_))

    def _export_attributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_prefix="",
        name_="messagereceivedtime-iso8601",
    ):
        pass

    def _export_attributes(
        self,
        outfile,
        level,
        namespace_prefix="",
        namespacedef_='xmlns:t="http://www.w3.org/namespace/"',
        name_="messagereceivedtime-iso8601",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._build_attributes(node, node.attrib, already_processed)
        self.value = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", node.text
            )
            self.content_.append(obj_)
        for child in node:
            node_name = TagPattern.match(child.tag).groups()[-1]
            self._build_children(child, node, node_name, gds_collector_=gds_collector_)
        return self

    def _build_attributes(self, node, attrs, already_processed):
        pass

    def _build_children(
        self, child_, node, node_name, fromsubclass_=False, gds_collector_=None
    ):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(
                MixedContainer.CategoryText, MixedContainer.TypeNone, "", child_.tail
            )
            self.content_.append(obj_)
        pass


# end class messagereceivedtime_iso8601

# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {"http://www.w3.org/namespace/": []}

__all__ = [
    "AcctId",
    "ActivationStatus",
    "ActiveProfileSlotNumber",
    "Address",
    "AgreementType",
    "AlarmActive",
    "AlarmDescr",
    "AlarmId",
    "AmbientTemperature",
    "ArrivalLocationId",
    "ArrivalSkyFence",
    "Asset",
    "AssetBatteryVoltage",
    "AssetId",
    "AssetType",
    "AssetTypeAttr",
    "AssetTypeAttrName",
    "AssetTypeAttrVal",
    "AssetTypeBase",
    "AssetTypeDef",
    "AssociatedDTTM",
    "AssociatedDTTMISO8601",
    "ATS",
    "BatchNum",
    "Battery",
    "Binary",
    "BranchName",
    "CheckStatus",
    "City",
    "Container",
    "ContainerId",
    "ContentType",
    "ControllerOn",
    "Country",
    "Cube",
    "CustomAssetType",
    "DepartureCity",
    "DepartureCountry",
    "DepartureDistance",
    "DepartureGeoName",
    "DepartureLandMark",
    "DepartureLatitude",
    "DepartureLatitudeISO6709",
    "DepartureLocation",
    "DepartureLocationId",
    "DepartureLongitude",
    "DepartureLongitudeISO6709",
    "DeparturePostal",
    "DepartureSkyFence",
    "DepartureState",
    "DepartureTime",
    "DepartureTimeISO8601",
    "DeviceType",
    "Direction",
    "Distance",
    "DoorStateOpen",
    "DoorSwitchOpen",
    "DTTSStatus",
    "EHCounter",
    "EHMeter",
    "EmptyNonCargo",
    "EngineMode",
    "EngineOn",
    "EngineRunHours",
    "EngineSize",
    "EngineSpeed",
    "EngineStandByHours",
    "EngineSwitchOnHours",
    "EPMFlag",
    "Error",
    "Event",
    "Expiration",
    "ExpirationISO8601",
    "ExtPwr",
    "FloorSpace",
    "FuelPercent",
    "GeoName",
    "GeoShape",
    "GeoTypeName",
    "GLS",
    "GroupName",
    "Groups",
    "Heading",
    "HeadingInDegrees",
    "Idle",
    "IdleDuration",
    "IdleGap",
    "IdleStatus",
    "ImageCity",
    "ImageCountry",
    "ImageGeoName",
    "ImageLat",
    "ImageLatISO6709",
    "ImageLink",
    "ImageLocation",
    "ImageLocationId",
    "ImageLon",
    "ImageLonISO6709",
    "ImagePostal",
    "ImageState",
    "ImageTime",
    "ImageTimeISO8601",
    "InputId",
    "InputName",
    "InputState",
    "InputVal",
    "InstallCity",
    "InstallCountry",
    "InstallDate",
    "InstallDateISO8601",
    "InstallDistance",
    "InstallGeoName",
    "InstallLandMark",
    "InstallLatitude",
    "InstallLatitudeISO6709",
    "InstallLocation",
    "InstallLocationId",
    "InstallLongitude",
    "InstallLongitudeISO6709",
    "InstallState",
    "InstallTime",
    "InstallTimeISO8601",
    "InterfaceType",
    "JourneyDistance",
    "LandMark",
    "LastUpdate",
    "LastUpdateISO8601",
    "Latitude",
    "LatitudeISO6709",
    "Lessee",
    "LesseesCac",
    "Lessor",
    "LessorsCac",
    "LocationId",
    "LocationIds",
    "Longitude",
    "LongitudeISO6709",
    "LSD",
    "Meridian",
    "MessageReceivedTime",
    "MessageReceivedTimeISO8601",
    "MessageType",
    "Mileage",
    "MileageInKM",
    "MileageInMiles",
    "MileageCapable",
    "MileageDate",
    "MileageDetails",
    "MileageSetupStatus",
    "ModeZone1",
    "ModeZone2",
    "ModeZone3",
    "MTSN",
    "NearlyEmpty",
    "NextAction",
    "NextActionISO8601",
    "Note",
    "Owner",
    "OwnersCac",
    "Postal",
    "Profile",
    "ProfileId",
    "ProfileNum",
    "ProfilePwr",
    "ProfileStatus",
    "ProfileType",
    "Quality",
    "Range",
    "ReeferAlarm",
    "ReeferAlarmStatus",
    "ReeferAlarmType",
    "ReeferMake",
    "ReeferOperatingStatus",
    "ReeferRemoteTemperatureSensor1",
    "ReeferRemoteTemperatureSensor2",
    "ReeferRemoteTemperatureSensor3",
    "ReeferState",
    "RemoteSwitch1Open",
    "RemoteSwitch2Open",
    "RemoteTemperatureSensor1",
    "RemoteTemperatureSensor2",
    "RemoteTemperatureSensor3",
    "ReturnAirTemperatureZone1",
    "ReturnAirTemperatureZone2",
    "ReturnAirTemperatureZone3",
    "SCac",
    "SecondaryId",
    "Section",
    "Serial",
    "SerialData",
    "SerialId",
    "SerialName",
    "SerialType",
    "SetPointTemperatureZone1",
    "SetPointTemperatureZone2",
    "SetPointTemperatureZone3",
    "Setup",
    "ShippingAddress",
    "Size",
    "SkyBitz",
    "SkyCameraPlanType",
    "SkyFence",
    "SkyFenceStatus",
    "Speed",
    "State",
    "Street",
    "SupplyAirTemperatureZone1",
    "TemperatureCelsius",
    "TemperatureFahrenheit",
    "Time",
    "TimeISO8601",
    "TimeOfReading",
    "TimeOfReadingISO8601",
    "Timestamp",
    "TotalDeviceMileage",
    "TotalMileage",
    "Township",
    "TractorId",
    "TransferDate",
    "TransferDateISO8601",
    "TransId",
    "TriggeredBy",
    "TruckingCompany",
    "TurnUpdate",
    "TurnUpdateISO8601",
    "VolEvent",
    "VolSerialData",
    "VolTimeOfReading",
    "VolTimeOfReadingISO8601",
    "VolumetricData",
]
