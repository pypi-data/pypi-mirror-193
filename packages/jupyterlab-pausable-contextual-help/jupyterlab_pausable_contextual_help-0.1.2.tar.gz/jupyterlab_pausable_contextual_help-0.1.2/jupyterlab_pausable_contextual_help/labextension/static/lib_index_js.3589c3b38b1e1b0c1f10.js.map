{"version":3,"file":"lib_index_js.3589c3b38b1e1b0c1f10.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAC6C;AACM;AACP;AACA;AACD;AAC3C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,4BAA4B,qDAAM;AAClC,6BAA6B,qDAAM;AACnC;AACA,8BAA8B,qDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAuB;AAC9C,yBAAyB;AACzB;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,gBAAgB,gEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAS,GAAG,MAAM;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9JA;AACA;AACqE;AACiB;AAChC;AACtD;AACA;AACA;AACA;AACA;AACA,KAAK;AACiC;AACQ;AACD;AACO;AACH;AACO;AACF;AACI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAW;AAC1B,eAAe,iEAAe,EAAE,2DAAS,EAAE,oEAAe;AAC1D,cAAc,+CAAU;AACxB;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA,4BAA4B,+DAAa;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAc;AAC9C,iCAAiC,sDAAc,GAAG,YAAY;AAC9D,iBAAiB;AACjB;AACA;AACA,uCAAuC,oEAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oEAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oEAAa;AAC1D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,kCAAkC,oBAAoB;AACjF;AACA;AACA;AACA,8BAA8B,mDAAmD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAU,EAAE,gEAAe,EAAE,8DAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAe,GAAG,gBAAgB;AACpE,gCAAgC,wDAAiB,GAAG,uBAAuB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAU,EAAE,kEAAgB,EAAE,8DAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAe,GAAG,gBAAgB;AACpE,gCAAgC,wDAAiB,GAAG,uBAAuB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;;;;AC/SvB;AACA;AACgD;AACS;AACT;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,kDAAK;AACzC;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,gDAAgD,mEAAc;AAC9D;AACA,8CAA8C,mDAAM;AACpD;AACA;AACA;AACA,wEAAwE,uBAAuB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iEAAe;AACpB,qBAAqB,sEAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtHA;AACA;AACoD;AACpD;AACA;AACA;AACO,8BAA8B,8DAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;ACxCA;AACA;AAC0C;AAC1C;AACA;AACA;AACO,uBAAuB,oDAAK","sources":["webpack://jupyterlab_pausable_contextual_help/./lib/handler.js","webpack://jupyterlab_pausable_contextual_help/./lib/index.js","webpack://jupyterlab_pausable_contextual_help/./lib/inspector.js","webpack://jupyterlab_pausable_contextual_help/./lib/kernelconnector.js","webpack://jupyterlab_pausable_contextual_help/./lib/tokens.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Text } from '@jupyterlab/coreutils';\nimport { MimeModel } from '@jupyterlab/rendermime';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Debouncer } from '@lumino/polling';\nimport { Signal } from '@lumino/signaling';\n/**\n * An object that handles code inspection.\n */\nexport class InspectionHandler {\n    /**\n     * Construct a new inspection handler for a widget.\n     */\n    constructor(options) {\n        this._cleared = new Signal(this);\n        this._disposed = new Signal(this);\n        this._editor = null;\n        this._inspected = new Signal(this);\n        this._isDisposed = false;\n        this._pending = 0;\n        this._standby = true;\n        this._lastInspectedReply = null;\n        this._connector = options.connector;\n        this._rendermime = options.rendermime;\n        this._debouncer = new Debouncer(this.onEditorChange.bind(this), 250);\n    }\n    /**\n     * A signal emitted when the inspector should clear all items.\n     */\n    get cleared() {\n        return this._cleared;\n    }\n    /**\n     * A signal emitted when the handler is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * A signal emitted when an inspector value is generated.\n     */\n    get inspected() {\n        return this._inspected;\n    }\n    /**\n     * The editor widget used by the inspection handler.\n     */\n    get editor() {\n        return this._editor;\n    }\n    set editor(newValue) {\n        if (newValue === this._editor) {\n            return;\n        }\n        // Remove all of our listeners.\n        Signal.disconnectReceiver(this);\n        const editor = (this._editor = newValue);\n        if (editor) {\n            // Clear the inspector in preparation for a new editor.\n            this._cleared.emit(void 0);\n            // Call onEditorChange to cover the case where the user changes\n            // the active cell\n            this.onEditorChange();\n            editor.model.selections.changed.connect(this._onChange, this);\n            editor.model.value.changed.connect(this._onChange, this);\n        }\n    }\n    /**\n     * Indicates whether the handler makes API inspection requests or stands by.\n     *\n     * #### Notes\n     * The use case for this attribute is to limit the API traffic when no\n     * inspector is visible.\n     */\n    get standby() {\n        return this._standby;\n    }\n    set standby(value) {\n        this._standby = value;\n    }\n    /**\n     * Get whether the inspection handler is disposed.\n     *\n     * #### Notes\n     * This is a read-only property.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the handler.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disposed.emit(void 0);\n        Signal.clearData(this);\n    }\n    /**\n     * Handle a text changed signal from an editor.\n     *\n     * #### Notes\n     * Update the hints inspector based on a text change.\n     */\n    onEditorChange(customText) {\n        // If the handler is in standby mode, bail.\n        if (this._standby) {\n            return;\n        }\n        const editor = this.editor;\n        if (!editor) {\n            return;\n        }\n        const text = customText ? customText : editor.model.value.text;\n        const position = editor.getCursorPosition();\n        const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);\n        const update = { content: null };\n        const pending = ++this._pending;\n        void this._connector\n            .fetch({ offset, text })\n            .then(reply => {\n            // If handler has been disposed or a newer request is pending, bail.\n            if (!reply || this.isDisposed || pending !== this._pending) {\n                this._lastInspectedReply = null;\n                this._inspected.emit(update);\n                return;\n            }\n            const { data } = reply;\n            // Do not update if there would be no change.\n            if (this._lastInspectedReply &&\n                JSONExt.deepEqual(this._lastInspectedReply, data)) {\n                return;\n            }\n            const mimeType = this._rendermime.preferredMimeType(data);\n            if (mimeType) {\n                const widget = this._rendermime.createRenderer(mimeType);\n                const model = new MimeModel({ data });\n                void widget.renderModel(model);\n                update.content = widget;\n            }\n            this._lastInspectedReply = reply.data;\n            this._inspected.emit(update);\n        })\n            .catch(reason => {\n            // Since almost all failures are benign, fail silently.\n            this._lastInspectedReply = null;\n            this._inspected.emit(update);\n        });\n    }\n    /**\n     * Handle changes to the editor state, debouncing.\n     */\n    _onChange() {\n        void this._debouncer.invoke();\n    }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ILabShell, ILayoutRestorer } from '@jupyterlab/application';\nimport { ICommandPalette, MainAreaWidget, WidgetTracker } from '@jupyterlab/apputils';\nimport { IConsoleTracker } from '@jupyterlab/console';\n// import {\n//   IInspector,\n//   InspectionHandler,\n//   InspectorPanel,\n//   KernelConnector\n// } from '@jupyterlab/inspector';\nimport { IInspector } from './tokens';\nimport { InspectionHandler } from './handler';\nimport { InspectorPanel } from './inspector';\nimport { KernelConnector } from './kernelconnector';\nimport { ILauncher } from '@jupyterlab/launcher';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { inspectorIcon } from '@jupyterlab/ui-components';\n/**\n * The command IDs used by the inspector plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.open = 'myinspector:open';\n    CommandIDs.close = 'myinspector:close';\n    CommandIDs.toggle = 'myinspector:toggle';\n    CommandIDs.trigger = 'myinspector:trigger';\n    CommandIDs.toggleStandby = 'myinspector:toggleStandby';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * A service providing code introspection.\n */\nconst inspector = {\n    id: 'jupyterlab_pausable_contextual_help:inspector',\n    requires: [ITranslator],\n    optional: [ICommandPalette, ILauncher, ILayoutRestorer],\n    provides: IInspector,\n    autoStart: true,\n    activate: (app, translator, palette, launcher, restorer) => {\n        const trans = translator.load('jupyterlab');\n        const { commands, shell } = app;\n        const caption = trans.__('Manually updating code documentation from the active kernel');\n        const openedLabel = trans.__('My Contextual Help');\n        const namespace = 'inspector';\n        const datasetKey = 'jpInspector';\n        const tracker = new WidgetTracker({\n            namespace\n        });\n        function isInspectorOpen() {\n            return inspector && !inspector.isDisposed;\n        }\n        function isStandby() {\n            // return inspector && inspector.content && inspector.content.source && inspector.content.source.standby;\n            if (inspector && inspector.content && inspector.content.source) {\n                return inspector.content.source.standby;\n            }\n            return false;\n        }\n        let source = null;\n        let inspector;\n        function openInspector(args) {\n            var _a;\n            if (!isInspectorOpen()) {\n                inspector = new MainAreaWidget({\n                    content: new InspectorPanel({ translator })\n                });\n                inspector.id = 'jp-inspector';\n                inspector.title.label = openedLabel;\n                inspector.title.icon = inspectorIcon;\n                void tracker.add(inspector);\n                source = source && !source.isDisposed ? source : null;\n                inspector.content.source = source;\n                (_a = inspector.content.source) === null || _a === void 0 ? void 0 : _a.onEditorChange(args);\n            }\n            if (!inspector.isAttached) {\n                shell.add(inspector, 'main', {\n                    activate: false,\n                    mode: 'split-right'\n                });\n            }\n            shell.activateById(inspector.id);\n            document.body.dataset[datasetKey] = 'open';\n            return inspector;\n        }\n        function closeInspector() {\n            inspector.dispose();\n            delete document.body.dataset[datasetKey];\n        }\n        // Add inspector:open command to registry.\n        const showLabel = trans.__('Open My Contextual Help');\n        commands.addCommand(CommandIDs.open, {\n            caption,\n            isEnabled: () => !inspector ||\n                inspector.isDisposed ||\n                !inspector.isAttached ||\n                !inspector.isVisible,\n            label: showLabel,\n            icon: args => (args.isLauncher ? inspectorIcon : undefined),\n            execute: args => {\n                var _a;\n                const text = args && args.text;\n                const refresh = args && args.refresh;\n                // if inspector is open, see if we need a refresh\n                if (isInspectorOpen() && refresh)\n                    (_a = inspector.content.source) === null || _a === void 0 ? void 0 : _a.onEditorChange(text);\n                else\n                    openInspector(text);\n            }\n        });\n        // Add inspector:close command to registry.\n        const closeLabel = trans.__('Hide My Contextual Help');\n        commands.addCommand(CommandIDs.close, {\n            caption,\n            isEnabled: () => isInspectorOpen(),\n            label: closeLabel,\n            icon: args => (args.isLauncher ? inspectorIcon : undefined),\n            execute: () => closeInspector()\n        });\n        // Add inspector:toggle command to registry.\n        const toggleLabel = trans.__('Show My Contextual Help');\n        commands.addCommand(CommandIDs.toggle, {\n            caption,\n            label: toggleLabel,\n            isToggled: () => isInspectorOpen(),\n            execute: args => {\n                if (isInspectorOpen()) {\n                    closeInspector();\n                }\n                else {\n                    const text = args && args.text;\n                    openInspector(text);\n                }\n            }\n        });\n        // Add inspector:trigger command to registry.\n        const triggerLabel = trans.__('Trigger My Contextual Help');\n        commands.addCommand(CommandIDs.trigger, {\n            caption,\n            isEnabled: () => isStandby(),\n            label: triggerLabel,\n            execute: () => {\n                var _a;\n                if (inspector && inspector.content && inspector.content.source && isStandby()) {\n                    inspector.content.source.standby = false;\n                    (_a = inspector.content.source) === null || _a === void 0 ? void 0 : _a.onEditorChange();\n                    inspector.content.source.standby = true;\n                }\n            }\n        });\n        // Add inspector:toggleStandby command to registry.\n        const toggleStandbyLabel = trans.__('Auto Update My Contextual Help');\n        commands.addCommand(CommandIDs.toggleStandby, {\n            caption,\n            isToggled: () => !isStandby(),\n            label: toggleStandbyLabel,\n            execute: () => {\n                if (inspector && inspector.content && inspector.content.source) {\n                    if (isStandby()) {\n                        inspector.content.source.standby = false;\n                    }\n                    else {\n                        inspector.content.source.standby = true;\n                    }\n                }\n            }\n        });\n        // Add open command to launcher if possible.\n        if (launcher) {\n            launcher.add({ command: CommandIDs.open, args: { isLauncher: true } });\n        }\n        // Add toggle command to command palette if possible.\n        if (palette) {\n            palette.addItem({ command: CommandIDs.toggle, category: toggleLabel });\n        }\n        // Handle state restoration.\n        if (restorer) {\n            void restorer.restore(tracker, {\n                command: CommandIDs.toggle,\n                name: () => 'inspector'\n            });\n        }\n        // Create a proxy to pass the `source` to the current inspector.\n        const proxy = Object.defineProperty({}, 'source', {\n            get: () => !inspector || inspector.isDisposed ? null : inspector.content.source,\n            set: (src) => {\n                source = src && !src.isDisposed ? src : null;\n                if (inspector && !inspector.isDisposed) {\n                    inspector.content.source = source;\n                }\n            }\n        });\n        return proxy;\n    }\n};\n/**\n * An extension that registers consoles for inspection.\n */\nconst consoles = {\n    id: 'jupyterlab_pausable_contextual_help:consoles',\n    requires: [IInspector, IConsoleTracker, ILabShell],\n    autoStart: true,\n    activate: (app, manager, consoles, labShell, translator) => {\n        // Maintain association of new consoles with their respective handlers.\n        const handlers = {};\n        // Create a handler for each console that is created.\n        consoles.widgetAdded.connect((sender, parent) => {\n            const sessionContext = parent.console.sessionContext;\n            const rendermime = parent.console.rendermime;\n            const connector = new KernelConnector({ sessionContext });\n            const handler = new InspectionHandler({ connector, rendermime });\n            // Associate the handler to the widget.\n            handlers[parent.id] = handler;\n            // Set the initial editor.\n            const cell = parent.console.promptCell;\n            handler.editor = cell && cell.editor;\n            // Listen for prompt creation.\n            parent.console.promptCellCreated.connect((sender, cell) => {\n                handler.editor = cell && cell.editor;\n            });\n            // Listen for parent disposal.\n            parent.disposed.connect(() => {\n                delete handlers[parent.id];\n                handler.dispose();\n            });\n        });\n        // Keep track of console instances and set inspector source.\n        labShell.currentChanged.connect((_, args) => {\n            const widget = args.newValue;\n            if (!widget || !consoles.has(widget)) {\n                return;\n            }\n            const source = handlers[widget.id];\n            if (source) {\n                manager.source = source;\n            }\n        });\n        app.contextMenu.addItem({\n            command: CommandIDs.toggle,\n            selector: '.jp-CodeConsole-promptCell'\n        });\n        app.contextMenu.addItem({\n            command: CommandIDs.toggleStandby,\n            selector: '.jp-CodeConsole-promptCell'\n        });\n    }\n};\n/**\n * An extension that registers notebooks for inspection.\n */\nconst notebooks = {\n    id: 'jupyterlab_pausable_contextual_help:notebooks',\n    requires: [IInspector, INotebookTracker, ILabShell],\n    autoStart: true,\n    activate: (app, manager, notebooks, labShell) => {\n        // Maintain association of new notebooks with their respective handlers.\n        const handlers = {};\n        // Create a handler for each notebook that is created.\n        notebooks.widgetAdded.connect((sender, parent) => {\n            const sessionContext = parent.sessionContext;\n            const rendermime = parent.content.rendermime;\n            const connector = new KernelConnector({ sessionContext });\n            const handler = new InspectionHandler({ connector, rendermime });\n            // Associate the handler to the widget.\n            handlers[parent.id] = handler;\n            // Set the initial editor.\n            const cell = parent.content.activeCell;\n            handler.editor = cell && cell.editor;\n            // Listen for active cell changes.\n            parent.content.activeCellChanged.connect((sender, cell) => {\n                handler.editor = cell && cell.editor;\n            });\n            // Listen for parent disposal.\n            parent.disposed.connect(() => {\n                delete handlers[parent.id];\n                handler.dispose();\n            });\n        });\n        // Keep track of notebook instances and set inspector source.\n        labShell.currentChanged.connect((sender, args) => {\n            const widget = args.newValue;\n            if (!widget || !notebooks.has(widget)) {\n                return;\n            }\n            const source = handlers[widget.id];\n            if (source) {\n                manager.source = source;\n            }\n        });\n        app.contextMenu.addItem({\n            command: CommandIDs.toggle,\n            selector: '.jp-Notebook'\n        });\n        app.contextMenu.addItem({\n            command: CommandIDs.toggleStandby,\n            selector: '.jp-Notebook'\n        });\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [inspector, consoles, notebooks];\nexport default plugins;\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Printing } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Panel, Widget } from '@lumino/widgets';\n/**\n * The class name added to inspector panels.\n */\nconst PANEL_CLASS = 'jp-Inspector';\n/**\n * The class name added to inspector content.\n */\nconst CONTENT_CLASS = 'jp-Inspector-content';\n/**\n * The class name added to default inspector content.\n */\nconst DEFAULT_CONTENT_CLASS = 'jp-Inspector-default-content';\n/**\n * A panel which contains a set of inspectors.\n */\nexport class InspectorPanel extends Panel {\n    /**\n     * Construct an inspector.\n     */\n    constructor(options = {}) {\n        super();\n        this._source = null;\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        if (options.initialContent instanceof Widget) {\n            this._content = options.initialContent;\n        }\n        else if (typeof options.initialContent === 'string') {\n            this._content = InspectorPanel._generateContentWidget(`<p>${options.initialContent}</p>`);\n        }\n        else {\n            this._content = InspectorPanel._generateContentWidget('<p>' +\n                this._trans.__('Press F1 on a function to see documentation.') +\n                '</p>');\n        }\n        this.addClass(PANEL_CLASS);\n        this.layout.addWidget(this._content);\n    }\n    /**\n     * Print in iframe\n     */\n    [Printing.symbol]() {\n        return () => Printing.printWidget(this);\n    }\n    /**\n     * The source of events the inspector panel listens for.\n     */\n    get source() {\n        return this._source;\n    }\n    set source(source) {\n        if (this._source === source) {\n            return;\n        }\n        // Disconnect old signal handler.\n        if (this._source) {\n            this._source.standby = true;\n            this._source.inspected.disconnect(this.onInspectorUpdate, this);\n            this._source.disposed.disconnect(this.onSourceDisposed, this);\n        }\n        // Reject a source that is already disposed.\n        if (source && source.isDisposed) {\n            source = null;\n        }\n        // Update source.\n        this._source = source;\n        // Connect new signal handler.\n        if (this._source) {\n            //   this._source.standby = false;\n            this._source.inspected.connect(this.onInspectorUpdate, this);\n            this._source.disposed.connect(this.onSourceDisposed, this);\n        }\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.source = null;\n        super.dispose();\n    }\n    /**\n     * Handle inspector update signals.\n     */\n    onInspectorUpdate(sender, args) {\n        const { content } = args;\n        // Update the content of the inspector widget.\n        if (!content || content === this._content) {\n            return;\n        }\n        this._content.dispose();\n        this._content = content;\n        content.addClass(CONTENT_CLASS);\n        this.layout.addWidget(content);\n    }\n    /**\n     * Handle source disposed signals.\n     */\n    onSourceDisposed(sender, args) {\n        this.source = null;\n    }\n    /**\n     * Generate content widget from string\n     */\n    static _generateContentWidget(message) {\n        const widget = new Widget();\n        widget.node.innerHTML = message;\n        widget.addClass(CONTENT_CLASS);\n        widget.addClass(DEFAULT_CONTENT_CLASS);\n        return widget;\n    }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * The default connector for making inspection requests from the Jupyter API.\n */\nexport class KernelConnector extends DataConnector {\n    /**\n     * Create a new kernel connector for inspection requests.\n     *\n     * @param options - The instantiation options for the kernel connector.\n     */\n    constructor(options) {\n        super();\n        this._sessionContext = options.sessionContext;\n    }\n    /**\n     * Fetch inspection requests.\n     *\n     * @param request - The inspection request text and details.\n     */\n    fetch(request) {\n        var _a;\n        const kernel = (_a = this._sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!kernel) {\n            return Promise.reject(new Error('Inspection fetch requires a kernel.'));\n        }\n        const contents = {\n            code: request.text,\n            cursor_pos: request.offset,\n            detail_level: 1\n        };\n        return kernel.requestInspect(contents).then(msg => {\n            const response = msg.content;\n            if (response.status !== 'ok' || !response.found) {\n                throw new Error('Inspection fetch failed to return successfully.');\n            }\n            return { data: response.data, metadata: response.metadata };\n        });\n    }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The inspector panel token.\n */\nexport const IInspector = new Token('@jupyterlab/inspector:IInspector');\n"],"names":[],"sourceRoot":""}