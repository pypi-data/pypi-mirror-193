# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pokerlib', 'pokerlib.statistics']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'pokerlib',
    'version': '1.0.0',
    'description': 'Python poker library',
    'long_description': '# pokerlib\n[![PyPI version](https://badge.fury.io/py/pokerlib.svg)](https://pypi.org/project/pokerlib)\n\nA lightweight Python poker library that focuses on simplifying a poker game implementation when its io is supplied. It includes modules that help with hand parsing and poker game continuation.\n\nOne application of this library was made by the PokerMessenger app, which supplies library with io in the form of messenger group threads. The app\'s repo is at https://github.com/kuco23/pokermessenger.\n\nTo install, run \n```bash\npip install pokerlib\n```\n\n## Usage\nLibrary consists of a module for parsing cards, which can be used seperately, and modules that aid in running a poker game.\n\n### HandParser\nThis module helps with parsing hands. A hand usually consists of 2 dealt cards plus 5 on the board, and `HandParser` is optimized to work with up to 7 cards (otherwise flushes and straights require some small additional work). A card is defined as a pair of two enums. All of the enums used are of `IntEnum` type, so you can also freely interchange them for integers. Below is an example of how to construct two different hands and then compare them.\n\n```python\nhand1 = HandParser([\n    (Rank.KING, Suit.SPADE),\n    (Rank.ACE, Suit.SPADE)\n])\n\nhand2 = HandParser([\n    (Rank.NINE, Suit.SPADE),\n    (Rank.TWO, Suit.CLUB)\n])\n\nboard = [\n    (Rank.EIGHT, Suit.SPADE),\n    (Rank.TEN, Suit.SPADE),\n    (Rank.JACK, Suit.SPADE),\n    (Rank.QUEEN, Suit.SPADE),\n    (Rank.TWO, Suit.HEART)\n]\n\n# add new cards to each hand\nhand1 += board # add the board to hand1\nhand2 += board # add the board to hand2\n\nprint(hand1.handenum) # Hand.STRAIGHTFLUSH\nprint(hand2.handenum) # Hand.STRAIGHTFLUSH\nprint(hand1 > hand2) # True\n```\n\n> **note:**\n> In the previous version, each hand had to be parsed manually, now calling any of the methods requiring the hand to be parsed, triggers parsing. Note that the only way to add new cards to a hand is through the `__iadd__` method. If this method is called with hand already parsed, it logs that a new parsing is required.\n\nIt is also possible to fetch hand\'s kickers.\n\n```python\nhand = HandParser([\n    (Rank.TWO, Suit.DIAMOND),\n    (Rank.ACE, Suit.CLUB),\n    (Rank.TWO, Suit.SPADE),\n    (Rank.THREE, Suit.DIAMOND),\n    (Rank.TEN, Suit.HEART),\n    (Rank.SIX, Suit.HEART),\n    (Rank.KING, Suit.CLUB)\n])\n\nprint(list(hand.kickercards))\n# [\n#   (<Rank.ACE: 12>, <Suit.CLUB: 1>),\n#   (<Rank.KING: 11>, <Suit.CLUB: 1>),\n#   (<Rank.TEN: 8>, <Suit.HEART: 3>)\n# ]\n```\n\nNote that the attribute `kickers` saves the indices of `hand.cards` that form `kickercards`.\n\nUsing HandParser, we can estimate the probability of a given hand winning the game with given known cards on the table (as implemented in another python cli-app [here](https://github.com/cookpete/poker-odds)). We do this by repeatedly random-sampling hands, then averaging the wins. Mathematically, this process converges to the probability by the law of large numbers.\n\n```python\nfrom random import sample\nfrom itertools import product\nfrom pokerlib import HandParser\nfrom pokerlib.enums import Rank, Suit\n\ndef getWinningProbabilities(players_cards, board=[], n=1000):\n    cards = list(product(Rank, Suit))\n    for card in board: cards.remove(card)\n    for player_cards in players_cards:\n        for card in player_cards:\n            cards.remove(card)\n\n    wins = [0] * len(players_cards)\n    for i in range(n):\n        board_ = sample(cards, 5-len(board))\n        hands = [\n            HandParser(player_cards + board + board_)\n            for player_cards in players_cards\n        ]\n        winner = max(hands)\n        for i, hand in enumerate(hands):\n            if hand == winner: wins[i] += 1\n\n    return [win / n for win in wins]\n    \nw1, w2 = getWinningProbabilities([\n    [(Rank.ACE, Suit.HEART), (Rank.KING, Suit.HEART)],\n    [(Rank.KING, Suit.SPADE), (Rank.KING, Suit.DIAMOND)]\n])\n```\n\n### Poker Game\nA poker table can be established by providing its configuration.\nA poker table object responds to given input with appropriate output,\nwhich can be customized by overriding the two functions producing it.\n\n```python\nfrom pokerlib import Player, PlayerGroup, Table\n\n# just print the output\nclass MyTable(Table):\n    def publicOut(self, out_id, **kwargs):\n        print(out_id, kwargs)\n    def privateOut(self, player_id, out_id, **kwargs):\n        print(out_id, kwargs)\n\ntable = MyTable(\n    table_id = 0\n    seats = 2\n    players = PlayerGroup([])\n    buyin = 100\n    small_blind = 5\n    big_blind = 10\n)\n```\n\nPlayers could be passed inside MyTable constructor,\nbut as they usually join the table after its definition,\nwe will do that below.\n\n```python\nplayer1 = Player(\n    table_id = table.id,\n    _id = 1,\n    name = \'alice\',\n    money = table.buyin\n)\nplayer2 = Player(\n    table_id = table.id,\n    _id = 2,\n    name = \'bob\',\n    money = table.buyin\n)\ntable += [player1, player2]\n```\n\nCommunication with the `table` object is established through specified enums,\nwhich can be modified by overriding table\'s `publicIn` method.\nUsing enums, we can implement a poker game as shown below.\n\n```python\nfrom pokerlib.enums import RoundPublicInId, TablePublicInId\n\ntable.publicIn(player1.id, TablePublicInId.STARTROUND)\ntable.publicIn(player1.id, RoundPublicInId.CALL)\ntable.publicIn(player2.id, RoundPublicInId.CHECK)\ntable.publicIn(player1.id, RoundPublicInId.CHECK)\ntable.publicIn(player2.id, RoundPublicInId.RAISE, raise_by=50)\ntable.publicIn(player1.id, RoundPublicInId.CALL)\ntable.publicIn(player1.id, RoundPublicInId.CHECK)\ntable.publicIn(player2.id, RoundPublicInId.CHECK)\ntable.publicIn(player1.id, RoundPublicInId.ALLIN)\ntable.publicIn(player2.id, RoundPublicInId.CALL)\n```\n\nWrong inputs are mostly ignored, though they can produce a response, when that seems useful. As noted before, when providing input, the `table` object responds with output ids (e.g. `PLAYERACTIONREQUIRED`) along with additional data that depends on the output id. For all possible outputs, check `RoundPublicInId` and `TablePublicInId` enums.\n\nA new round has to be initiated by one of the players every time the previous one ends (or at the beginning). A simple command line game, where you respond by enum names, can be implemented as below (for working version check `tests/round_test.py`).\n\n```python\n# define a table with fixed players as before\ntable = ...\nwhile table:\n    while table and not table.round:\n        table.publicIn(\n            table.players[0].id, \n            TablePublicInId.STARTROUND\n        )\n\n    player = table.round.current_player\n    inp = input(f"require input from {player.id}: ")\n\n    if inp in RoundPublicInId.__members__:\n        action, raise_by = RoundPublicInId.__members__[inp], 0\n    elif inp.startswith(RoundPublicInId.RAISE.name):\n        raise_by = int(inp.split()[1])\n        action, raise_by = RoundPublicInId.RAISE, raise_by\n    else:\n        continue\n\n    table.publicIn(player.id, action, raise_by=raise_by)\n```\n\n## Tests\nBasic tests for this library are included. You can test handparser by running\n```bash\npython tests/handparser.py\n```\nand the poker game by calling\n```bash\npython tests/round_test.py <player_number>\n```\nwhich will run a poker game simulation with raw data getting printed to stdout.\n\n## License\nGNU General Public License v3.0\n',
    'author': 'kuco23',
    'author_email': 'nseverkar@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/kuco23/pokerlib/',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
