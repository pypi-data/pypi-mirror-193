****************
Inline Regridder
****************

**Status:** Beta version 1.0.0b1

**Sample Rose Suite:** `u-ce479`_ (login required)

**Rose App Name:** inline_regridder

**App Class Path:** afterburner.apps.inline_regridder.InlineRegridder

.. contents::
   :depth: 3

Quick-Start Guide
=================

If you are familiar working with FCM/SVN commands and configuring complex climate
suites then you may wish to skip straight to the :doc:`Quick-Start Guide </rose_apps/inline_regridder/quickstart>`
to the Inline Regridder application.

Overview
========

The Inline Regridder app is a Rose-enabled application for regridding climate
model diagnostics as they are being generated by a climate simulation, though
it can also be employed as a stand-alone post-processing utility. The app will
usually be configured to regrid a selected subset of diagnostics at the end of
each model integration step (or some other user-defined cycle point).

Model diagnostics to be regridded are identified either by STASH code or by CF
standard name. Additional diagnostic attributes (such as LBPROC or LBTIM) may be
required to distinguish between like-named diagnostics that can occur together
in some types of model output.

The source model data can be in any file format recognised by Iris, e.g.
UM fieldsfile, UM PP, or netCDF format. The regridded data is output in netCDF-4
classic format by default, though this can be changed by the user if desired.

At present, the supported regridding schemes are limited to those recognised by
the Iris package (`further info <https://scitools-iris.readthedocs.io/en/latest/userguide/interpolation_and_regridding.html>`_).
In addition to performing the regridding of model data, the app may also be
configured to remove a rim of a user-defined width, or apply aland-sea mask.
Both of these operations are applied as precursor steps to the main regridding task.

The Inline Regridder app is configured via an INI-style text file conforming to
Rose's extended INI file format. The contents of the app config file are described
in detail under the `Configuring the Application`_ section later on in this guide.

Application Inputs
==================

There are two main kinds of input data sources:

1. Climate model data files
2. Grid data files

The model data files contain the diagnostics that are to be regridded. Although
the current beta version of the Inline Regridder app is designed to handle
diagnostics generated by the Unified Model, in principle it should work with
output from other climate models (so long as Iris can read the output files).

It is assumed that all of the model data files reside in a single directory on
the file system since that is the usual layout utilised by the Unified Model
(where the directory is typically the one pointed to by the ``$DATAM`` environment
variable).

The names of the files to read for a given diagnostic are determined according
to a user-defined filename template, as discussed under the `Filename Templates`_
section below.

The grid data files act as the source for diagnostics or ancillary variables
which define the target grids (and, if required, land-sea masks) used during
regridding operations. Nominally, the current version of the app only supports
regular lat/long grids. In practice, however, the viability of a particular source
grid to target grid transformation is dependent mainly upon the capabilities of
the Iris regridding functionality.

The `Grid Definitions`_ section describes how to define target grids in the
app config file.
 
Application Outputs
===================

Regridded diagnostics are written to netCDF files, one diagnostic per output file.
The files are saved to the directory defined by the ``[general]output_dir``
app config option (see `General Options`_). The names of the output files are
also determined by a filename template, as described in the next section.

.. _filename-templates:

Filename Templates
==================

The Inline Regridder app needs to know the names of the input files from which
to read model diagnostics, and the names of the output files in which to save
regridded versions of those diagnostics. This is achieved through the use of
user-defined filename templates, one covering input files, and one covering
output files.

Each filename template is a text string containing a combination of free text
and named tokens (from a controlled list) enclosed in brace characters, e.g.
``{runid}``. 

By way of example, the default template for PP input files, as defined in the
sample app config file, looks something like this:

.. code-block:: ini

   [general]
   input_filename_template={runid}{dotstream}*.pp 

Here, the ``{runid}`` and ``{dotstream}`` tokens get replaced at runtime with
the values associated with the model diagnostic currently being processed. The
``runid`` token is fairly self-explanatory. The ``dotstream`` token represents
the stream name with a '.' character inserted at position 1. In the case of the
'apy' stream, for example, the value of the ``dotstream`` token would expand to
'a.py'.

The filename template for netCDF output files might look something like this:

.. code-block:: ini

   [general]
   output_filename_template={runid}_{stream}_{var_name}_proc{lbproc}_tim{lbtim}.nc

.. note:: In most cases you'll want filename templates to yield *unique names*
   for the set of stream-plus-diagnostic combinations configured for a given
   run of the application. If not then the possibility exists that the output
   file created for a given diagnostic may overwrite that used for a diagnostic
   generated earlier in the processing sequence.

The standard list of recognised filename tokens is shown in the table below.

=========================== =================
Token                       Substituted Value
=========================== =================
model, model_name           Model name, e.g. 'UM'
suite, suite_id, suite_name Suite name, e.g. 'mi-ab123'
runid                       Run ID, e.g. 'ab123' (automaticaly derived from the suite name)
realm                       Realm abbreviation, e.g. 'a' for atmos (automatically derived from the stream name)
stream                      Stream name, e.g. 'apy' (automatically updated as each stream is processed)
dotstream                   Stream name with a '.' in position 1, e.g. 'a.py' (automaticaly derived from the stream name)
var_id                      STASH code or CF standard name for a diagnostic/variable
lbproc                      Value of LBPROC PP header item (default: 128)
lbtim                       Value of LBTIM PP header item (default: 122)
grid_res                    Grid resolution mnemonic, e.g. 'n48'
data_start_date             The start date of the output data (see also `Datetime Format`_)
data_end_date               The end date of the output data (see also `Datetime Format`_)
=========================== =================

The above list may be extended with arbitrary user-defined tokens simply by adding
an option with the desired name (and a default value) to the ``[namelist:diagnostics(_defaults_)]``
section of the app config file. The new option can, and usually should, be
overridden for individual diagnostics.

By way of illustration, to include a custom token named ``mip_name`` in a filename
template one could modify the app config file as follows:

.. code-block:: ini

   [general]
   # amend template to use the new mip_name token
   output_filename_template={runid}_{stream}_{mip_name}_proc{lbproc}_tim{lbtim}.nc
   # ...

   [namelist:diagnostics(_defaults_)]
   # ...
   mip_name=undefined
   # ...

   [namelist:diagnostics(surface_temp)]
   enabled=true
   var_id=m01s00i024
   mip_name=tas
   # ...

Integration With Climate Suites
===============================

The `Running the Application`_ section towards the end of this guide describes
the actual mechanics of invoking the Inline Regridder app. The present section
provides some hints as regards how best to incorporate the app into a Rose/cylc
suite.

Although the Inline Regridder app can be run independently within a terminal window,
it is envisaged that invoking it under the control of a Rose/cylc suite will be the
preferred mode of operation (and the reason why it's called an *inline* regridder).

Lifetime of Model Data Files
----------------------------

An important point to bear in mind is that the Inline Regridder reads and regrids
diagnostic data which it loads from a subset (typically) of the files output by
the climate model at a given cycle point. The particular subset of data files will
depend upon which output streams have been specified in the app config file.

As a consequence of this behaviour it is crucial that, during the execution of
the regridding task, the input data files are *neither modified nor deleted by
any other suite task*. In particular, when working with PP files as the input
source, the postproc app must be configured such that the transform and archive
tasks occur either side of the regridding task. In terms of a cylc dependency
graph this could be depicted schematically as follows:

.. code-block:: ini

   [dependencies]
   graph = postproc => inline_regridder:finish => pparchive

(Note: The actual postproc tasks might have different names in your suites)

The reasoning here is that we want the PP files to remain in situ on disk until
the regridding task has completed. Otherwise, if the postproc tasks were to run
back-to-back, some of the PP files would be deleted before the regridding task
had a chance to process them.

There is also an assumption that the postproc tasks for successive cycle points
do not overlap in time (i.e. they execute sequentially). This is important because
otherwise the regridding task would not know which PP files to load and process
at any given cycle point since files from multiple cycles would co-exist in the
suite share directory. Fortuitously, in most standard climate suites, the postproc
task is configured to execute in just this manner (though this should be verified
before running a suite).

Runtime Performance Considerations
----------------------------------

To avoid repeatedly reading a given model data file multiple times (i.e. for multiple
target diagnostics), the Inline Regridder app uses Iris's load functions to read
the data for *all* required diagnostics at the commencement of processing of each
data stream.

Loading data from large UM fieldsfiles or PP files is known to result in a substantial
drain on system resources. Similarly, the task of regridding model diagnostics,
especially high-resolution fields on multiple levels, is a compute-intensive operation.
Taken together, this means that incorporating the Inline Regridder app into a
climate suite could lead to a *significant performance overhead*. Attempting to regrid
a large number of diagnostics might, therefore, lead to exceeding system resource
limits. This will of course depend upon the target runtime platform and the system
load at any given moment. Experimentation may be necessary, therefore, in order to
determine appropriate resource limits.

Handling of Output Files
------------------------

As described under `Application Outputs`_, the app writes files of regridded
diagnostics to the user-configured output directory. It is the responsibility of
the user or suite creator to configure any additional processing of the output
files that might be required. This might include, for example, copying or moving
the files to some other disk location, or archiving the files to the MASS data
storage system.

If no such additional processing is defined then the files will simply remain
on disk (at least until they get deleted by some or other housekeeping task).

Configuring the Application
===========================

The Inline Regridder app is configured by specifying properties in a text file
based upon Rose's custom INI file format. This so-called 'app config file' may
be created and updated manually using your favourite text editor, or else by
using Rose's graphical editor tool (invoked by typing ``rose config-edit`` or,
if you're really pressed for time, ``rose edit``).

You can, if you like, mix-and-match both of these techniques at different times.
One advantage of editing the configuration file manually is that it doesn't get
reformatted or reordered, which does happen when you modify and save a config
file using ``rose edit``. This can be mildly annoying.

A sample app config file is included as part of the reference Rose suite named
`u-ce479`_. Within that suite the app config file can be found at the path
``app/inline_regridder/rose-app.conf``. It contains all of the properties currently
recognised by the Inline Regridder app, listed with their default values where
appropriate. Some of the less frequently used properties are hidden (from a Rose
perspective) by placing a '!' character at the front of the property or section
definition.

A brief description of each configuration property is provided below on a section
by section basis.

COMMAND EXECUTION
-----------------

Config file section: ``[command]``

Default Command
~~~~~~~~~~~~~~~

.. code-block:: ini

   default=rose env-cat rose-app-run.conf >rose-app-expanded.conf;
          =$AFTERBURNER_HOME_DIR/bin/apprun.sh InlineRegridder -v -c rose-app-expanded.conf

This property defines the command that Rose will invoke in order to run the
Inline Regridder application. As shown above, the default command makes use of
the ``rose env-cat`` command to expand any environment variables defined in the
runtime version of the app config file (``rose-app-run.conf``). The resulting
file (``rose-app-expanded.conf``) is then passed to Afterburner's ``apprun.sh``
script.

Other than to append additional command-line options (as described below under
`Command-Line Options`_), the default command syntax does not normally need to be
modified.

If you're not using Rose to run the Inline Regridder app then this property is
ignored.

RUNTIME ENVIRONMENT
-------------------

Config file section: ``[env]``

Afterburner Home Directory
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   AFTERBURNER_HOME_DIR=/data/users/afterburner/software/turbofan/current

This environment variable is used to define the pathname of the directory within
which the Afterburner software is installed. If this variable is already set
within your runtime environment - e.g. within one of your shell start-up scripts -
then it's not essential to repeat it here (though it doesn't necessarily hurt to
do so). If you're not sure where the Afterburner software is installed at your
site, please contact your local system administrator.

Alternatively, it is possible to define this variable under the appropriate
section of either the ``rose-suite.conf`` file or the ``suite.rc`` file
(assuming that the Inline Regridder app is being executed under the control
of a Rose/cylc suite).

SciTools Module
~~~~~~~~~~~~~~~

.. code-block:: ini

   SCITOOLS_MODULE=scitools/default-current

This environment variable may be used to specify the name of the SciTools module
to load immediately prior to invocation of the Inline Regridder app. If it's not
defined then the default SciTools module gets loaded. To prevent loading of any
SciTools module this environment variable can be set to 'none'. This might be
desirable if the calling environment has already loaded the required module.

GENERAL OPTIONS
---------------

Config file section: ``[general]``

Input and Output Directories
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   model_data_dir=${DATAM}
   output_dir=${DATAM}/regridded

The ``model_data_dir`` option defines the pathname of the directory containing
model data files (in the format specified below). The pathname may contain
environment variables; these are best enclosed within braces so as to avoid
potential ambiguity when the path is expanded.

The ``output_dir`` option defines the pathname (absolute or relative) of the
directory within which to save any output files. As with the ``model_data_dir``
option, the path may contain environment variables. Note, that a relative path
will be relative to the *current working directory* which, in a running Rose/cylc
suite, will usually be the task work directory, i.e. $CYLC_TASK_WORK_DIR. 

Input File Format & Filename Template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   input_file_format=pp
   input_filename_template={runid}{dotstream}*.pp

The ``input_file_format`` option defines the format of the input model data.
Currently supported formats include UM fieldsfiles, UM PP (default), and netCDF.

The ``input_filename_template`` option specifies the template by which model data
files are identified when the app is run. The list of brace-delimited tokens
which can be used within a template are described under the `Filename Templates`_
section.

Output File Format & Filename Template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   output_file_format=nc
   output_filename_template={runid}_{stream}_{var_id}_proc{lbproc}_tim{lbtim}.nc

The ``output_file_format`` option defines the format of the output files (of
regridded data) generated by the app. At present, netCDF is the only supported
output format.

The ``output_filename_template`` option specifies the template that will be used
to construct the name of netCDF output files. Refer to the `Filename Templates`_
section for details.

Datetime Format
~~~~~~~~~~~~~~~

.. code-block:: ini

   datetime_format=%Y%m%d

The ``datetime_format`` option is used to specify the format of datetime strings
incorporated into the names of output files. At present, the filename tokens that
make use of the datetime format are ``{data_start_date}`` and ``{data_end_date}``.

The permitted format codes are as documented for Python's `datetime.strftime`_
function. The default format is ``%Y%m%d``, which yields, for example, a date
string of the form '19701201' for the date 1st Dec 1970.

Abort On Error
~~~~~~~~~~~~~~

.. code-block:: ini

   abort_on_error=true

By default, a data processing error will cause the Inline Regridder app to exit
immediately. Setting the ``abort_on_error`` option to false will result in the
app catching an exception, reporting (and logging) the associated error message,
and skipping to the next diagnostic, or the next stream, to be processed.

.. note:: In the current implementation, being unable to find any model data
   for a given diagnostic is *not* considered an error; rather an informational
   message is emitted and processing skips forward to the next diagnostic. If it's
   desired by users, this behaviour could be modified in future versions of the app.   

NETCDF SAVE OPTIONS
-------------------

Config file section: ``[netcdf_saver]``

NetCDF Format
~~~~~~~~~~~~~

.. code-block:: ini

   netcdf_format=NETCDF4_CLASSIC
   overwrite=false

The ``netcdf_format`` option is used to specify the format or 'flavour' of
netCDF to use for output files. The default of NETCDF4_CLASSIC is chosen because
it enables data compression to be applied (if required; see below). Set this
option to NETCDF4 if you need to take advantage of the features provided by the
netCDF-4 enhanced data model.

File Overwriting & Appending
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   overwrite=false
   append=false

By default, the Inline Regridder app will *not* overwrite existing output files.
The ``overwrite`` option may be used to control this behaviour.

If it is required to *append* data to an existing file then the ``append`` option
should be enabled (in which case ``overwrite=true`` is implied). The context
within which the app is being run will likely determine whether or not the append
option is useful. For example, if the app is writing out timestamped files - one
per stream-diagnostic combination per cycle point, say - then the same file will
only be written to once.

Compression Options
~~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   zlib=true
   complevel=2

Data compression is enabled by default at the specified compression level. You
may want to experiment with different compression settings. Note, however, that
compression levels above, say, 4 are prone to the law of diminishing returns:
it can take a disproportionate amount of time and CPU resource to achieve a small
amount of extra compression.

Unlimited Dimensions
~~~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   unlimited_dimensions=time

By default, data variables are written out with *no unlimited dimensions* since
this usually leads to smaller output files. If need be, however, one or more (in
the case of netCDF-4) unlimited dimensions can be specified via the ``unlimited_dimensions``
option. In the example above, the time dimension will be unlimited, i.e. it
becomes a so-called record dimension in netCDF-speak. This can be desirable if
later on you are planning to concatenate files together along the time axis.

Additional NetCDF Options
~~~~~~~~~~~~~~~~~~~~~~~~~

The following options are less frequently needed, but are there if you need them.
Refer to the Iris `netcdf.save`_ function documentation for further details.

.. code-block:: ini

   shuffle=false
   fletcher32=false
   contiguous=false
   least_significant_digit=

DIAGNOSTIC DEFINITIONS
----------------------

Config file section: ``[namelist:diagnostics]``

Model diagnostics that are to be regridded are specified via this namelist.
A sizeable number of properties can be specified for each diagnostic. In most
cases, however, only a handful of properties need to be defined; and often just
the ``var_id`` option. The remaining properties are inherited from the 'dummy'
diagnostic named ``_defaults_`` (which should appear at the top of the namelist
when the config file is viewed using rose-edit). 

Enabling/Disabling Diagnostics
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   [namelist:diagnostics(tas)]
   enabled=true

Ordinarily each diagnostic is enabled, meaning that it will get detected and
processed by the Inline Regridder app. Sometimes, however, it can be useful to
temporarily disable a diagnostic without having to actually delete it from the
app config file. The ``enabled`` option allows you to conveniently switch
diagnostics on and off.

Diagnostic/Variable Identifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   [namelist:diagnostics(tas)]
   # defined by a UM STASH code
   var_id=m01s00i024
   # defined by a CF standard name
   var_id=surface_temperature

The ``var_id`` option specifies the identifier of a target model diagnostic that
you wish to regrid. It should either be a STASH code or a CF standard name, as
illustrated in the example above. For processing UM model diagnostics it will
usually be desirable to specify a STASH code. For other climate models, notably
those generating netCDF output, the standard name will normally be required.

Stream Names
~~~~~~~~~~~~

.. code-block:: ini

   [namelist:diagnostics(tas)]
   streams=apm,aps,apy

This important option is used to specify the stream, or comma-separated list of
streams, for which the diagnostic should be processed. In the case where each
diagnostic is to be processed for the same streams, then the ``streams`` option
need only be defined once under the ``_defaults_`` diagnostic.

Suite Name, Model Name & Model Realm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   [namelist:diagnostics(tas)]
   suite_name=
   model_name=UM
   realm=a

Each of these properties is optional. When the Inline Regridder app is run under
the control of a cylc suite then the ``suite_name`` option is derived from the
CYLC_SUITE_NAME environment variable. If the app is executed in stand-alone mode
then you may wish to set it manually. Otherwise the value defaults to 'expid'.

The ``model_name`` and/or ``realm`` options should be set if you are using the
'{model_name}' and/or '{realm}' tokens in either of the filename templates (see above).
Both options can be set to any text string. Typically, however, realm is set to one
of the letters a, o, i, or l (which carry their familiar meanings: atmos, ocean,
ice, land).

Note: a ``runid`` property is automatically derived from the suite name and
attached to the diagnostic definition. This too may be referenced in filename
templates using the '{runid}' token.

Standard Name, Long Name, Variable Name & Units
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   [namelist:diagnostics(tas)]
   standard_name=surface_temperature
   long_name=Air Temperature at 2m
   var_name=tas2m
   units=

These optional CF-related properties may be used to set the values of the
equivalently named attributes on the cube of regridded data which gets generated
for each processed diagnostic. The cube attributes would then appear as metadata
attributes attached to the corresponding variable in the output netCDF file.

It is often to useful to reference either the standard name or the variable name
within a filename template by using the tokens ``{standard_name}`` or ``{var_name}``.
If this is done then the relevant options should be defined for *all* diagnostics
in the app config file.

It should not normally be necessary to set the ``units`` option since the units
of the regridded data are taken from the source diagnostic. No units conversion
is automatically applied in the event that this option is defined. Consequently,
it should be used with caution.

LBPROC & LBTIM Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   [namelist:diagnostics(tas)]
   lbproc=128
   lbtim=122

These two options are used to disambiguate UM diagnostics which share the same
STASH code and which can end up being serialised in the same model output file.
A common use is to set the ``lbtim`` option so as to correctly select a diagnostic
at a particular sampling frequency, e.g. 3h, 6h, or 24h.

If undefined, the ``lbproc`` and ``lbtim`` options assume default values of 128
and 122, respectively.

Land-sea Mask
~~~~~~~~~~~~~

.. code-block:: ini

   [namelist:diagnostics(tas)]
   apply_lsm=true
   lsm_grid=um_n96e_pgrid

A land-sea mask can be applied to a model diagnostic *prior* to the regridding
step. The ``apply_lsm`` option controls whether or not a land-sea mask is applied;
by default it is disabled. If it is enabled then the ``lsm_grid`` option must
define the name (namelist id) of a grid definition (see `Grid Definitions`_).
The referenced grid must have the same shape, in the lat/long dimensions, as the
diagnostic data.

Rim Removal
~~~~~~~~~~~

.. code-block:: ini

   [namelist:diagnostics(tas)]
   remove_rim=true
   rim_width=10

A rim of a user-defined width can be removed from the input diagnostic data
*prior* to the regridding step. The rim is applied symmetrically to both ends of
the relevant horizontal axes, be they lat/long or or X/Y. 

Note: If a land-sea mask is to be applied to a given diagnostic then the rim is
also removed from the land-sea mask grid referenced by the diagnostic (the
assumption being that the diagnostic grid and the land-sea mask grid are normally
congruent).

Regridding Options
~~~~~~~~~~~~~~~~~~

.. code-block:: ini

   [namelist:diagnostics(tas)]
   regridder=default

The ``regridder`` option is used to associate a diagnostic (or potentially all
diagnostics if it is defined against the ``_defaults_`` diagnostic) with the
definition of a particular regridder. As the name suggests, the regridder defines
the method that will be used to regrid a diagnostic. Refer to the `Regridder Definitions`_
section below for details.

GRID DEFINITIONS
----------------

Config file section: ``[namelist:grids]``

The ``grids`` namelist portion of the app config file is used to define any
grids that are required during the execution of the Inline Regridder app. Grids
are currently used for two purposes: firstly, and primarily, to act as target
grids during regridding, and secondly to act as the source for a land-sea mask.

In both cases the grid is read from a file, which must be in a format supported
by the Iris package. In practice, a specific data variable is loaded from the specified
file and the grid is derived from the relevant horizontal coordinates associated
with that variable. The horizontal coordinates are determined by searching for
dimensions with axis labels 'X' and 'Y'.

The following fragment of an app config file shows the grid definition for an
'N96e' land-sea mask serialised in a UM fieldsfile. A diagnostic or regridder
wanting to reference this grid would do so using its namelist index value or
label, i.e. ``um_n96e_lsm``.

.. code-block:: ini

   [namelist:grids(um_n96e_lsm)]
   file_path=/scratch/mary/grid_files/lsm/ff/qrparm.mask.n96e
   var_id=land_binary_mask

And here's an example of specifying a target grid serialised in a netCDF file
as the variable named ``land_area_fraction``:

.. code-block:: ini

   [namelist:grids(um_n48e_pgrid)]
   file_path=/scratch/mary/grid_files/nc/um_n48e_pgrid.nc
   var_id=land_area_fraction

.. warning:: The files referred to by each grid definition **must** be visible
   to the host computer that will be running the Inline Regridder app.

.. note:: The Inline Regridder app does not currently support inverting a land-sea
   mask (e.g. to convert it from a land mask to a sea mask, or vice versa). If
   this is required then an inverted version of the grid should first be created
   off-line and the resulting file referenced via a separate grid definition
   in the app config file.

REGRIDDER DEFINITIONS
---------------------

Config file section: ``[namelist:regridders]``

The ``regridders`` namelist portion of the app config file is used to configure
any regridders that are required during the execution of the Inline Regridder app.
Each regridder definition contains a reference to a target grid (as described above),
the path to a Python class that will be used to perform the regridding, plus any
arguments to pass to the initialisation method for that class.

.. code-block:: ini

   [namelist:regridders(default)]
   target_grid=um_n48e_pgrid
   scheme=iris.analysis.AreaWeighted
   scheme_args=mdtol=1

The value of the ``target_grid`` option must be the name of one of the grids
specified in the ``grids`` namelist (see `Grid Definitions`_).

The ``scheme`` argument is used to specify the *full path* to the Python class
which implements the desired regridding algorithm. At present, the class must be
either one of the Iris regridder classes (e.g. ``iris.analysis.AreaWeighted``) or
else a custom class that is derived from one of the Iris classes.

.. note:: At runtime the specified regridder class must be resolvable from the
   module search path. In other words, it must be importable.

The ``scheme_args`` option may be used to specify simple arguments (i.e. Python
primitives, not objects) that will be passed to the initialisation method of the
regridder class. The arguments are evaluated (safely) before being handed over.
Thus, the '1' in the ``mdtol=1`` example above would be evaluated and passed as
an integer value via the mdtol argument. If it was specified as, say, '1.0' then
it would be passed as a Python float.

The value of the ``scheme_args`` option may be enclosed in parentheses if it
aids clarity, e.g. ``scheme_args=(mdtol=1, astr='foo')``.

UM OPTIONS
----------

Config file section: ``[um]``

This configuration section permits specification of options pertaining to the
Unified Model.

.. code-block:: ini

   [um]
   cylc_task_name=atmos_main
   sentinel_file_ext=.arch

The ``cylc_task_name`` option is used to specify the name of the cylc task that
runs each UM integration step.

The ``sentinel_file_ext`` option is used to specify the filename extension that
is used to flag model output files that are being processed by the postproc
application. It is used by the Inline Regridder app to identify the subset of
possible model data files that need to be loaded at a particular cycle point.

If the filename extension is set to an empty string then the filtering of input
filenames based on sentinel files is not carried out (this is also the case when
the app is *not* running under the control of a Rose suite). Conversely, if the
filename extension is defined, but none of the target data files have an associated
sentinel file, then *no model data is loaded*.  

Running the Application
=======================

The Inline Regridder application can be run either manually at the shell command
line or automatically under the control of a Rose suite. Both methods are described
in general terms in the :doc:`/invoking` chapter. The guidance in that chapter is
largely applicable to the current context.

Manual Invocation
-----------------

To run the app manually from the command line, type the following:

.. code-block:: bash

    % export AFTERBURNER_HOME_DIR=<path-to-afterburner-home-dir>
    % $AFTERBURNER_HOME_DIR/bin/apprun.sh InlineRegridder -c <config-file> [options]

An app config file, as described in the previous section, must be specified via
the ``-c`` (or ``--config-file``) option. Additional command-line options are
described below; often it is desirable to turn on the ``-v`` (or ``--verbose``)
option in order to see progress messages.

The initial ``export`` command above is not needed if the AFTERBURNER_HOME_DIR
shell variable is already defined in, for example, one of your shell start-up
scripts. Likewise, if the directory ``$AFTERBURNER_HOME_DIR/bin`` is included in
your command search path, then the second command can be shortened to plain
``% apprun.sh ...``.

If you have checked out (or exported) a working copy of the `Afterburner code base
<https://code.metoffice.gov.uk/trac/afterburner/browser/turbofan/trunk>`_ then you
can, if desired, set the AFTERBURNER_HOME_DIR variable to point to the directory
containing that working copy.

Invoking the Inline Regridder app manually will of course only run it once.
Typically, however, you'll want to run the app at regular cycle points during
the execution of a Rose/cylc suite. This approach is described in the next section.

Invocation from a Rose/Cylc Suite
---------------------------------

Firstly, create a copy of the `u-ce479`_ sample Rose suite (login required).

Next, modify the app config file for the Inline Regridder application (i.e. the
file ``app/inline_regridder/rose-app.conf``), and also the ``suite.rc`` file, to
suit your particular data source locations and processing requirements.

At this point you can either run the suite in stand-alone mode, or you can copy
the ``app`` directory over to an existing Rose suite and run (or restart) it.
In the latter case it will be necessary to modify the suite's dependency graph
(in the ``suite.rc`` file) so that the ``inline_regridder`` task is invoked at
the desired cycle points. Please consult the relevant Rose and cylc documentation
for further guidance on how to do this.

.. note:: When the Inline Regridder app is executed as part of a Rose/cylc suite,
   any output messages will normally be directed to Rose's standard log files
   (which can be viewed by running the Rose command ``rose suite-log``).

Command-Line Options
--------------------

Command-line options can be viewed by invoking the app with the ``-h`` (or ``--help``)
option, as shown below::

    % apprun.sh --help
    Usage: apprun.sh <app_name> [options] [arguments]

    % apprun.sh InlineRegridder --help
    Usage: InlineRegridder [-h] [-V] [-D | -q | -v] -c CONFIG_FILE

    Inline Regridder: regrids climate model data.

    optional arguments:
      -h, --help            Show this help message and exit
      -V, --version         Show Afterburner version number and exit
      -D, --debug           Enable debug message mode
      -q, --quiet           Enable quiet message mode
      -v, --verbose         Enable verbose message mode
      -c CONFIG_FILE, --config-file CONFIG_FILE
                            Pathname of app configuration file

These options are fairly self-explanatory. Note, however, that the -D, -q and -v
options are mutually exclusive.

Notes for users of the prototype Inline Regridder app
=====================================================

If you have previously used the early prototype version (v0.1.0b1) of the Inline
Regridder app and you wish to update and reuse the associated app configuration
then you'll need to make the following minor changes to the ``rose-app.conf`` file.
This is best done manually using your favourite text editor. Usually you'll want
to take a copy of this file before modifying it.

* Update all diagnostic options named ``suite`` to ``suite_name``

* Update all diagnostic options named ``model`` to ``model_name``

* Update all diagnostic options named ``var_name`` to ``var_id`` (Note, however,
  that the ``var_name`` option does have a separate use - see the
  `Standard Name, Long Name, Variable Name & Units`_ section)

.. Links below are referenced elsewhere in this document.

.. _u-ce479: https://code.metoffice.gov.uk/trac/roses-u/browser/c/e/4/7/9/trunk

.. _netcdf.save: https://scitools.org.uk/iris/docs/latest/iris/iris/fileformats/netcdf.html#iris.fileformats.netcdf.save

.. _datetime.strftime: https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior
